<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture - ROUP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rust-based OpenMP/OpenACC Unified Parser - Safe, fast, and extensible">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ROUP Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ouankou/roup" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ouankou/roup/edit/main/docs/book/src/architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This document explains ROUP's internal design, from lexical analysis to the C FFI boundary.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>ROUP is structured in three main layers:</p>
<pre><code>┌─────────────────────────────────────┐
│   C/C++ Applications                │
├─────────────────────────────────────┤
│   C FFI Layer (16 functions)        │  ← ~60 lines of unsafe code (0.9%)
├─────────────────────────────────────┤
│   Rust API (Parser + IR)            │  ← 100% safe Rust
├─────────────────────────────────────┤
│   Lexer (nom-based)                  │  ← Token extraction
└─────────────────────────────────────┘
</code></pre>
<p><strong>Key Design Principles:</strong></p>
<ul>
<li><strong>Safety First</strong>: 99.1% safe Rust code</li>
<li><strong>Zero-Copy</strong>: Minimal allocations during parsing</li>
<li><strong>Error Recovery</strong>: Detailed error messages with location info</li>
<li><strong>Language Agnostic</strong>: Supports C, C++, and Fortran</li>
</ul>
<hr />
<h2 id="lexer-layer"><a class="header" href="#lexer-layer">Lexer Layer</a></h2>
<p><strong>Location</strong>: <code>src/lexer.rs</code></p>
<p>The lexer transforms raw OpenMP pragma text into a stream of tokens.</p>
<h3 id="tokenization-process"><a class="header" href="#tokenization-process">Tokenization Process</a></h3>
<pre><code class="language-rust">Input:  "#pragma omp parallel num_threads(4)"
         ↓
Tokens: [
    Pragma("#pragma omp"),
    Identifier("parallel"),
    Identifier("num_threads"),
    LParen,
    Integer(4),
    RParen
]</code></pre>
<h3 id="token-types"><a class="header" href="#token-types">Token Types</a></h3>
<pre><code class="language-rust">pub enum Token&lt;'a&gt; {
    Identifier(&amp;'a str),      // parallel, private, shared
    Integer(i64),              // 4, 100, 256
    Float(f64),                // 2.5, 1.0e-6
    String(&amp;'a str),           // "filename.txt"
    LParen,                    // (
    RParen,                    // )
    Comma,                     // ,
    Colon,                     // :
    Plus,                      // +
    Minus,                     // -
    Star,                      // *
    // ... more operators
}</code></pre>
<h3 id="lexer-implementation"><a class="header" href="#lexer-implementation">Lexer Implementation</a></h3>
<p><strong>Technology</strong>: Built with <a href="https://github.com/rust-bakery/nom">nom</a> parser combinators</p>
<p><strong>Why nom?</strong></p>
<ul>
<li><strong>Zero-copy</strong>: Works directly on input &amp;str, no allocations</li>
<li><strong>Composable</strong>: Small parsers combine into larger ones</li>
<li><strong>Error-rich</strong>: Detailed error messages with position</li>
<li><strong>Well-established</strong>: Widely used parser combinator library</li>
</ul>
<p><strong>Example Lexer Function:</strong></p>
<pre><code class="language-rust">// Parse an identifier: alphanumeric + underscores
fn identifier(input: &amp;str) -&gt; IResult&lt;&amp;str, Token&gt; {
    let (remaining, matched) = take_while1(|c: char| {
        c.is_alphanumeric() || c == '_'
    })(input)?;
    
    Ok((remaining, Token::Identifier(matched)))
}</code></pre>
<hr />
<h2 id="parser-layer"><a class="header" href="#parser-layer">Parser Layer</a></h2>
<p><strong>Location</strong>: <code>src/parser/</code></p>
<p>The parser converts token streams into a structured Intermediate Representation (IR).</p>
<h3 id="parser-modules"><a class="header" href="#parser-modules">Parser Modules</a></h3>
<pre><code>src/parser/
├── mod.rs          # Main parser entry point
├── directive.rs    # Directive parsing (parallel, for, task, etc.)
├── clause.rs       # Clause parsing (private, reduction, etc.)
└── openmp.rs       # OpenMP-specific parsing logic
</code></pre>
<h3 id="parsing-phases"><a class="header" href="#parsing-phases">Parsing Phases</a></h3>
<h4 id="phase-1-directive-recognition"><a class="header" href="#phase-1-directive-recognition">Phase 1: Directive Recognition</a></h4>
<pre><code class="language-rust">Input tokens: [Identifier("parallel"), Identifier("for"), ...]
               ↓
Directive:    DirectiveKind::ParallelFor</code></pre>
<p>Supports 120+ directive types from OpenMP 3.0 through 6.0.</p>
<h4 id="phase-2-clause-parsing"><a class="header" href="#phase-2-clause-parsing">Phase 2: Clause Parsing</a></h4>
<pre><code class="language-rust">Input tokens: [Identifier("num_threads"), LParen, Integer(4), RParen]
               ↓
Clause:       Clause::NumThreads(IntegerExpr(4))</code></pre>
<p>Parses 92+ clause types with full argument validation.</p>
<h4 id="phase-3-ir-construction"><a class="header" href="#phase-3-ir-construction">Phase 3: IR Construction</a></h4>
<pre><code class="language-rust">DirectiveIR {
    kind: DirectiveKind::ParallelFor,
    clauses: vec![
        Clause::NumThreads(IntegerExpr(4)),
        Clause::Private(vec!["i", "j"]),
    ],
    location: SourceLocation { line: 1, column: 1 },
    language: Language::C,
}</code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Errors include detailed context:</p>
<pre><code class="language-rust">ParseError {
    message: "Expected ')' after num_threads value",
    location: SourceLocation { line: 1, column: 27 },
    context: "#pragma omp parallel num_threads(4",
                                              ^
}</code></pre>
<hr />
<h2 id="intermediate-representation-ir"><a class="header" href="#intermediate-representation-ir">Intermediate Representation (IR)</a></h2>
<p><strong>Location</strong>: <code>src/ir/</code></p>
<p>The IR is the central data structure representing parsed OpenMP directives.</p>
<h3 id="ir-structure"><a class="header" href="#ir-structure">IR Structure</a></h3>
<pre><code class="language-rust">pub struct DirectiveIR {
    pub kind: DirectiveKind,           // What directive?
    pub clauses: Vec&lt;Clause&gt;,          // What clauses?
    pub location: SourceLocation,      // Where in source?
    pub language: Language,            // C, C++, or Fortran?
}</code></pre>
<h3 id="directive-kinds"><a class="header" href="#directive-kinds">Directive Kinds</a></h3>
<pre><code class="language-rust">pub enum DirectiveKind {
    // Parallel constructs
    Parallel,
    ParallelFor,
    ParallelSections,
    
    // Work-sharing
    For,
    Sections,
    Section,
    Single,
    
    // Tasking
    Task,
    TaskLoop,
    TaskWait,
    TaskGroup,
    
    // Device offloading
    Target,
    TargetData,
    TargetUpdate,
    Teams,
    
    // Synchronization
    Barrier,
    Critical,
    Atomic,
    Ordered,
    
    // SIMD
    Simd,
    DeclareSimd,
    
    // Advanced (OpenMP 5.0+)
    Metadirective,
    DeclareVariant,
    Loop,
    
    // ... 120+ total directives
}</code></pre>
<h3 id="clause-types"><a class="header" href="#clause-types">Clause Types</a></h3>
<pre><code class="language-rust">pub enum Clause {
    // Thread management
    NumThreads(IntegerExpr),
    If(Condition),
    
    // Data sharing
    Private(Vec&lt;Variable&gt;),
    Shared(Vec&lt;Variable&gt;),
    FirstPrivate(Vec&lt;Variable&gt;),
    LastPrivate(Vec&lt;Variable&gt;),
    
    // Reductions
    Reduction {
        operator: ReductionOperator,
        variables: Vec&lt;Variable&gt;,
    },
    
    // Scheduling
    Schedule {
        kind: ScheduleKind,
        chunk_size: Option&lt;IntegerExpr&gt;,
    },
    
    // Loop control
    Collapse(usize),
    Ordered,
    Nowait,
    
    // Defaults
    Default(DefaultKind),
    
    // ... 92+ total clauses
}</code></pre>
<h3 id="supporting-types"><a class="header" href="#supporting-types">Supporting Types</a></h3>
<pre><code class="language-rust">pub enum ScheduleKind {
    Static,
    Dynamic,
    Guided,
    Auto,
    Runtime,
}

pub enum ReductionOperator {
    Add,         // +
    Subtract,    // -
    Multiply,    // *
    BitAnd,      // &amp;
    BitOr,       // |
    BitXor,      // ^
    LogicalAnd,  // &amp;&amp;
    LogicalOr,   // ||
    Min,
    Max,
}

pub enum DefaultKind {
    Shared,
    None,
    Private,
    FirstPrivate,
}

pub enum Language {
    C,
    Cpp,
    Fortran,
}</code></pre>
<hr />
<h2 id="c-ffi-layer"><a class="header" href="#c-ffi-layer">C FFI Layer</a></h2>
<p><strong>Location</strong>: <code>src/c_api.rs</code></p>
<p>The FFI layer exposes a minimal unsafe pointer-based API to C/C++.</p>
<h3 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h3>
<p><strong>Goal</strong>: Provide a traditional C API (malloc/free pattern) with minimal unsafe code.</p>
<p><strong>Achieved</strong>:</p>
<ul>
<li><strong>16 functions</strong>: Complete C API surface</li>
<li><strong>~60 lines of unsafe</strong>: Only at FFI boundary (~0.9% of file)</li>
<li><strong>Standard patterns</strong>: Familiar to C programmers</li>
<li><strong>Safe internals</strong>: All business logic in safe Rust</li>
</ul>
<h3 id="ffi-functions"><a class="header" href="#ffi-functions">FFI Functions</a></h3>
<h4 id="lifecycle-functions-3"><a class="header" href="#lifecycle-functions-3">Lifecycle Functions (3)</a></h4>
<pre><code class="language-c">// Parse directive, returns pointer or NULL
OmpDirective* roup_parse(const char* input);

// Free directive (required)
void roup_directive_free(OmpDirective* directive);

// Free clause (not usually needed - owned by directive)
void roup_clause_free(OmpClause* clause);
</code></pre>
<h4 id="directive-query-functions-3"><a class="header" href="#directive-query-functions-3">Directive Query Functions (3)</a></h4>
<pre><code class="language-c">// Get directive type (integer)
int32_t roup_directive_kind(const OmpDirective* directive);

// Get number of clauses
int32_t roup_directive_clause_count(const OmpDirective* directive);

// Create iterator over clauses
OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);
</code></pre>
<h4 id="iterator-functions-2"><a class="header" href="#iterator-functions-2">Iterator Functions (2)</a></h4>
<pre><code class="language-c">// Get next clause (returns 1 if available, 0 if done)
int32_t roup_clause_iterator_next(OmpClauseIterator* iter, OmpClause** out);

// Free iterator
void roup_clause_iterator_free(OmpClauseIterator* iter);
</code></pre>
<h4 id="clause-query-functions-4"><a class="header" href="#clause-query-functions-4">Clause Query Functions (4)</a></h4>
<pre><code class="language-c">// Get clause type (0=num_threads, 2=private, etc.)
int32_t roup_clause_kind(const OmpClause* clause);

// Get schedule kind for schedule clauses
int32_t roup_clause_schedule_kind(const OmpClause* clause);

// Get reduction operator for reduction clauses
int32_t roup_clause_reduction_operator(const OmpClause* clause);

// Get default data sharing
int32_t roup_clause_default_data_sharing(const OmpClause* clause);
</code></pre>
<h4 id="variable-list-functions-4"><a class="header" href="#variable-list-functions-4">Variable List Functions (4)</a></h4>
<pre><code class="language-c">// Get variable list from clause
OmpStringList* roup_clause_variables(const OmpClause* clause);

// Get list length
int32_t roup_string_list_len(const OmpStringList* list);

// Get string at index
const char* roup_string_list_get(const OmpStringList* list, int32_t index);

// Free string list
void roup_string_list_free(OmpStringList* list);
</code></pre>
<h3 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h3>
<p><strong>Ownership Rules:</strong></p>
<ol>
<li><strong>Directives</strong>: Created by <code>roup_parse()</code>, freed by <code>roup_directive_free()</code></li>
<li><strong>Iterators</strong>: Created by <code>roup_directive_clauses_iter()</code>, freed by <code>roup_clause_iterator_free()</code></li>
<li><strong>String Lists</strong>: Created by <code>roup_clause_variables()</code>, freed by <code>roup_string_list_free()</code></li>
<li><strong>Clauses</strong>: Owned by directive, DO NOT call <code>roup_clause_free()</code> on them</li>
</ol>
<p><strong>Pattern</strong>: Standard C malloc/free, familiar to all C programmers.</p>
<h3 id="safety-boundaries"><a class="header" href="#safety-boundaries">Safety Boundaries</a></h3>
<h4 id="the-60-lines-of-unsafe"><a class="header" href="#the-60-lines-of-unsafe">The ~60 Lines of Unsafe</a></h4>
<p>All unsafe code is confined to FFI boundary operations:</p>
<p><strong>1. Reading C Strings (2 places)</strong></p>
<pre><code class="language-rust">// Safety: Caller must ensure input is valid null-terminated C string
unsafe {
    CStr::from_ptr(input).to_str()
}</code></pre>
<p><strong>Checks:</strong></p>
<ul>
<li>✅ NULL pointer check before unsafe</li>
<li>✅ UTF-8 validation with error return</li>
<li>✅ No memory writes, only reads</li>
</ul>
<p><strong>2. Writing to Output Pointers (multiple places)</strong></p>
<pre><code class="language-rust">// Safety: Caller must ensure out is valid, aligned, writable
unsafe {
    *out = value;
}</code></pre>
<p><strong>Checks:</strong></p>
<ul>
<li>✅ NULL pointer check before unsafe</li>
<li>✅ Only writes primitive types (i32, u32, pointers)</li>
<li>✅ Single write operation, no loops</li>
</ul>
<p><strong>3. Pointer Manipulation for Iterators</strong></p>
<pre><code class="language-rust">// Safety: Internal Box pointer management
unsafe {
    Box::from_raw(ptr)
}</code></pre>
<p><strong>Checks:</strong></p>
<ul>
<li>✅ NULL pointer check</li>
<li>✅ Pointer created by Box::into_raw()</li>
<li>✅ No double-free (consumed on free)</li>
</ul>
<h3 id="why-minimal-unsafe-is-necessary"><a class="header" href="#why-minimal-unsafe-is-necessary">Why Minimal Unsafe is Necessary</a></h3>
<p><strong>Cannot avoid unsafe for FFI:</strong></p>
<ul>
<li>Reading C strings requires <code>CStr::from_ptr()</code> (unsafe)</li>
<li>Writing to C pointers requires dereference (unsafe)</li>
<li>This is standard Rust FFI practice</li>
</ul>
<p><strong>Alternative approaches considered:</strong></p>
<p>❌ <strong>Zero unsafe</strong>: Would require C programs to build strings byte-by-byte (40x slower, unusable)</p>
<p>❌ <strong>Handle-based API</strong>: Would need global registry with more unsafe code (50+ blocks)</p>
<p>✅ <strong>Minimal unsafe pointer API</strong>: Only ~60 lines, standard C patterns, practical performance</p>
<p>See <a href="https://github.com/ouankou/roup/blob/main/AGENTS.md">AGENTS.md</a> for the official API architecture documentation.</p>
<hr />
<h2 id="data-flow-example"><a class="header" href="#data-flow-example">Data Flow Example</a></h2>
<p>Let's trace a complete parse operation:</p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<pre><code class="language-c">const char* input = "#pragma omp parallel for num_threads(4) private(i)";
OmpDirective* dir = roup_parse(input);
</code></pre>
<h3 id="step-1-ffi-boundary-c--rust"><a class="header" href="#step-1-ffi-boundary-c--rust">Step 1: FFI Boundary (C → Rust)</a></h3>
<pre><code class="language-rust">// src/c_api.rs
#[no_mangle]
pub extern "C" fn roup_parse(input: *const c_char) -&gt; *mut OmpDirective {
    // NULL check
    if input.is_null() {
        return std::ptr::null_mut();
    }
    
    // Read C string (unsafe #1)
    let rust_str = unsafe {
        CStr::from_ptr(input).to_str().ok()?
    };
    
    // Call safe parser
    let directive_ir = parser::parse(rust_str).ok()?;
    
    // Box and return pointer
    Box::into_raw(Box::new(directive_ir))
}</code></pre>
<h3 id="step-2-lexer-pure-rust"><a class="header" href="#step-2-lexer-pure-rust">Step 2: Lexer (Pure Rust)</a></h3>
<pre><code class="language-rust">// src/lexer.rs
tokenize("#pragma omp parallel for num_threads(4) private(i)")
  ↓
[
    Pragma("#pragma omp"),
    Identifier("parallel"),
    Identifier("for"),
    Identifier("num_threads"),
    LParen,
    Integer(4),
    RParen,
    Identifier("private"),
    LParen,
    Identifier("i"),
    RParen,
]</code></pre>
<h3 id="step-3-parser-pure-rust"><a class="header" href="#step-3-parser-pure-rust">Step 3: Parser (Pure Rust)</a></h3>
<pre><code class="language-rust">// src/parser/mod.rs
parse_directive(tokens)
  ↓
DirectiveIR {
    kind: DirectiveKind::ParallelFor,
    clauses: vec![
        Clause::NumThreads(IntegerExpr(4)),
        Clause::Private(vec!["i"]),
    ],
    location: SourceLocation { line: 1, column: 1 },
    language: Language::C,
}</code></pre>
<h3 id="step-4-ffi-boundary-rust--c"><a class="header" href="#step-4-ffi-boundary-rust--c">Step 4: FFI Boundary (Rust → C)</a></h3>
<pre><code class="language-rust">// Return pointer to C
Box::into_raw(Box::new(directive_ir)) → 0x7fff12340000</code></pre>
<h3 id="step-5-c-queries"><a class="header" href="#step-5-c-queries">Step 5: C Queries</a></h3>
<pre><code class="language-c">int32_t kind = roup_directive_kind(dir);           // 28 (ParallelFor)
int32_t count = roup_directive_clause_count(dir);  // 2
</code></pre>
<h3 id="step-6-cleanup"><a class="header" href="#step-6-cleanup">Step 6: Cleanup</a></h3>
<pre><code class="language-c">roup_directive_free(dir);  // Calls Box::from_raw() and drops
</code></pre>
<hr />
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time Complexity</a></h3>
<ul>
<li><strong>Lexing</strong>: O(n) where n = input length</li>
<li><strong>Parsing</strong>: O(n × m) where m = average clause complexity (~O(n) in practice)</li>
<li><strong>IR Construction</strong>: O(c) where c = number of clauses</li>
<li><strong>FFI Call Overhead</strong>: ~10ns per call</li>
</ul>
<h3 id="space-complexity"><a class="header" href="#space-complexity">Space Complexity</a></h3>
<ul>
<li><strong>Lexer</strong>: O(1) - zero-copy, works on &amp;str</li>
<li><strong>Parser</strong>: O(c) - allocates clause vector</li>
<li><strong>IR</strong>: O(c) - owns clause data</li>
<li><strong>FFI</strong>: O(1) - pointer conversion only</li>
</ul>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<p>Typical directive parsing:</p>
<div class="table-wrapper"><table><thead><tr><th>Directive</th><th>Time</th><th>Allocations</th></tr></thead><tbody>
<tr><td><code>#pragma omp parallel</code></td><td>~500ns</td><td>1 (DirectiveIR)</td></tr>
<tr><td><code>#pragma omp parallel for num_threads(4)</code></td><td>~800ns</td><td>2 (DirectiveIR + 1 clause)</td></tr>
<tr><td><code>#pragma omp parallel for private(i,j,k) reduction(+:sum)</code></td><td>~1.2µs</td><td>3 (DirectiveIR + 2 clauses)</td></tr>
</tbody></table>
</div>
<p><strong>Compare to old handle-based API</strong>: 40x fewer FFI calls, 320x faster string building.</p>
<hr />
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<h3 id="safe-concurrency"><a class="header" href="#safe-concurrency">Safe Concurrency</a></h3>
<p><strong>Parser</strong>: Thread-safe, can parse from multiple threads simultaneously</p>
<pre><code class="language-rust">// Safe to do in parallel
std::thread::spawn(|| {
    let dir1 = parse("#pragma omp parallel");
});
std::thread::spawn(|| {
    let dir2 = parse("#pragma omp for");
});</code></pre>
<p><strong>IR</strong>: Immutable after construction, safe to share across threads</p>
<p><strong>FFI</strong>: Each directive is independent, safe to parse in parallel</p>
<h3 id="unsafe-patterns-user-responsibility"><a class="header" href="#unsafe-patterns-user-responsibility">Unsafe Patterns (User Responsibility)</a></h3>
<p>❌ <strong>Sharing directive across threads without synchronization</strong></p>
<pre><code class="language-c">// Thread 1
roup_directive_free(dir);

// Thread 2 (at same time)
roup_directive_kind(dir);  // Use-after-free!
</code></pre>
<p>❌ <strong>Double-free</strong></p>
<pre><code class="language-c">roup_directive_free(dir);
roup_directive_free(dir);  // Undefined behavior!
</code></pre>
<p>✅ <strong>Safe multi-threaded usage</strong></p>
<pre><code class="language-c">// Each thread has its own directive
OmpDirective* dir1 = roup_parse("#pragma omp parallel");  // Thread 1
OmpDirective* dir2 = roup_parse("#pragma omp for");       // Thread 2
</code></pre>
<hr />
<h2 id="error-handling-strategy"><a class="header" href="#error-handling-strategy">Error Handling Strategy</a></h2>
<h3 id="rust-api"><a class="header" href="#rust-api">Rust API</a></h3>
<p>Uses <code>Result&lt;DirectiveIR, ParseError&gt;</code>:</p>
<pre><code class="language-rust">match parse(input) {
    Ok(directive) =&gt; { /* use directive */ },
    Err(ParseError { message, location, .. }) =&gt; {
        eprintln!("Parse error at line {}: {}", location.line, message);
    }
}</code></pre>
<h3 id="c-api"><a class="header" href="#c-api">C API</a></h3>
<p>Uses <code>NULL</code> return values:</p>
<pre><code class="language-c">OmpDirective* dir = roup_parse(input);
if (dir == NULL) {
    fprintf(stderr, "Parse failed\n");
    return 1;
}
</code></pre>
<p><strong>Query functions</strong>: Return <code>-1</code> or safe defaults for NULL inputs</p>
<pre><code class="language-c">int32_t kind = roup_directive_kind(NULL);  // Returns -1, won't crash
</code></pre>
<hr />
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h2>
<h3 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h3>
<pre><code>Total Tests:    352
Unit Tests:     239
Integration:    51
Doc Tests:      62
</code></pre>
<h3 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h3>
<ol>
<li><strong>Lexer Tests</strong>: Token extraction, edge cases, Unicode</li>
<li><strong>Parser Tests</strong>: Directive recognition, clause parsing, error cases</li>
<li><strong>IR Tests</strong>: Structure validation, roundtrip serialization</li>
<li><strong>FFI Tests</strong>: NULL handling, memory safety, error propagation</li>
<li><strong>Concurrent Tests</strong>: Multi-threaded parsing, race detection</li>
</ol>
<h3 id="example-tests"><a class="header" href="#example-tests">Example Tests</a></h3>
<pre><code class="language-rust">#[test]
fn test_parallel_for_parsing() {
    let result = parse("#pragma omp parallel for num_threads(4)");
    assert!(result.is_ok());
    
    let directive = result.unwrap();
    assert_eq!(directive.kind, DirectiveKind::ParallelFor);
    assert_eq!(directive.clauses.len(), 1);
    
    match &amp;directive.clauses[0] {
        Clause::NumThreads(IntegerExpr(4)) =&gt; {},
        _ =&gt; panic!("Expected NumThreads(4)"),
    }
}

#[test]
fn test_ffi_null_safety() {
    let dir = roup_parse(std::ptr::null());
    assert!(dir.is_null());
    
    let kind = roup_directive_kind(std::ptr::null());
    assert_eq!(kind, -1);
}</code></pre>
<hr />
<h2 id="design-trade-offs"><a class="header" href="#design-trade-offs">Design Trade-offs</a></h2>
<h3 id="lexer-nom-vs-custom"><a class="header" href="#lexer-nom-vs-custom">Lexer: nom vs Custom</a></h3>
<p><strong>Chose nom:</strong></p>
<ul>
<li>✅ Zero-copy parsing</li>
<li>✅ Rich error messages</li>
<li>✅ Well-tested combinators</li>
<li>✅ Easy to extend</li>
</ul>
<p><strong>vs Custom Lexer:</strong></p>
<ul>
<li>❌ Learning curve</li>
<li>❌ Dependency on external crate</li>
</ul>
<h3 id="ir-owned-vs-borrowed"><a class="header" href="#ir-owned-vs-borrowed">IR: Owned vs Borrowed</a></h3>
<p><strong>Chose owned (Vec, String):</strong></p>
<ul>
<li>✅ Simple lifetime management</li>
<li>✅ Easy to pass across FFI</li>
<li>✅ No lifetime annotations in IR</li>
</ul>
<p><strong>vs Borrowed (&amp;str slices):</strong></p>
<ul>
<li>❌ Slower (allocations)</li>
<li>❌ More memory usage</li>
</ul>
<p><strong>Justification</strong>: Parsing is not the bottleneck; simplicity and FFI compatibility matter more.</p>
<h3 id="ffi-pointers-vs-handles"><a class="header" href="#ffi-pointers-vs-handles">FFI: Pointers vs Handles</a></h3>
<p><strong>Chose pointers:</strong></p>
<ul>
<li>✅ Standard C pattern (malloc/free)</li>
<li>✅ Minimal unsafe (~60 lines)</li>
<li>✅ Zero overhead</li>
<li>✅ Familiar to C programmers</li>
</ul>
<p><strong>vs Handle-based:</strong></p>
<ul>
<li>❌ 40x more FFI calls</li>
<li>❌ 50+ unsafe blocks</li>
<li>❌ Global registry complexity</li>
</ul>
<p>See <a href="https://github.com/ouankou/roup/blob/main/AGENTS.md#c-ffi-api-architecture">AGENTS.md - C FFI API Architecture</a> for details.</p>
<hr />
<h2 id="future-architecture-considerations"><a class="header" href="#future-architecture-considerations">Future Architecture Considerations</a></h2>
<h3 id="potential-enhancements"><a class="header" href="#potential-enhancements">Potential Enhancements</a></h3>
<ol>
<li><strong>Incremental Parsing</strong>: Parse only changed directives</li>
<li><strong>Streaming API</strong>: Parse large files without loading into memory</li>
<li><strong>Parallel Parsing</strong>: Parse multiple files concurrently</li>
<li><strong>AST Transformation</strong>: Optimize or transform directives</li>
<li><strong>Code Generation</strong>: Generate code from IR</li>
</ol>
<h3 id="stability-guarantees"><a class="header" href="#stability-guarantees">Stability Guarantees</a></h3>
<p><strong>⚠️ Pre-1.0 Experimental Status:</strong></p>
<p>ROUP is under active development. While we aim for stability, <strong>all APIs may change</strong> before v1.0.</p>
<p><strong>More stable</strong> (unlikely to change much):</p>
<ul>
<li>Core parsing functionality (<code>parse()</code> pattern)</li>
<li>C FFI function signatures (16 functions)</li>
<li>IR structure (major fields)</li>
</ul>
<p><strong>Less stable</strong> (may change between versions):</p>
<ul>
<li>Internal parser implementation details</li>
<li>Lexer token types and error structures</li>
<li>Error message formatting</li>
<li>Clause/directive kind integer values</li>
<li>Specific API details and return types</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>ROUP's architecture prioritizes:</p>
<ol>
<li><strong>Safety</strong>: 99.1% safe Rust, minimal unsafe only at FFI boundary</li>
<li><strong>Performance</strong>: Zero-copy lexing, minimal allocations</li>
<li><strong>Usability</strong>: Standard C patterns, clear error messages</li>
<li><strong>Correctness</strong>: 352 tests, comprehensive OpenMP support</li>
</ol>
<p>The three-layer design (Lexer → Parser → FFI) provides a clean separation of concerns while maintaining excellent performance characteristics.</p>
<p><strong>Key Metrics:</strong></p>
<ul>
<li>16 FFI functions</li>
<li>~60 lines of unsafe code (0.9%)</li>
<li>95 directives</li>
<li>91 clauses</li>
<li>352 tests</li>
<li>~500ns to parse simple directive</li>
</ul>
<p>For implementation details, see the source code in <code>src/</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="openmp-support.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="contributing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="openmp-support.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="contributing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
