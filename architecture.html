<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture - ROUP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rust-based OpenMP/OpenACC Unified Parser - Safe, fast, and extensible">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ROUP Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ouankou/roup" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ouankou/roup/edit/main/docs/book/src/architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This document explains ROUP's internal design, from lexical analysis to the C FFI boundary.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>ROUP is structured in three main layers:</p>
<pre><code class="language-text">┌─────────────────────────────────────┐
│   C/C++ Applications                │
├─────────────────────────────────────┤
│   C FFI Layer (16 functions)        │  ← ~60 lines of unsafe code (0.9%)
├─────────────────────────────────────┤
│   Rust API (Parser + IR)            │  ← 100% safe Rust
├─────────────────────────────────────┤
│   Lexer (nom-based)                  │  ← Token extraction
└─────────────────────────────────────┘
```text

**Key Design Principles:**
- **Safety First**: 99.1% safe Rust code
- **Zero-Copy**: Minimal allocations during parsing
- **Error Recovery**: Detailed error messages with location info
- **Language Agnostic**: Supports C, C++, and Fortran

---

## Lexer Layer

**Location**: `src/lexer.rs`

The lexer transforms raw OpenMP pragma text into a stream of tokens.

### Tokenization Process

```rust
Input:  "#pragma omp parallel num_threads(4)"
         ↓
Tokens: [
    Pragma("#pragma omp"),
    Identifier("parallel"),
    Identifier("num_threads"),
    LParen,
    Integer(4),
    RParen
]
```text

### Token Types

```rust
pub enum Token&lt;'a&gt; {
    Identifier(&amp;'a str),      // parallel, private, shared
    Integer(i64),              // 4, 100, 256
    Float(f64),                // 2.5, 1.0e-6
    String(&amp;'a str),           // "filename.txt"
    LParen,                    // (
    RParen,                    // )
    Comma,                     // ,
    Colon,                     // :
    Plus,                      // +
    Minus,                     // -
    Star,                      // *
    // ... more operators
}
```text

### Lexer Implementation

**Technology**: Built with [nom](https://github.com/rust-bakery/nom) parser combinators

**Why nom?**
- **Zero-copy**: Works directly on input &amp;str, no allocations
- **Composable**: Small parsers combine into larger ones
- **Error-rich**: Detailed error messages with position
- **Well-established**: Widely used parser combinator library

**Example Lexer Function:**

```rust
// Parse an identifier: alphanumeric + underscores
fn identifier(input: &amp;str) -&gt; IResult&lt;&amp;str, Token&gt; {
    let (remaining, matched) = take_while1(|c: char| {
        c.is_alphanumeric() || c == '_'
    })(input)?;
    
    Ok((remaining, Token::Identifier(matched)))
}
```text

---

## Parser Layer

**Location**: `src/parser/`

The parser converts token streams into a structured Intermediate Representation (IR).

### Parser Modules

```text
src/parser/
├── mod.rs          # Main parser entry point
├── directive.rs    # Directive parsing (parallel, for, task, etc.)
├── clause.rs       # Clause parsing (private, reduction, etc.)
└── openmp.rs       # OpenMP-specific parsing logic
```text

### Parsing Phases

#### Phase 1: Directive Recognition

```rust
Input tokens: [Identifier("parallel"), Identifier("for"), ...]
               ↓
Directive:    DirectiveKind::ParallelFor
```text

Supports 120+ directive types from OpenMP 3.0 through 6.0.

#### Phase 2: Clause Parsing

```rust
Input tokens: [Identifier("num_threads"), LParen, Integer(4), RParen]
               ↓
Clause:       Clause::NumThreads(IntegerExpr(4))
```text

Parses 92+ clause types with full argument validation.

#### Phase 3: IR Construction

```rust
DirectiveIR {
    kind: DirectiveKind::ParallelFor,
    clauses: vec![
        Clause::NumThreads(IntegerExpr(4)),
        Clause::Private(vec!["i", "j"]),
    ],
    location: SourceLocation { line: 1, column: 1 },
    language: Language::C,
}
```text

### Error Handling

Errors include detailed context:

```rust
ParseError {
    message: "Expected ')' after num_threads value",
    location: SourceLocation { line: 1, column: 27 },
    context: "#pragma omp parallel num_threads(4",
                                              ^
}
```text

---

## Intermediate Representation (IR)

**Location**: `src/ir/`

The IR is the central data structure representing parsed OpenMP directives.

### IR Structure

```rust
pub struct DirectiveIR {
    pub kind: DirectiveKind,           // What directive?
    pub clauses: Vec&lt;Clause&gt;,          // What clauses?
    pub location: SourceLocation,      // Where in source?
    pub language: Language,            // C, C++, or Fortran?
}
```text

### Directive Kinds

```rust
pub enum DirectiveKind {
    // Parallel constructs
    Parallel,
    ParallelFor,
    ParallelSections,
    
    // Work-sharing
    For,
    Sections,
    Section,
    Single,
    
    // Tasking
    Task,
    TaskLoop,
    TaskWait,
    TaskGroup,
    
    // Device offloading
    Target,
    TargetData,
    TargetUpdate,
    Teams,
    
    // Synchronization
    Barrier,
    Critical,
    Atomic,
    Ordered,
    
    // SIMD
    Simd,
    DeclareSimd,
    
    // Advanced (OpenMP 5.0+)
    Metadirective,
    DeclareVariant,
    Loop,
    
    // ... 120+ total directives
}
```text

### Clause Types

```rust
pub enum Clause {
    // Thread management
    NumThreads(IntegerExpr),
    If(Condition),
    
    // Data sharing
    Private(Vec&lt;Variable&gt;),
    Shared(Vec&lt;Variable&gt;),
    FirstPrivate(Vec&lt;Variable&gt;),
    LastPrivate(Vec&lt;Variable&gt;),
    
    // Reductions
    Reduction {
        operator: ReductionOperator,
        variables: Vec&lt;Variable&gt;,
    },
    
    // Scheduling
    Schedule {
        kind: ScheduleKind,
        chunk_size: Option&lt;IntegerExpr&gt;,
    },
    
    // Loop control
    Collapse(usize),
    Ordered,
    Nowait,
    
    // Defaults
    Default(DefaultKind),
    
    // ... 92+ total clauses
}
```text

### Supporting Types

```rust
pub enum ScheduleKind {
    Static,
    Dynamic,
    Guided,
    Auto,
    Runtime,
}

pub enum ReductionOperator {
    Add,         // +
    Subtract,    // -
    Multiply,    // *
    BitAnd,      // &amp;
    BitOr,       // |
    BitXor,      // ^
    LogicalAnd,  // &amp;&amp;
    LogicalOr,   // ||
    Min,
    Max,
}

pub enum DefaultKind {
    Shared,
    None,
    Private,
    FirstPrivate,
}

pub enum Language {
    C,
    Cpp,
    Fortran,
}
```text

---

## C FFI Layer

**Location**: `src/c_api.rs`

The FFI layer exposes a minimal unsafe pointer-based API to C/C++.

### Design Philosophy

**Goal**: Provide a traditional C API (malloc/free pattern) with minimal unsafe code.

**Achieved**:
- **16 functions**: Complete C API surface
- **~60 lines of unsafe**: Only at FFI boundary (~0.9% of file)
- **Standard patterns**: Familiar to C programmers
- **Safe internals**: All business logic in safe Rust

### FFI Functions

#### Lifecycle Functions (3)

```c
// Parse directive, returns pointer or NULL
OmpDirective* roup_parse(const char* input);

// Free directive (required)
void roup_directive_free(OmpDirective* directive);

// Free clause (not usually needed - owned by directive)
void roup_clause_free(OmpClause* clause);
```text

#### Directive Query Functions (3)

```c
// Get directive type (integer)
int32_t roup_directive_kind(const OmpDirective* directive);

// Get number of clauses
int32_t roup_directive_clause_count(const OmpDirective* directive);

// Create iterator over clauses
OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);
```text

#### Iterator Functions (2)

```c
// Get next clause (returns 1 if available, 0 if done)
int32_t roup_clause_iterator_next(OmpClauseIterator* iter, OmpClause** out);

// Free iterator
void roup_clause_iterator_free(OmpClauseIterator* iter);
```text

#### Clause Query Functions (4)

```c
// Get clause type (0=num_threads, 2=private, etc.)
int32_t roup_clause_kind(const OmpClause* clause);

// Get schedule kind for schedule clauses
int32_t roup_clause_schedule_kind(const OmpClause* clause);

// Get reduction operator for reduction clauses
int32_t roup_clause_reduction_operator(const OmpClause* clause);

// Get default data sharing
int32_t roup_clause_default_data_sharing(const OmpClause* clause);
```text

#### Variable List Functions (4)

```c
// Get variable list from clause
OmpStringList* roup_clause_variables(const OmpClause* clause);

// Get list length
int32_t roup_string_list_len(const OmpStringList* list);

// Get string at index
const char* roup_string_list_get(const OmpStringList* list, int32_t index);

// Free string list
void roup_string_list_free(OmpStringList* list);
```text

### Memory Model

**Ownership Rules:**
1. **Directives**: Created by `roup_parse()`, freed by `roup_directive_free()`
2. **Iterators**: Created by `roup_directive_clauses_iter()`, freed by `roup_clause_iterator_free()`
3. **String Lists**: Created by `roup_clause_variables()`, freed by `roup_string_list_free()`
4. **Clauses**: Owned by directive, DO NOT call `roup_clause_free()` on them

**Pattern**: Standard C malloc/free, familiar to all C programmers.

### Safety Boundaries

#### The ~60 Lines of Unsafe

All unsafe code is confined to FFI boundary operations:

**1. Reading C Strings (2 places)**
```rust
// Safety: Caller must ensure input is valid null-terminated C string
unsafe {
    CStr::from_ptr(input).to_str()
}
```text

**Checks:**
- ✅ NULL pointer check before unsafe
- ✅ UTF-8 validation with error return
- ✅ No memory writes, only reads

**2. Writing to Output Pointers (multiple places)**
```rust
// Safety: Caller must ensure out is valid, aligned, writable
unsafe {
    *out = value;
}
```text

**Checks:**
- ✅ NULL pointer check before unsafe
- ✅ Only writes primitive types (i32, u32, pointers)
- ✅ Single write operation, no loops

**3. Pointer Manipulation for Iterators**
```rust
// Safety: Internal Box pointer management
unsafe {
    Box::from_raw(ptr)
}
```text

**Checks:**
- ✅ NULL pointer check
- ✅ Pointer created by Box::into_raw()
- ✅ No double-free (consumed on free)

### Why Minimal Unsafe is Necessary

**Cannot avoid unsafe for FFI:**
- Reading C strings requires `CStr::from_ptr()` (unsafe)
- Writing to C pointers requires dereference (unsafe)
- This is standard Rust FFI practice

**Alternative approaches considered:**

❌ **Zero unsafe**: Would require C programs to build strings byte-by-byte (40x slower, unusable)

❌ **Handle-based API**: Would need global registry with more unsafe code (50+ blocks)

✅ **Minimal unsafe pointer API**: Only ~60 lines, standard C patterns, practical performance

See [AGENTS.md](https://github.com/ouankou/roup/blob/main/AGENTS.md) for the official API architecture documentation.

---

## Data Flow Example

Let's trace a complete parse operation:

### Input

```c
const char* input = "#pragma omp parallel for num_threads(4) private(i)";
OmpDirective* dir = roup_parse(input);
```text

### Step 1: FFI Boundary (C → Rust)

```rust
// src/c_api.rs
#[no_mangle]
pub extern "C" fn roup_parse(input: *const c_char) -&gt; *mut OmpDirective {
    // NULL check
    if input.is_null() {
        return std::ptr::null_mut();
    }
    
    // Read C string (unsafe #1)
    let rust_str = unsafe {
        CStr::from_ptr(input).to_str().ok()?
    };
    
    // Call safe parser
    let directive_ir = parser::parse(rust_str).ok()?;
    
    // Box and return pointer
    Box::into_raw(Box::new(directive_ir))
}
```text

### Step 2: Lexer (Pure Rust)

```rust
// src/lexer.rs
tokenize("#pragma omp parallel for num_threads(4) private(i)")
  ↓
[
    Pragma("#pragma omp"),
    Identifier("parallel"),
    Identifier("for"),
    Identifier("num_threads"),
    LParen,
    Integer(4),
    RParen,
    Identifier("private"),
    LParen,
    Identifier("i"),
    RParen,
]
```text

### Step 3: Parser (Pure Rust)

```rust
// src/parser/mod.rs
parse_directive(tokens)
  ↓
DirectiveIR {
    kind: DirectiveKind::ParallelFor,
    clauses: vec![
        Clause::NumThreads(IntegerExpr(4)),
        Clause::Private(vec!["i"]),
    ],
    location: SourceLocation { line: 1, column: 1 },
    language: Language::C,
}
```text

### Step 4: FFI Boundary (Rust → C)

```rust
// Return pointer to C
Box::into_raw(Box::new(directive_ir)) → 0x7fff12340000
```text

### Step 5: C Queries

```c
int32_t kind = roup_directive_kind(dir);           // 28 (ParallelFor)
int32_t count = roup_directive_clause_count(dir);  // 2
```text

### Step 6: Cleanup

```c
roup_directive_free(dir);  // Calls Box::from_raw() and drops
```text

---

## Performance Characteristics

### Time Complexity

- **Lexing**: O(n) where n = input length
- **Parsing**: O(n × m) where m = average clause complexity (~O(n) in practice)
- **IR Construction**: O(c) where c = number of clauses
- **FFI Call Overhead**: ~10ns per call

### Space Complexity

- **Lexer**: O(1) - zero-copy, works on &amp;str
- **Parser**: O(c) - allocates clause vector
- **IR**: O(c) - owns clause data
- **FFI**: O(1) - pointer conversion only

### Benchmarks

Typical directive parsing:

| Directive | Time | Allocations |
|-----------|------|-------------|
| `#pragma omp parallel` | ~500ns | 1 (DirectiveIR) |
| `#pragma omp parallel for num_threads(4)` | ~800ns | 2 (DirectiveIR + 1 clause) |
| `#pragma omp parallel for private(i,j,k) reduction(+:sum)` | ~1.2µs | 3 (DirectiveIR + 2 clauses) |

**Compare to old handle-based API**: 40x fewer FFI calls, 320x faster string building.

---

## Thread Safety

### Safe Concurrency

**Parser**: Thread-safe, can parse from multiple threads simultaneously

```rust
// Safe to do in parallel
std::thread::spawn(|| {
    let dir1 = parse("#pragma omp parallel");
});
std::thread::spawn(|| {
    let dir2 = parse("#pragma omp for");
});
```text

**IR**: Immutable after construction, safe to share across threads

**FFI**: Each directive is independent, safe to parse in parallel

### Unsafe Patterns (User Responsibility)

❌ **Sharing directive across threads without synchronization**
```c
// Thread 1
roup_directive_free(dir);

// Thread 2 (at same time)
roup_directive_kind(dir);  // Use-after-free!
```text

❌ **Double-free**
```c
roup_directive_free(dir);
roup_directive_free(dir);  // Undefined behavior!
```text

✅ **Safe multi-threaded usage**
```c
// Each thread has its own directive
OmpDirective* dir1 = roup_parse("#pragma omp parallel");  // Thread 1
OmpDirective* dir2 = roup_parse("#pragma omp for");       // Thread 2
```text

---

## Error Handling Strategy

### Rust API

Uses `Result&lt;DirectiveIR, ParseError&gt;`:

```rust
match parse(input) {
    Ok(directive) =&gt; { /* use directive */ },
    Err(ParseError { message, location, .. }) =&gt; {
        eprintln!("Parse error at line {}: {}", location.line, message);
    }
}
```text

### C API

Uses `NULL` return values:

```c
OmpDirective* dir = roup_parse(input);
if (dir == NULL) {
    fprintf(stderr, "Parse failed\n");
    return 1;
}
```text

**Query functions**: Return `-1` or safe defaults for NULL inputs

```c
int32_t kind = roup_directive_kind(NULL);  // Returns -1, won't crash
```text

---

## Testing Strategy

### Test Coverage

```text
Total Tests:    352
Unit Tests:     239
Integration:    51
Doc Tests:      62
```text

### Test Categories

1. **Lexer Tests**: Token extraction, edge cases, Unicode
2. **Parser Tests**: Directive recognition, clause parsing, error cases
3. **IR Tests**: Structure validation, roundtrip serialization
4. **FFI Tests**: NULL handling, memory safety, error propagation
5. **Concurrent Tests**: Multi-threaded parsing, race detection

### Example Tests

```rust
#[test]
fn test_parallel_for_parsing() {
    let result = parse("#pragma omp parallel for num_threads(4)");
    assert!(result.is_ok());
    
    let directive = result.unwrap();
    assert_eq!(directive.kind, DirectiveKind::ParallelFor);
    assert_eq!(directive.clauses.len(), 1);
    
    match &amp;directive.clauses[0] {
        Clause::NumThreads(IntegerExpr(4)) =&gt; {},
        _ =&gt; panic!("Expected NumThreads(4)"),
    }
}

#[test]
fn test_ffi_null_safety() {
    let dir = roup_parse(std::ptr::null());
    assert!(dir.is_null());
    
    let kind = roup_directive_kind(std::ptr::null());
    assert_eq!(kind, -1);
}
```text

---

## Design Trade-offs

### Lexer: nom vs Custom

**Chose nom:**
- ✅ Zero-copy parsing
- ✅ Rich error messages
- ✅ Well-tested combinators
- ✅ Easy to extend

**vs Custom Lexer:**
- ❌ Learning curve
- ❌ Dependency on external crate

### IR: Owned vs Borrowed

**Chose owned (Vec, String):**
- ✅ Simple lifetime management
- ✅ Easy to pass across FFI
- ✅ No lifetime annotations in IR

**vs Borrowed (&amp;str slices):**
- ❌ Slower (allocations)
- ❌ More memory usage

**Justification**: Parsing is not the bottleneck; simplicity and FFI compatibility matter more.

### FFI: Pointers vs Handles

**Chose pointers:**
- ✅ Standard C pattern (malloc/free)
- ✅ Minimal unsafe (~60 lines)
- ✅ Zero overhead
- ✅ Familiar to C programmers

**vs Handle-based:**
- ❌ 40x more FFI calls
- ❌ 50+ unsafe blocks
- ❌ Global registry complexity

See [AGENTS.md - C FFI API Architecture](https://github.com/ouankou/roup/blob/main/AGENTS.md#c-ffi-api-architecture) for details.

---

## Future Architecture Considerations

### Potential Enhancements

1. **Incremental Parsing**: Parse only changed directives
2. **Streaming API**: Parse large files without loading into memory
3. **Parallel Parsing**: Parse multiple files concurrently
4. **AST Transformation**: Optimize or transform directives
5. **Code Generation**: Generate code from IR

### Stability Guarantees

**⚠️ Pre-1.0 Experimental Status:**

ROUP is under active development. While we aim for stability, **all APIs may change** before v1.0.

**More stable** (unlikely to change much):
- Core parsing functionality (`parse()` pattern)
- C FFI function signatures (16 functions)
- IR structure (major fields)

**Less stable** (may change between versions):
- Internal parser implementation details
- Lexer token types and error structures
- Error message formatting
- Clause/directive kind integer values
- Specific API details and return types

---

## Summary

ROUP's architecture prioritizes:

1. **Safety**: 99.1% safe Rust, minimal unsafe only at FFI boundary
2. **Performance**: Zero-copy lexing, minimal allocations
3. **Usability**: Standard C patterns, clear error messages
4. **Correctness**: 352 tests, comprehensive OpenMP support

The three-layer design (Lexer → Parser → FFI) provides a clean separation of concerns while maintaining excellent performance characteristics.

**Key Metrics:**
- 16 FFI functions
- ~60 lines of unsafe code (0.9%)
- 95 directives
- 91 clauses
- 352 tests
- ~500ns to parse simple directive

For implementation details, see the source code in `src/`.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="line-continuations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="contributing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="line-continuations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="contributing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
