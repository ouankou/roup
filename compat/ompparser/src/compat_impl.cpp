/*
 * OpenMPIR.cpp - Minimal ompparser compatibility implementation using ROUP
 *
 * This provides ONLY the implementation (.cpp), using ompparser's headers
 * from the git submodule at compat/ompparser/ompparser/src/
 *
 * Copyright (c) 2025 ROUP Project
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <OpenMPIR.h>
#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <cstring>
#include <cstdint>
#include <sstream>
#include <string>
#include <vector>

// Include ROUP constants (auto-generated by build.rs from src/c_api.rs)
#include <roup_constants.h>

// Forward declarations for opaque ROUP types
struct OmpDirective;
struct OmpClause;
struct OmpStringList;
struct OmpDirectiveList;
struct OmpClauseIterator;

static constexpr uint32_t ROUP_REDUCTION_MODIFIER_TASK = 1u << 0;
static constexpr uint32_t ROUP_REDUCTION_MODIFIER_INSCAN = 1u << 1;
static constexpr uint32_t ROUP_REDUCTION_MODIFIER_DEFAULT = 1u << 2;
static constexpr uint32_t ROUP_SCHEDULE_MODIFIER_MONOTONIC = 1u << 0;
static constexpr uint32_t ROUP_SCHEDULE_MODIFIER_NONMONOTONIC = 1u << 1;
static constexpr uint32_t ROUP_SCHEDULE_MODIFIER_SIMD = 1u << 2;
static constexpr uint32_t ROUP_MAP_MODIFIER_ALWAYS = 1u << 0;
static constexpr uint32_t ROUP_MAP_MODIFIER_CLOSE = 1u << 1;
static constexpr uint32_t ROUP_MAP_MODIFIER_PRESENT = 1u << 2;
static constexpr uint32_t ROUP_MAP_MODIFIER_SELF = 1u << 3;
static constexpr uint32_t ROUP_MAP_MODIFIER_OMPX_HOLD = 1u << 4;

static OpenMPDirectiveKind mapRoupToOmpparserDirective(int32_t roup_kind);
static OpenMPDirectiveKind getEndDirectivePairedKind(int32_t roup_end_kind);
static void append_variables_to_clause(OpenMPClause* clause, OmpStringList* list);
static OpenMPClauseKind mapRoupToOmpparserClause(int32_t roup_kind);
static OpenMPMapClauseType mapRoupMapType(int32_t code);
static char* duplicate_c_string(const char* input);
static std::vector<OpenMPMapClauseModifier> mapRoupMapModifiers(uint32_t mask, bool include_mapper);
static void attach_variant_selector_from_roup(OpenMPVariantClause* clause, const OmpClause* roup_clause, void* exprParse(const char* expr));
static void convert_map_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void handle_dist_schedule_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void handle_schedule_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_clause_with_payload(
    OpenMPDirective* dir,
    const OmpClause* roup_clause,
    OpenMPClauseKind clause_kind,
    std::vector<OpenMPUsesAllocatorsClause*>& uses_allocators_clauses,
    void* exprParse(const char* expr),
    bool debug_logging);
static void convert_depobj_clause(OpenMPDirective* dir, const OmpClause* roup_clause, void* exprParse(const char* expr));
static void convert_depobj_update_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_depend_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_allocate_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_order_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_atomic_default_mem_order_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_size_expr_clause(OpenMPDirective* dir, const OmpClause* roup_clause, OpenMPClauseKind clause_kind);
static void convert_defaultmap_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_uses_allocators_clause(OpenMPDirective* dir, const OmpClause* roup_clause, std::vector<OpenMPUsesAllocatorsClause*>& uses_allocators_clauses);
static void convert_device_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_lastprivate_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_allocator_like_clause(OpenMPDirective* dir, const OmpClause* roup_clause, OpenMPClauseKind clause_kind);
static void convert_affinity_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_linear_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_variables_clause(OpenMPDirective* dir, const OmpClause* roup_clause, OpenMPClauseKind clause_kind);
static void convert_atomic_clause(OpenMPDirective* dir, const OmpClause* roup_clause, OpenMPClauseKind clause_kind);
static void convert_num_threads_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_collapse_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_if_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_proc_bind_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_bind_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_aligned_clause(OpenMPDirective* dir, const OmpClause* roup_clause, OpenMPClauseKind clause_kind);
static void convert_ordered_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_default_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_device_type_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_atomic_ordered_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_allocators_clause(OpenMPDirective* dir, const OmpClause* roup_clause);
static void convert_generic_clause(OpenMPDirective* dir, const OmpClause* roup_clause, OpenMPClauseKind clause_kind);

// Directive parameter kinds (mirrors src/c_api.rs)
static constexpr int ROUPO_PARAM_NONE = 0;
static constexpr int ROUPO_PARAM_IDENTIFIER_LIST = 1;
static constexpr int ROUPO_PARAM_IDENTIFIER = 2;
static constexpr int ROUPO_PARAM_MAPPER = 3;
static constexpr int ROUPO_PARAM_VARIANT_FUNCTION = 4;
static constexpr int ROUPO_PARAM_DEPOBJ = 5;
static constexpr int ROUPO_PARAM_SCAN = 6;
static constexpr int ROUPO_PARAM_CONSTRUCT = 7;
static constexpr int ROUPO_PARAM_CRITICAL = 8;
static constexpr int ROUPO_PARAM_FLUSH_LIST = 9;
static constexpr int ROUPO_PARAM_DECLARE_REDUCTION = 10;
static constexpr int ROUPO_PARAM_DECLARE_SIMD = 11;
static constexpr int ROUPO_DECLARE_MAPPER_ID_DEFAULT = 0;
static constexpr int ROUPO_DECLARE_MAPPER_ID_USER = 1;
static constexpr int ROUPO_DECLARE_MAPPER_ID_UNSPECIFIED = 2;

// Scan directive mode codes (mirrors src/c_api.rs)
static constexpr int ROUPO_SCAN_MODE_UNSPECIFIED = -1;
static constexpr int ROUPO_SCAN_MODE_EXCLUSIVE = 0;
static constexpr int ROUPO_SCAN_MODE_INCLUSIVE = 1;

// Construct parameter codes for cancel/cancellation-point
static constexpr int ROUPO_CONSTRUCT_UNKNOWN = -1;
static constexpr int ROUPO_CONSTRUCT_PARALLEL = 0;
static constexpr int ROUPO_CONSTRUCT_SECTIONS = 1;
static constexpr int ROUPO_CONSTRUCT_FOR = 2;
static constexpr int ROUPO_CONSTRUCT_TASKGROUP = 3;
static constexpr int ROUPO_CONSTRUCT_OTHER = 4;

// Uses-allocators codes returned by ROUP C API (mirror src/c_api.rs ordering)
enum RoupUsesAllocatorsKind {
    ROUPO_USES_ALLOC_DEFAULT = 0,
    ROUPO_USES_ALLOC_LARGE_CAP = 1,
    ROUPO_USES_ALLOC_CONST = 2,
    ROUPO_USES_ALLOC_HIGH_BW = 3,
    ROUPO_USES_ALLOC_LOW_LAT = 4,
    ROUPO_USES_ALLOC_CGROUP = 5,
    ROUPO_USES_ALLOC_PTEAM = 6,
    ROUPO_USES_ALLOC_THREAD = 7,
    ROUPO_USES_ALLOC_USER = 8,
};

static constexpr int ROUPO_IF_MODIFIER_UNSPECIFIED = -1;
static constexpr int ROUPO_IF_MODIFIER_PARALLEL = 0;
static constexpr int ROUPO_IF_MODIFIER_TASK = 1;
static constexpr int ROUPO_IF_MODIFIER_TASKLOOP = 2;
static constexpr int ROUPO_IF_MODIFIER_TARGET = 3;
static constexpr int ROUPO_IF_MODIFIER_TARGET_DATA = 4;
static constexpr int ROUPO_IF_MODIFIER_TARGET_ENTER_DATA = 5;
static constexpr int ROUPO_IF_MODIFIER_TARGET_EXIT_DATA = 6;
static constexpr int ROUPO_IF_MODIFIER_TARGET_UPDATE = 7;
static constexpr int ROUPO_IF_MODIFIER_SIMD = 8;
static constexpr int ROUPO_IF_MODIFIER_CANCEL = 9;
static constexpr int ROUPO_IF_MODIFIER_USER = 10;

static OpenMPBaseLang current_lang = Lang_C;

// ============================================================================
// ROUP C API Forward Declarations
// ============================================================================

extern "C" {
    // Opaque types from ROUP
    struct OmpDirective;
    struct OmpClause;
    struct OmpClauseIterator;
    struct OmpStringList;

    // Core parsing
    OmpDirective* roup_parse(const char* input);
    OmpDirective* roup_parse_with_language(const char* input, int32_t language);
    void roup_directive_free(OmpDirective* directive);

    // Directive queries
    int32_t roup_directive_kind(const OmpDirective* directive);
    int32_t roup_directive_clause_count(const OmpDirective* directive);
    OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);
    const char* roup_directive_name(const OmpDirective* directive);
    const char* roup_directive_parameter(const OmpDirective* directive);
    int32_t roup_directive_parameter_kind(const OmpDirective* directive);
    int32_t roup_directive_parameter_scan_mode(const OmpDirective* directive);
    int32_t roup_directive_parameter_construct_type(const OmpDirective* directive);
    OmpStringList* roup_directive_parameter_identifiers(const OmpDirective* directive);
    int32_t roup_directive_declare_mapper_identifier_kind(const OmpDirective* directive);
    const char* roup_directive_declare_mapper_user_identifier(const OmpDirective* directive);
    const char* roup_directive_declare_mapper_type(const OmpDirective* directive);
    const char* roup_directive_declare_mapper_variable(const OmpDirective* directive);
    int32_t roup_directive_declare_reduction_operator(const OmpDirective* directive);
    const char* roup_directive_declare_reduction_user_identifier(const OmpDirective* directive);
    OmpStringList* roup_directive_declare_reduction_types(const OmpDirective* directive);
    const char* roup_directive_declare_reduction_combiner(const OmpDirective* directive);
    const char* roup_directive_declare_reduction_initializer(const OmpDirective* directive);
    const char* roup_directive_declare_simd_target(const OmpDirective* directive);
    const char* roup_directive_critical_hint(const OmpDirective* directive);

    // Iterator operations (updated API with out parameter)
    int32_t roup_clause_iterator_next(OmpClauseIterator* iter, const OmpClause** out);
    void roup_clause_iterator_free(OmpClauseIterator* iter);

    // Clause queries
    int32_t roup_clause_kind(const OmpClause* clause);
    int32_t roup_clause_schedule_kind(const OmpClause* clause);
    uint32_t roup_clause_schedule_modifier_mask(const OmpClause* clause);
    const char* roup_clause_schedule_chunk(const OmpClause* clause);
    int32_t roup_clause_dist_schedule_kind(const OmpClause* clause);
    const char* roup_clause_dist_schedule_chunk(const OmpClause* clause);
    int32_t roup_clause_if_modifier(const OmpClause* clause);
    int32_t roup_clause_order_modifier(const OmpClause* clause);
    int32_t roup_clause_order_kind(const OmpClause* clause);
    const char* roup_clause_arguments(const OmpClause* clause);
    int32_t roup_clause_reduction_operator(const OmpClause* clause);
    int32_t roup_clause_map_type(const OmpClause* clause);
    uint32_t roup_clause_map_modifier_mask(const OmpClause* clause);
    const char* roup_clause_map_mapper(const OmpClause* clause);
    int32_t roup_clause_map_iterator_count(const OmpClause* clause);
    const char* roup_clause_map_iterator_type(const OmpClause* clause, int32_t index);
    const char* roup_clause_map_iterator_name(const OmpClause* clause, int32_t index);
    const char* roup_clause_map_iterator_start(const OmpClause* clause, int32_t index);
    const char* roup_clause_map_iterator_end(const OmpClause* clause, int32_t index);
    const char* roup_clause_map_iterator_step(const OmpClause* clause, int32_t index);
    int32_t roup_clause_linear_modifier(const OmpClause* clause);
    const char* roup_clause_linear_step(const OmpClause* clause);
    int32_t roup_clause_depend_type(const OmpClause* clause);
    int32_t roup_clause_depend_has_iterators(const OmpClause* clause);
    int32_t roup_clause_depend_iterator_count(const OmpClause* clause);
    const char* roup_clause_depend_iterator_type(const OmpClause* clause, int32_t index);
    const char* roup_clause_depend_iterator_name(const OmpClause* clause, int32_t index);
    const char* roup_clause_depend_iterator_start(const OmpClause* clause, int32_t index);
    const char* roup_clause_depend_iterator_end(const OmpClause* clause, int32_t index);
    const char* roup_clause_depend_iterator_step(const OmpClause* clause, int32_t index);
    int32_t roup_clause_grainsize_modifier(const OmpClause* clause);
    int32_t roup_clause_num_tasks_modifier(const OmpClause* clause);
    uint32_t roup_clause_reduction_modifier_mask(const OmpClause* clause);
    const char* roup_clause_reduction_user_identifier(const OmpClause* clause);
    const char* roup_clause_reduction_modifiers_text(const OmpClause* clause);
    int32_t roup_clause_reduction_space_after_colon(const OmpClause* clause);
    int32_t roup_clause_lastprivate_modifier(const OmpClause* clause);
    int32_t roup_clause_requires_count(const OmpClause* clause);
    int32_t roup_clause_requires_modifier(const OmpClause* clause, int32_t index);
    const char* roup_clause_requires_name(const OmpClause* clause, int32_t index);
    const char* roup_requires_modifier_name(int32_t code);
    OmpStringList* roup_clause_variables(const OmpClause* clause);
    int32_t roup_string_list_len(const OmpStringList* list);
    const char* roup_string_list_get(const OmpStringList* list, int32_t index);
    void roup_string_list_free(OmpStringList* list);

    int32_t roup_clause_default_data_sharing(const OmpClause* clause);
    int32_t roup_clause_defaultmap_behavior(const OmpClause* clause);
    int32_t roup_clause_defaultmap_category(const OmpClause* clause);
    int32_t roup_clause_uses_allocators_count(const OmpClause* clause);
    int32_t roup_clause_uses_allocator_kind(const OmpClause* clause, int32_t index);
    const char* roup_clause_uses_allocator_user(const OmpClause* clause, int32_t index);
    const char* roup_clause_uses_allocator_traits(const OmpClause* clause, int32_t index);
    int32_t roup_clause_device_modifier(const OmpClause* clause);
    const char* roup_clause_device_expression(const OmpClause* clause);
    int32_t roup_clause_depobj_update_dependence(const OmpClause* clause);
    const char* roup_clause_allocate_allocator(const OmpClause* clause);
    int32_t roup_clause_affinity_modifier(const OmpClause* clause);
    int32_t roup_clause_affinity_iterator_count(const OmpClause* clause);
    const char* roup_clause_affinity_iterator_type(const OmpClause* clause, int32_t index);
    const char* roup_clause_affinity_iterator_name(const OmpClause* clause, int32_t index);
    const char* roup_clause_affinity_iterator_start(const OmpClause* clause, int32_t index);
    const char* roup_clause_affinity_iterator_end(const OmpClause* clause, int32_t index);
    const char* roup_clause_affinity_iterator_step(const OmpClause* clause, int32_t index);
    const char* roup_clause_if_expression(const OmpClause* clause);
    const char* roup_clause_default_variant(const OmpClause* clause);
    int32_t roup_clause_order_modifier(const OmpClause* clause);
    int32_t roup_clause_order_kind(const OmpClause* clause);
    int32_t roup_clause_atomic_default_mem_order(const OmpClause* clause);
    int32_t roup_clause_proc_bind_policy(const OmpClause* clause);
    int32_t roup_clause_bind_modifier(const OmpClause* clause);
    int32_t roup_clause_device_type_kind(const OmpClause* clause);
    const char* roup_clause_grainsize_expr(const OmpClause* clause);
    const char* roup_clause_num_tasks_expr(const OmpClause* clause);
    int32_t roup_clause_allocator_kind(const OmpClause* clause);
    int32_t roup_clause_allocate_kind(const OmpClause* clause);
    const char* roup_clause_aligned_alignment(const OmpClause* clause);
    // Selector getters
    const char* roup_clause_selector_device_kind(const OmpClause* clause);
    const char* roup_clause_selector_device_num(const OmpClause* clause);
    const char* roup_clause_selector_device_num_score(const OmpClause* clause);
    OmpStringList* roup_clause_selector_device_isa(const OmpClause* clause);
    OmpStringList* roup_clause_selector_device_arch(const OmpClause* clause);
    const char* roup_clause_selector_impl_vendor(const OmpClause* clause);
    const char* roup_clause_selector_impl_vendor_score(const OmpClause* clause);
    const char* roup_clause_selector_impl_user_expression(const OmpClause* clause);
    const char* roup_clause_selector_impl_user_expression_score(const OmpClause* clause);
    OmpStringList* roup_clause_selector_impl_extensions(const OmpClause* clause);
    OmpStringList* roup_clause_selector_impl_extension_scores(const OmpClause* clause);
    const char* roup_clause_selector_user_condition(const OmpClause* clause);
    OmpStringList* roup_clause_selector_constructs(const OmpClause* clause);
    OmpStringList* roup_clause_selector_construct_scores(const OmpClause* clause);
    OmpDirectiveList* roup_clause_selector_construct_directives(const OmpClause* clause);
    OmpDirective* roup_clause_selector_nested_directive(const OmpClause* clause);
    bool roup_clause_selector_is_target_device(const OmpClause* clause);

    int32_t roup_directive_list_len(const OmpDirectiveList* list);
    OmpDirective* roup_directive_list_get(const OmpDirectiveList* list, int32_t index);
    void roup_directive_list_free(OmpDirectiveList* list);

}

// Helpers to reuse ROUP-parsed directives without reparsing strings
static OpenMPDirective* convert_roup_directive_to_ompparser(
    OmpDirective* roup_dir,
    void* exprParse(const char* expr),
    bool free_input,
    bool debug_logging);

// Convert a single ROUP clause into ompparser clause(s) without string parsing.
static void convert_clause_from_roup(
    OpenMPDirective* dir,
    const OmpClause* roup_clause,
    OpenMPClauseKind clause_kind,
    std::vector<OpenMPUsesAllocatorsClause*>& uses_allocators_clauses,
    void* exprParse(const char* expr),
    bool debug_logging) {
    bool unsupported = false;

    switch (clause_kind) {
        case OMPC_default:
            convert_default_clause(dir, roup_clause);
            break;
        case OMPC_map:
            convert_map_clause(dir, roup_clause);
            break;
        case OMPC_num_threads:
            convert_num_threads_clause(dir, roup_clause);
            break;
        case OMPC_dist_schedule:
            handle_dist_schedule_clause(dir, roup_clause);
            break;
        case OMPC_schedule:
            handle_schedule_clause(dir, roup_clause);
            break;
        case OMPC_reduction:
        case OMPC_task_reduction:
        case OMPC_in_reduction:
        case OMPC_detach:
        case OMPC_depobj_update:
        case OMPC_affinity:
        case OMPC_linear:
            convert_clause_with_payload(dir, roup_clause, clause_kind, uses_allocators_clauses, exprParse, debug_logging);
            break;
        case OMPC_simdlen: {
            OpenMPClause* clause = dir->addOpenMPClause(OMPC_simdlen, "");
            const char* expr = roup_clause_arguments(roup_clause);
            if (clause && expr && expr[0]) {
                clause->addLangExpr(strdup(expr));
            }
            if (clause && clause->getClausePosition() == -1) {
                dir->getClausesInOriginalOrder()->push_back(clause);
                clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
            }
            break;
        }
        case OMPC_uniform:
            convert_variables_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_inbranch:
        case OMPC_notinbranch:
            convert_generic_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_safelen: {
            OpenMPClause* clause = dir->addOpenMPClause(OMPC_safelen, "");
            const char* expr = roup_clause_arguments(roup_clause);
            if (clause && expr && expr[0]) {
                clause->addLangExpr(strdup(expr));
            }
            if (clause && clause->getClausePosition() == -1) {
                dir->getClausesInOriginalOrder()->push_back(clause);
                clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
            }
            break;
        }
        case OMPC_depend:
            convert_depend_clause(dir, roup_clause);
            break;
        case OMPC_allocate:
            convert_allocate_clause(dir, roup_clause);
            break;
        case OMPC_private:
        case OMPC_firstprivate:
        case OMPC_shared:
        case OMPC_copyin:
        case OMPC_copyprivate:
        case OMPC_to:
        case OMPC_from:
        case OMPC_link:
        case OMPC_use_device_ptr:
        case OMPC_use_device_addr:
        case OMPC_has_device_addr:
            convert_variables_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_collapse:
            convert_collapse_clause(dir, roup_clause);
            break;
        case OMPC_if:
            convert_if_clause(dir, roup_clause);
            break;
        case OMPC_proc_bind:
            convert_proc_bind_clause(dir, roup_clause);
            break;
        case OMPC_bind:
            convert_bind_clause(dir, roup_clause);
            break;
        case OMPC_nowait:
        case OMPC_inclusive:
        case OMPC_exclusive:
            convert_generic_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_nontemporal:
            convert_variables_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_order:
            convert_order_clause(dir, roup_clause);
            break;
        case OMPC_atomic_default_mem_order:
            convert_atomic_default_mem_order_clause(dir, roup_clause);
            break;
        case OMPC_grainsize:
        case OMPC_num_tasks:
            convert_size_expr_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_defaultmap:
            convert_defaultmap_clause(dir, roup_clause);
            break;
        case OMPC_align:
        case OMPC_aligned:
            convert_aligned_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_uses_allocators:
            convert_uses_allocators_clause(dir, roup_clause, uses_allocators_clauses);
            break;
        case OMPC_device:
            convert_device_clause(dir, roup_clause);
            break;
        case OMPC_lastprivate:
            convert_lastprivate_clause(dir, roup_clause);
            break;
        case OMPC_allocator:
            convert_allocator_like_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_device_type:
            convert_device_type_clause(dir, roup_clause);
            break;
        case OMPC_destroy:
            convert_generic_clause(dir, roup_clause, clause_kind);
            break;
        case OMPC_ordered:
            if (dir->getKind() == OMPD_atomic) {
                convert_atomic_ordered_clause(dir, roup_clause);
            } else {
                convert_ordered_clause(dir, roup_clause);
            }
            break;
        case OMPC_acq_rel:
        case OMPC_release:
        case OMPC_acquire:
        case OMPC_relaxed:
        case OMPC_read:
        case OMPC_write:
        case OMPC_update:
        case OMPC_capture:
        case OMPC_seq_cst:
        case OMPC_hint:
            convert_atomic_clause(dir, roup_clause, clause_kind);
            break;
        default:
            unsupported = true;
            break;
    }

    if (unsupported && debug_logging) {
        fprintf(stderr, "[compat] unsupported clause kind=%d; consider upstream ompparser support\n",
                static_cast<int>(clause_kind));
    }
}

// Helper function to extract string after directive name for clause data
static std::string extract_clause_text(const std::string& full_input, const char* directive_name) {
    // Find where the directive name ends
    std::string needle = std::string(directive_name);
    size_t pos = full_input.find(needle);
    if (pos == std::string::npos) {
        return "";
    }

    // Skip past the directive name and any whitespace
    pos += needle.length();
    while (pos < full_input.length() && std::isspace(full_input[pos])) {
        pos++;
    }

    return full_input.substr(pos);
}

// Some end directives (e.g., end critical(name)) are not yet accepted by the ROUP parser.
// Extract and strip the trailing parameter to allow parsing to proceed while we propagate the name ourselves.
static std::pair<std::string, std::string> strip_end_directive_parameter(const std::string& input) {
    const std::string target = "end critical";
    std::string lower_input = input;
    std::transform(lower_input.begin(), lower_input.end(), lower_input.begin(), [](unsigned char c) {
        return static_cast<char>(std::tolower(c));
    });
    size_t pos = lower_input.find(target);
    if (pos == std::string::npos) {
        return {input, ""};
    }

    size_t paren = lower_input.find('(', pos + target.length());
    size_t close = lower_input.find(')', paren);
    if (paren == std::string::npos || close == std::string::npos || close <= paren) {
        return {input, ""};
    }

    std::string stripped = input;
    stripped.erase(paren, close - paren + 1);
    std::string param = input.substr(paren + 1, close - paren - 1);
    return {stripped, param};
}

// Convert an already-parsed ROUP directive into an ompparser directive (no string parsing).
static OpenMPDirective* convert_roup_directive_to_ompparser(
    OmpDirective* roup_dir,
    void* exprParse(const char* expr),
    bool free_input,
    bool debug_logging) {
    if (debug_logging) {
        fprintf(stderr, "[compat] convert_roup_directive_to_ompparser start dir=%p\n", (void*)roup_dir);
    }
    if (roup_dir == nullptr) {
        return nullptr;
    }

    int32_t roup_kind = roup_directive_kind(roup_dir);
    OpenMPDirectiveKind kind = mapRoupToOmpparserDirective(roup_kind);
    if (debug_logging) {
        fprintf(stderr, "[compat] convert: roup_kind=%d mapped=%d\n", roup_kind, static_cast<int>(kind));
    }

    OpenMPDirective* dir = nullptr;
    OpenMPEndDirective* end_dir_owner = nullptr;
    OpenMPDirectiveKind end_paired_kind = OMPD_unknown;

    switch (kind) {
        case OMPD_atomic:
            dir = new OpenMPAtomicDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_end: {
            OpenMPDirectiveKind paired_kind = getEndDirectivePairedKind(roup_kind);
            OpenMPEndDirective* end_dir = new OpenMPEndDirective();
            end_dir->setBaseLang(current_lang);
            end_dir_owner = end_dir;
            if (paired_kind != OMPD_unknown) {
                end_paired_kind = paired_kind;
                OpenMPDirective* paired_dir = nullptr;
                if (paired_kind == OMPD_critical) {
                    OpenMPCriticalDirective* crit_dir = new OpenMPCriticalDirective();
                    crit_dir->setBaseLang(current_lang);
                    paired_dir = crit_dir;
                } else {
                    paired_dir = new OpenMPDirective(paired_kind, current_lang, 0, 0);
                }
                end_dir->setPairedDirective(paired_dir);
            }
            dir = end_dir;
            break;
        }
        case OMPD_requires:
            dir = new OpenMPRequiresDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_allocate:
            dir = new OpenMPAllocateDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_threadprivate:
            dir = new OpenMPThreadprivateDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_groupprivate:
            dir = new OpenMPGroupprivateDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_declare_reduction:
            dir = new OpenMPDeclareReductionDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_declare_mapper:
            dir = new OpenMPDeclareMapperDirective(OMPD_DECLARE_MAPPER_IDENTIFIER_unspecified);
            dir->setBaseLang(current_lang);
            break;
        case OMPD_declare_variant:
            dir = new OpenMPDeclareVariantDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_declare_simd:
            dir = new OpenMPDeclareSimdDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_flush:
            dir = new OpenMPFlushDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_depobj:
            dir = new OpenMPDepobjDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_declare_target:
            dir = new OpenMPDeclareTargetDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_begin_declare_target:
        case OMPD_end_declare_target:
            dir = new OpenMPDirective(kind, current_lang, 0, 0);
            break;
        case OMPD_critical:
            dir = new OpenMPCriticalDirective();
            dir->setBaseLang(current_lang);
            break;
        default:
            dir = new OpenMPDirective(kind, current_lang, 0, 0);
            break;
    }

    if (dir == nullptr) {
        if (free_input) {
            roup_directive_free(roup_dir);
        }
        return nullptr;
    }

    const char* param = roup_directive_parameter(roup_dir);
    const int32_t param_kind = roup_directive_parameter_kind(roup_dir);

    if (debug_logging &&
        (kind == OMPD_critical || kind == OMPD_depobj || kind == OMPD_flush)) {
        fprintf(stderr,
                "[compat] directive param kind=%d text=\"%s\"\n",
                param_kind,
                param ? param : "(null)");
    }

    auto record_clause_in_order = [&](OpenMPClause* clause) {
        if (clause && clause->getClausePosition() == -1) {
            dir->getClausesInOriginalOrder()->push_back(clause);
            clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
        }
    };

    if (param != nullptr && param[0] != '\0' && end_dir_owner != nullptr) {
        if (end_paired_kind == OMPD_critical) {
            std::string param_str(param);
            if (param_str.length() >= 2 && param_str.front() == '(' && param_str.back() == ')') {
                param_str = param_str.substr(1, param_str.length() - 2);
            }
            OpenMPDirective* paired_dir = end_dir_owner->getPairedDirective();
            if (paired_dir != nullptr) {
                OpenMPCriticalDirective* crit_dir = static_cast<OpenMPCriticalDirective*>(paired_dir);
                char* safe = duplicate_c_string(param_str.c_str());
                crit_dir->setCriticalName(safe ? safe : "");
                if (safe) free(safe);
            }
        }
    } else if (end_dir_owner != nullptr && end_paired_kind == OMPD_critical) {
        // Fallback: attempt to pull the critical name from identifiers list
        OmpStringList* identifiers = roup_directive_parameter_identifiers(roup_dir);
        const char* name = identifiers ? roup_string_list_get(identifiers, 0) : nullptr;
        if (name && name[0]) {
            std::string param_str(name);
            if (param_str.length() >= 2 && param_str.front() == '(' && param_str.back() == ')') {
                param_str = param_str.substr(1, param_str.length() - 2);
            }
            OpenMPDirective* paired_dir = end_dir_owner->getPairedDirective();
            if (paired_dir != nullptr) {
                OpenMPCriticalDirective* crit_dir = static_cast<OpenMPCriticalDirective*>(paired_dir);
                char* safe = duplicate_c_string(param_str.c_str());
                crit_dir->setCriticalName(safe ? safe : "");
                if (safe) free(safe);
            }
        }
        if (identifiers) {
            roup_string_list_free(identifiers);
        }
    }

    if (param != nullptr && param[0] != '\0') {
        bool handled_param = false;

        if (kind == OMPD_critical) {
            if (param && param[0]) {
                std::string param_str(param);
                if (param_str.length() >= 2 && param_str.front() == '(' && param_str.back() == ')') {
                    param_str = param_str.substr(1, param_str.length() - 2);
                }
                auto* crit_dir = static_cast<OpenMPCriticalDirective*>(dir);
                char* safe = duplicate_c_string(param_str.c_str());
                crit_dir->setCriticalName(safe ? safe : "");
                if (safe) {
                    free(safe);
                }
                handled_param = true;
            }
        } else if (kind == OMPD_flush) {
            OmpStringList* identifiers = roup_directive_parameter_identifiers(roup_dir);
            if (identifiers != nullptr) {
                auto* flush_dir = static_cast<OpenMPFlushDirective*>(dir);
                int32_t len = roup_string_list_len(identifiers);
                for (int32_t i = 0; i < len; ++i) {
                    const char* item = roup_string_list_get(identifiers, i);
                    if (item != nullptr) {
                        flush_dir->addFlushList(item);
                    }
                }
                roup_string_list_free(identifiers);
                handled_param = true;
            }
        } else if (kind == OMPD_depobj) {
            OmpStringList* identifiers = roup_directive_parameter_identifiers(roup_dir);
            const char* depobj = identifiers ? roup_string_list_get(identifiers, 0) : nullptr;
            if (depobj && depobj[0]) {
                static_cast<OpenMPDepobjDirective*>(dir)->addDepobj(depobj);
                handled_param = true;
            }
            if (identifiers) {
                roup_string_list_free(identifiers);
            }
        } else if (kind == OMPD_cancel || kind == OMPD_cancellation_point) {
            int32_t construct_type = roup_directive_parameter_construct_type(roup_dir);
            if (std::getenv("ROUP_DEBUG_COMPAT") != nullptr) {
                fprintf(stderr, "[compat] cancel construct_type=%d\n", construct_type);
            }
            switch (construct_type) {
                case ROUPO_CONSTRUCT_PARALLEL:
                    record_clause_in_order(dir->addOpenMPClause(OMPC_parallel));
                    handled_param = true;
                    break;
                case ROUPO_CONSTRUCT_SECTIONS:
                    record_clause_in_order(dir->addOpenMPClause(OMPC_sections));
                    handled_param = true;
                    break;
                case ROUPO_CONSTRUCT_FOR:
                    record_clause_in_order(
                        dir->addOpenMPClause(current_lang == Lang_Fortran ? OMPC_do : OMPC_for));
                    handled_param = true;
                    break;
                case ROUPO_CONSTRUCT_TASKGROUP:
                    record_clause_in_order(dir->addOpenMPClause(OMPC_taskgroup));
                    handled_param = true;
                    break;
                default:
                    break;
            }
        } else if (kind == OMPD_declare_simd) {
            const char* name = roup_directive_declare_simd_target(roup_dir);
            if (name && name[0]) {
                auto* ds_dir = static_cast<OpenMPDeclareSimdDirective*>(dir);
                ds_dir->addProcName(name);
                handled_param = true;
            } else if (param_kind == ROUPO_PARAM_DECLARE_SIMD) {
                OmpStringList* identifiers = roup_directive_parameter_identifiers(roup_dir);
                const char* id_name = identifiers ? roup_string_list_get(identifiers, 0) : nullptr;
                if (id_name && id_name[0]) {
                    auto* ds_dir = static_cast<OpenMPDeclareSimdDirective*>(dir);
                    ds_dir->addProcName(id_name);
                    handled_param = true;
                }
                if (identifiers) {
                    roup_string_list_free(identifiers);
                }
            }
        } else if (kind == OMPD_declare_target) {
            auto* dt_dir = static_cast<OpenMPDeclareTargetDirective*>(dir);
            OmpStringList* identifiers = roup_directive_parameter_identifiers(roup_dir);
            if (identifiers != nullptr) {
                int32_t len = roup_string_list_len(identifiers);
                for (int32_t i = 0; i < len; ++i) {
                    const char* item = roup_string_list_get(identifiers, i);
                    if (item != nullptr) {
                        dt_dir->addExtendedList(item);
                    }
                }
                roup_string_list_free(identifiers);
            }
            handled_param = true;
        } else if (kind == OMPD_declare_mapper) {
            auto* dm_dir = static_cast<OpenMPDeclareMapperDirective*>(dir);
            int32_t id_kind = roup_directive_declare_mapper_identifier_kind(roup_dir);
            if (id_kind == ROUPO_DECLARE_MAPPER_ID_USER) {
                dm_dir->setIdentifier(OMPD_DECLARE_MAPPER_IDENTIFIER_user);
                const char* user = roup_directive_declare_mapper_user_identifier(roup_dir);
                if (user && user[0]) {
                    dm_dir->setUserDefinedIdentifier(user);
                }
            } else if (id_kind == ROUPO_DECLARE_MAPPER_ID_DEFAULT) {
                dm_dir->setIdentifier(OMPD_DECLARE_MAPPER_IDENTIFIER_default);
            } else {
                dm_dir->setIdentifier(OMPD_DECLARE_MAPPER_IDENTIFIER_unspecified);
            }
            const char* type_name = roup_directive_declare_mapper_type(roup_dir);
            const char* var_name = roup_directive_declare_mapper_variable(roup_dir);
            if (type_name && type_name[0]) {
                std::string type_value(type_name);
                if (current_lang != Lang_Fortran && !type_value.empty() && type_value.back() != ' ') {
                    type_value.push_back(' ');
                }
                dm_dir->setDeclareMapperType(type_value.c_str());
            }
            if (var_name && var_name[0]) {
                dm_dir->setDeclareMapperVar(var_name);
            }
            handled_param = true;
        } else if (kind == OMPD_declare_reduction) {
            auto* dr_dir = static_cast<OpenMPDeclareReductionDirective*>(dir);
            auto operator_code = roup_directive_declare_reduction_operator(roup_dir);
            const char* user_id = roup_directive_declare_reduction_user_identifier(roup_dir);
            auto map_operator_string = [](int32_t code) -> const char* {
                switch (code) {
                    case 0: return "+";
                    case 1: return "-";
                    case 2: return "*";
                    case 3: return "&";
                    case 4: return "|";
                    case 5: return "^";
                    case 6: return "&&";
                    case 7: return "||";
                    case 8: return "min";
                    case 9: return "max";
                    default: return "";
                }
            };
            if (user_id && user_id[0]) {
                dr_dir->setIdentifier(user_id);
            } else {
                dr_dir->setIdentifier(map_operator_string(operator_code));
            }
            OmpStringList* types = roup_directive_declare_reduction_types(roup_dir);
            if (types != nullptr) {
                int32_t len = roup_string_list_len(types);
                for (int32_t i = 0; i < len; ++i) {
                    const char* t = roup_string_list_get(types, i);
                    if (t) {
                        dr_dir->addTypenameList(strdup(t));
                    }
                }
                roup_string_list_free(types);
            }
            const char* combiner = roup_directive_declare_reduction_combiner(roup_dir);
            if (combiner && combiner[0]) {
                dr_dir->setCombiner(combiner);
            }
            const char* initializer = roup_directive_declare_reduction_initializer(roup_dir);
            if (initializer && initializer[0]) {
                dr_dir->setInitializer(initializer);
            }
            handled_param = true;
        } else if (kind == OMPD_scan && param_kind == ROUPO_PARAM_SCAN) {
            int32_t scan_mode = roup_directive_parameter_scan_mode(roup_dir);
            OmpStringList* variables = roup_directive_parameter_identifiers(roup_dir);
            OpenMPClauseKind scan_clause_kind =
                (scan_mode == ROUPO_SCAN_MODE_INCLUSIVE) ? OMPC_inclusive : OMPC_exclusive;
            OpenMPClause* clause = dir->addOpenMPClause(scan_clause_kind, "");
            if (clause != nullptr) {
                if (variables != nullptr) {
                    append_variables_to_clause(clause, variables);
                    roup_string_list_free(variables);
                }
                if (clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(clause);
                    clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            }
            handled_param = true;
        } else if ((param_kind == ROUPO_PARAM_IDENTIFIER_LIST || param_kind == ROUPO_PARAM_IDENTIFIER) &&
                   (kind == OMPD_allocate || kind == OMPD_threadprivate ||
                    kind == OMPD_groupprivate || kind == OMPD_declare_mapper ||
                    kind == OMPD_declare_variant || kind == OMPD_declare_simd)) {
            OmpStringList* identifiers = roup_directive_parameter_identifiers(roup_dir);
            if (identifiers != nullptr) {
                int32_t len = roup_string_list_len(identifiers);
                for (int32_t i = 0; i < len; ++i) {
                    const char* item = roup_string_list_get(identifiers, i);
                    if (item == nullptr) {
                        continue;
                    }
                    char* persistent_param = strdup(item);
                    if (kind == OMPD_allocate) {
                        auto* alloc_dir = static_cast<OpenMPAllocateDirective*>(dir);
                        alloc_dir->addAllocateList(persistent_param);
                    } else if (kind == OMPD_threadprivate) {
                        auto* tp_dir = static_cast<OpenMPThreadprivateDirective*>(dir);
                        tp_dir->addThreadprivateList(persistent_param);
                    } else if (kind == OMPD_groupprivate) {
                        auto* gp_dir = static_cast<OpenMPGroupprivateDirective*>(dir);
                        gp_dir->addGroupprivateList(persistent_param);
                    } else if (kind == OMPD_declare_variant) {
                        auto* dv_dir = static_cast<OpenMPDeclareVariantDirective*>(dir);
                        dv_dir->setVariantFuncID(persistent_param);
                        free(persistent_param);
                    }
                }
                roup_string_list_free(identifiers);
                handled_param = true;
            }
        } else if (kind == OMPD_declare_variant && param != nullptr) {
            auto* dv_dir = static_cast<OpenMPDeclareVariantDirective*>(dir);
            dv_dir->setVariantFuncID(param);
            handled_param = true;
        }
        // TODO: handle critical hint clause safely if needed
    }

    if (debug_logging) {
        fprintf(stderr, "[compat] after param handling\n");
    }

    // Clause conversion (existing logic reused)
    OpenMPDirective* output_dir = dir;
    if (end_dir_owner != nullptr && end_dir_owner->getPairedDirective() != nullptr) {
        dir = end_dir_owner->getPairedDirective();
    }

    std::vector<OpenMPUsesAllocatorsClause*> uses_allocators_clauses;

    if (kind == OMPD_critical) {
        const char* hint_expr = roup_directive_critical_hint(roup_dir);
        if (hint_expr && hint_expr[0]) {
            OpenMPClause* clause = dir->addOpenMPClause(OMPC_hint, "");
            if (clause) {
                clause->addLangExpr(strdup(hint_expr));
                if (clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(clause);
                    clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            }
        }
        return output_dir;
    } else {
        int32_t clause_count = roup_directive_clause_count(roup_dir);
        if (debug_logging) {
            fprintf(stderr, "[compat] clause_count=%d\n", clause_count);
        }

        OmpClauseIterator* iter = roup_directive_clauses_iter(roup_dir);
        if (debug_logging) {
            fprintf(stderr, "[compat] clause iterator=%p\n", (void*)iter);
        }
        if (iter) {
            const OmpClause* roup_clause;
            while (roup_clause_iterator_next(iter, &roup_clause) == 1) {
                if (debug_logging && kind == OMPD_critical) {
                    fprintf(stderr, "[compat] critical clause observed\n");
                }
                int32_t roup_kind_clause = roup_clause_kind(roup_clause);
                OpenMPClauseKind clause_kind = mapRoupToOmpparserClause(roup_kind_clause);

                if (kind == OMPD_depobj && roup_kind_clause == 81) {
                    clause_kind = OMPC_depobj_update;
                }
                if (kind == OMPD_metadirective && roup_kind_clause == 2) {
                    clause_kind = OMPC_otherwise;
                }

                if (debug_logging) {
                    fprintf(stderr, "[compat] clause kind raw=%d mapped=%d\n", roup_kind_clause, static_cast<int>(clause_kind));
                }

                if (clause_kind == OMPC_when || clause_kind == OMPC_match || clause_kind == OMPC_otherwise) {
                    OpenMPVariantClause* variant_clause = nullptr;
                    if (clause_kind == OMPC_when) {
                        variant_clause = static_cast<OpenMPVariantClause*>(OpenMPWhenClause::addWhenClause(dir));
                    } else if (clause_kind == OMPC_match) {
                        variant_clause = static_cast<OpenMPVariantClause*>(OpenMPMatchClause::addMatchClause(dir));
                    } else {
                        variant_clause = static_cast<OpenMPVariantClause*>(OpenMPOtherwiseClause::addOtherwiseClause(dir));
                    }

                    if (variant_clause != nullptr) {
                        attach_variant_selector_from_roup(variant_clause, roup_clause, exprParse);
                        if (variant_clause->getClausePosition() == -1) {
                            dir->getClausesInOriginalOrder()->push_back(variant_clause);
                            variant_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                        }
                    }
                } else {
                    if (debug_logging) {
                        fprintf(stderr, "[compat] converting clause kind=%d\n", static_cast<int>(clause_kind));
                    }
                    convert_clause_from_roup(dir, roup_clause, clause_kind, uses_allocators_clauses, exprParse, debug_logging);
                    if (debug_logging) {
                        fprintf(stderr, "[compat] finished clause kind=%d\n", static_cast<int>(clause_kind));
                    }
                }
            }
            roup_clause_iterator_free(iter);
        }
    }

    if (kind == OMPD_critical) {
        free_input = false; // avoid freeing critical source until crash understood
    }

    if (free_input) {
        roup_directive_free(roup_dir);
    }

    if (debug_logging && (kind == OMPD_cancel || kind == OMPD_cancellation_point)) {
        fprintf(stderr,
                "[compat] cancel directive clauses=%zu param_kind=%d\n",
                dir->getClausesInOriginalOrder()->size(),
                param_kind);
    }

    return output_dir;
}

// Convert a single ROUP clause into ompparser clause(s) without string parsing.
// Forward declaration for format_iterator
static std::string format_iterator(const char* expr);

// Helper function to format mapper expressions for ompparser compatibility
// Expected format: "mapper(name) : items" with space before the colon
static std::string format_mapper(const char* expr) {
    if (expr == nullptr || expr[0] == '\0') {
        return "";
    }

    std::string input(expr);
    std::string result;

    // Check if this contains "mapper("
    size_t mapper_pos = input.find("mapper(");
    if (mapper_pos == std::string::npos) {
        // Not a mapper expression, return as-is
        return input;
    }

    // Find the matching closing parenthesis for mapper
    size_t i = mapper_pos + 7;  // after "mapper("
    int paren_depth = 1;
    while (i < input.length() && paren_depth > 0) {
        if (input[i] == '(') {
            paren_depth++;
        } else if (input[i] == ')') {
            paren_depth--;
        }
        i++;
    }

    // Now i is after the closing ')'
    // Check if there's a colon immediately after (with optional spaces)
    while (i < input.length() && input[i] == ' ') {
        i++;
    }

    if (i < input.length() && input[i] == ':') {
        // Insert space before the colon
        result = input.substr(0, i) + " : " + input.substr(i + 1);
        // Skip any spaces after the colon in the original
        size_t j = i + 1;
        while (j < input.length() && input[j] == ' ') {
            j++;
        }
        if (j > i + 1) {
            // Remove extra spaces
            result = input.substr(0, i) + " : " + input.substr(j);
        }
    } else {
        // No colon after mapper, return as-is
        result = input;
    }

    return result;
}

// Helper function to add spaces after commas and colons for ompparser formatting
// ompparser expects: "a, b, c" not "a,b,c" and "modifier: value" not "modifier:value"
static std::string format_clause_args(const char* args, bool space_after_colon = true) {
    if (args == nullptr || args[0] == '\0') {
        return "";
    }

    // First, handle iterator expressions if present
    std::string input = format_iterator(args);
    // Then handle mapper expressions
    input = format_mapper(input.c_str());

    std::string result;
    int paren_depth = 0;

    for (size_t i = 0; i < input.length(); ++i) {
        char c = input[i];

        if (c == '(') {
            paren_depth++;
            result += c;
        } else if (c == ')') {
            paren_depth--;
            result += c;
        } else if (c == ',' && paren_depth == 0) {
            result += ", ";  // Add space after comma
            // Skip any existing spaces
            while (i + 1 < input.length() && input[i + 1] == ' ') {
                i++;
            }
        } else if (c == ':' && space_after_colon && paren_depth == 0) {
            result += ": ";  // Add space after colon
            // Skip any existing spaces
            while (i + 1 < input.length() && input[i + 1] == ' ') {
                i++;
            }
        } else {
            result += c;
        }
    }

    return result;
}

// Trim whitespace from both ends of a string
static std::string trim_copy(const std::string& value) {
    const char* whitespace = " \t\n\r\f\v";
    const size_t start = value.find_first_not_of(whitespace);
    if (start == std::string::npos) {
        return "";
    }
    const size_t end = value.find_last_not_of(whitespace);
    return value.substr(start, end - start + 1);
}

// Find the matching closing delimiter for a given opening delimiter
static size_t find_matching_delim(const std::string& text, size_t open_pos, char open_ch, char close_ch) {
    if (open_pos == std::string::npos || open_pos >= text.size() || text[open_pos] != open_ch) {
        return std::string::npos;
    }
    int depth = 1;
    for (size_t i = open_pos + 1; i < text.size(); ++i) {
        if (text[i] == open_ch) {
            depth++;
        } else if (text[i] == close_ch) {
            depth--;
            if (depth == 0) {
                return i;
            }
        }
    }
    return std::string::npos;
}

// Split on a delimiter while respecting balanced parentheses/braces
static std::vector<std::string> split_top_level(const std::string& input, char delim) {
    std::vector<std::string> parts;
    std::string current;
    int paren_depth = 0;
    int brace_depth = 0;

    for (char c : input) {
        if (c == '(') {
            paren_depth++;
        } else if (c == ')') {
            paren_depth--;
        } else if (c == '{') {
            brace_depth++;
        } else if (c == '}') {
            brace_depth--;
        }

        if (c == delim && paren_depth == 0 && brace_depth == 0) {
            parts.push_back(trim_copy(current));
            current.clear();
        } else {
            current.push_back(c);
        }
    }

    if (!current.empty()) {
        parts.push_back(trim_copy(current));
    }

    return parts;
}

// Parse an expression of the form "score(<val>): payload" or "payload"
static std::pair<std::string, std::string> parse_scored_expression(const std::string& text) {
    std::string trimmed = trim_copy(text);
    std::string score;
    std::string payload = trimmed;

    if (trimmed.rfind("score", 0) == 0) {
        size_t paren = trimmed.find('(');
        size_t close = find_matching_delim(trimmed, paren, '(', ')');
        if (paren != std::string::npos && close != std::string::npos) {
            score = trim_copy(trimmed.substr(paren + 1, close - paren - 1));
            size_t colon = trimmed.find(':', close + 1);
            if (colon != std::string::npos) {
                payload = trim_copy(trimmed.substr(colon + 1));
            } else {
                payload.clear();
            }
        }
    } else {
        size_t colon = trimmed.find(':');
        if (colon != std::string::npos) {
            score = trim_copy(trimmed.substr(0, colon));
            payload = trim_copy(trimmed.substr(colon + 1));
        }
    }

    return {score, payload};
}

// Helper function to normalize expression formatting for ompparser compatibility
// Removes spaces after commas INSIDE parentheses: "foo(x, y)" -> "foo(x,y)"
// But preserves spaces at top level (handled elsewhere)
static std::string normalize_expression(const char* expr) {
    if (expr == nullptr || expr[0] == '\0') {
        return "";
    }

    std::string result;
    std::string input(expr);
    int paren_depth = 0;
    bool skip_next_space = false;

    for (size_t i = 0; i < input.length(); ++i) {
        char c = input[i];

        if (c == '(') {
            paren_depth++;
            result += c;
            skip_next_space = false;
        } else if (c == ')') {
            paren_depth--;
            result += c;
            skip_next_space = false;
        } else if (c == ',' && paren_depth > 0) {
            // Inside parentheses - add comma without space
            result += c;
            skip_next_space = true;  // Skip the next space if present
        } else if (c == ' ' && skip_next_space) {
            // Skip this space (after comma inside parentheses)
            skip_next_space = false;
        } else {
            result += c;
            skip_next_space = false;
        }
    }

    return result;
}

// Remove padding directly inside parentheses: "( x )" -> "(x)"
static std::string trim_paren_padding(const std::string& expr) {
    if (expr.empty()) {
        return expr;
    }

    std::string out;
    out.reserve(expr.size());

    for (size_t i = 0; i < expr.size(); ++i) {
        char c = expr[i];
        if (c == '(') {
            out.push_back(c);
            size_t j = i + 1;
            while (j < expr.size() && expr[j] == ' ') {
                ++j;
            }
            i = j - 1;
        } else if (c == ' ' && i + 1 < expr.size() && expr[i + 1] == ')') {
            continue;
        } else {
            out.push_back(c);
        }
    }

    return out;
}

// Helper function to format iterator expressions for ompparser compatibility
// Expected format: "iterator ( type var=start:end:step, ... ) : items"
// - Space after "iterator("
// - NO spaces around colons in range specs (start:end:step)
// - Spaces after commas between iterator definitions
// - Space before ")" and space after ") :"
static std::string format_iterator(const char* expr) {
    if (expr == nullptr || expr[0] == '\0') {
        return "";
    }

    std::string input(expr);

    // Check if this contains "iterator("
    size_t iter_pos = input.find("iterator(");
    // Also check for already-formatted "iterator ( "
    size_t iter_formatted_pos = input.find("iterator ( ");

    if (iter_pos == std::string::npos && iter_formatted_pos == std::string::npos) {
        // Not an iterator expression, return as-is
        return input;
    }

    // Use the first occurrence
    if (iter_pos == std::string::npos) {
        iter_pos = iter_formatted_pos;
    } else if (iter_formatted_pos != std::string::npos && iter_formatted_pos < iter_pos) {
        iter_pos = iter_formatted_pos;
    }

    // Build result string carefully
    std::string result;
    result = input.substr(0, iter_pos);
    result += "iterator ( ";  // Standardize to "iterator ( "

    // Skip past "iterator(" or "iterator ( " and any spaces
    size_t i = iter_pos;
    if (input.substr(i, 11) == "iterator ( ") {
        i += 11;
    } else if (input.substr(i, 9) == "iterator(") {
        i += 9;
    }
    while (i < input.length() && input[i] == ' ') {
        i++;
    }

    // Find the matching closing paren for iterator(...)
    int paren_depth = 1;
    size_t iter_content_start = i;
    size_t iter_content_end = i;

    while (i < input.length() && paren_depth > 0) {
        if (input[i] == '(') {
            paren_depth++;
        } else if (input[i] == ')') {
            paren_depth--;
            if (paren_depth == 0) {
                iter_content_end = i;
                break;
            }
        }
        i++;
    }

    // Now process the content between the parentheses
    std::string iter_content = input.substr(iter_content_start, iter_content_end - iter_content_start);

    // Process iterator content to format it correctly:
    // - Remove spaces around colons in range specs (var=start:end:step)
    // - Ensure space after commas between variables
    // - Preserve spaces in type names and identifiers
    std::string formatted_content;
    bool in_range_spec = false;

    for (size_t j = 0; j < iter_content.length(); j++) {
        char c = iter_content[j];

        if (c == '=') {
            // Start of range spec
            formatted_content += c;
            in_range_spec = true;
            // Skip any spaces after =
            while (j + 1 < iter_content.length() && iter_content[j + 1] == ' ') {
                j++;
            }
        } else if (c == ':' && in_range_spec) {
            // Colon in range spec - remove surrounding spaces
            while (!formatted_content.empty() && formatted_content.back() == ' ') {
                formatted_content.pop_back();
            }
            formatted_content += ':';
            // Skip spaces after colon
            while (j + 1 < iter_content.length() && iter_content[j + 1] == ' ') {
                j++;
            }
        } else if (c == ',') {
            // Comma between iterator variables
            // Remove trailing spaces before comma
            while (!formatted_content.empty() && formatted_content.back() == ' ') {
                formatted_content.pop_back();
            }
            formatted_content += ", ";
            in_range_spec = false;
            // Skip spaces after comma
            while (j + 1 < iter_content.length() && iter_content[j + 1] == ' ') {
                j++;
            }
        } else if (c == ' ' && in_range_spec) {
            // Skip all spaces within range specs
            continue;
        } else {
            formatted_content += c;
        }
    }

    // Remove trailing spaces
    while (!formatted_content.empty() && formatted_content.back() == ' ') {
        formatted_content.pop_back();
    }

    // Build the final result
    result += formatted_content;
    result += " )";  // Space before closing paren

    // Skip the closing paren in input and handle what comes after
    i = iter_content_end + 1;

    // Skip spaces
    while (i < input.length() && input[i] == ' ') {
        i++;
    }

    // Check for " : items" pattern
    if (i < input.length() && input[i] == ':') {
        result += " : ";
        i++;
        // Skip spaces after colon
        while (i < input.length() && input[i] == ' ') {
            i++;
        }
    }

    // Append the rest
    result += input.substr(i);

    return result;
}

// Helper function to split comma-separated list and add each item to clause
// This is critical for ompparser compatibility - it expects individual items
static void add_list_expressions(OpenMPClause* clause, const char* args) {
    if (clause == nullptr || args == nullptr || args[0] == '\0') {
        return;
    }

    // Args should already be formatted by format_clause_args before calling this function
    // DO NOT call format_iterator again here to avoid double-formatting
    std::string args_str(args);
    std::stringstream ss(args_str);
    std::string item;

    // Handle nested parentheses for complex arguments like linear(val(a,b,c):2)
    int paren_depth = 0;
    std::string current_item;

    for (size_t i = 0; i < args_str.length(); ++i) {
        char c = args_str[i];

        if (c == '(') {
            paren_depth++;
            current_item += c;
        } else if (c == ')') {
            paren_depth--;
            current_item += c;
        } else if (c == ',' && paren_depth == 0) {
            // Found a separator at top level
            // Trim whitespace
            size_t start = current_item.find_first_not_of(" \t\n\r\f\v");
            size_t end = current_item.find_last_not_of(" \t\n\r\f\v");

            if (start != std::string::npos && end != std::string::npos) {
                std::string trimmed = current_item.substr(start, end - start + 1);
                if (!trimmed.empty()) {
                    std::string cleaned = trim_paren_padding(trimmed);
                    bool preserve_spacing = cleaned.rfind("val(", 0) == 0 ||
                                            cleaned.rfind("ref(", 0) == 0 ||
                                            cleaned.rfind("uval(", 0) == 0;
                    if (!preserve_spacing) {
                        cleaned = normalize_expression(cleaned.c_str());
                    }
                    clause->addLangExpr(strdup(cleaned.c_str()));
                }
            }
            current_item.clear();
        } else {
            current_item += c;
        }
    }

    // Add the last item
    size_t start = current_item.find_first_not_of(" \t\n\r\f\v");
    size_t end = current_item.find_last_not_of(" \t\n\r\f\v");

    if (start != std::string::npos && end != std::string::npos) {
        std::string trimmed = current_item.substr(start, end - start + 1);
        if (!trimmed.empty()) {
            std::string cleaned = trim_paren_padding(trimmed);
            bool preserve_spacing = cleaned.rfind("val(", 0) == 0 ||
                                    cleaned.rfind("ref(", 0) == 0 ||
                                    cleaned.rfind("uval(", 0) == 0;
            if (!preserve_spacing) {
                cleaned = normalize_expression(cleaned.c_str());
            }
            clause->addLangExpr(strdup(cleaned.c_str()));
        }
    }
}

static char* duplicate_c_string(const char* input) {
    if (input == nullptr) {
        return strdup("");
    }
    return strdup(input);
}

static std::string join_variables_from_list(OmpStringList* list) {
    if (!list) {
        return {};
    }
    int length = roup_string_list_len(list);
    std::string result;
    for (int i = 0; i < length; ++i) {
        const char* item = roup_string_list_get(list, i);
        if (!item) {
            continue;
        }
        if (!result.empty()) {
            result += ", ";
        }
        result += item;
    }
    return result;
}

// Forward declaration to allow recursive parsing for variant selectors
extern "C" OpenMPDirective* parseOpenMP(const char* input, void* exprParse(const char* expr));

static OpenMPClauseContextKind map_context_kind(const std::string& value) {
    const std::string lowered = trim_copy(value);
    if (lowered == "host") return OMPC_CONTEXT_KIND_host;
    if (lowered == "nohost") return OMPC_CONTEXT_KIND_nohost;
    if (lowered == "any") return OMPC_CONTEXT_KIND_any;
    if (lowered == "cpu") return OMPC_CONTEXT_KIND_cpu;
    if (lowered == "gpu") return OMPC_CONTEXT_KIND_gpu;
    if (lowered == "fpga") return OMPC_CONTEXT_KIND_fpga;
    return OMPC_CONTEXT_KIND_unknown;
}

static OpenMPClauseContextVendor map_context_vendor(const std::string& value) {
    const std::string lowered = trim_copy(value);
    if (lowered == "amd") return OMPC_CONTEXT_VENDOR_amd;
    if (lowered == "arm") return OMPC_CONTEXT_VENDOR_arm;
    if (lowered == "bsc") return OMPC_CONTEXT_VENDOR_bsc;
    if (lowered == "cray") return OMPC_CONTEXT_VENDOR_cray;
    if (lowered == "fujitsu") return OMPC_CONTEXT_VENDOR_fujitsu;
    if (lowered == "gnu") return OMPC_CONTEXT_VENDOR_gnu;
    if (lowered == "ibm") return OMPC_CONTEXT_VENDOR_ibm;
    if (lowered == "intel") return OMPC_CONTEXT_VENDOR_intel;
    if (lowered == "llvm") return OMPC_CONTEXT_VENDOR_llvm;
    if (lowered == "nvidia") return OMPC_CONTEXT_VENDOR_nvidia;
    if (lowered == "pgi") return OMPC_CONTEXT_VENDOR_pgi;
    if (lowered == "ti") return OMPC_CONTEXT_VENDOR_ti;
    if (lowered == "unknown") return OMPC_CONTEXT_VENDOR_unknown;
    return OMPC_CONTEXT_VENDOR_unspecified;
}

static const char* get_score_entry(OmpStringList* scores, int32_t index) {
    if (!scores) {
        return "";
    }
    int32_t len = roup_string_list_len(scores);
    if (index < 0 || index >= len) {
        return "";
    }
    const char* score = roup_string_list_get(scores, index);
    return (score != nullptr && score[0] != '\0') ? score : "";
}

static void attach_variant_selector_from_roup(OpenMPVariantClause* clause, const OmpClause* roup_clause, void* exprParse(const char* expr)) {
    if (clause == nullptr || roup_clause == nullptr) {
        return;
    }

    const bool debug_variant = std::getenv("ROUP_DEBUG_VARIANT") != nullptr;

    // Device selector
    const char* device_kind = roup_clause_selector_device_kind(roup_clause);
    if (device_kind && device_kind[0]) {
        clause->setContextKind("", map_context_kind(device_kind));
    }

    OmpStringList* isa_list = roup_clause_selector_device_isa(roup_clause);
    if (isa_list) {
        int32_t len = roup_string_list_len(isa_list);
        for (int32_t i = 0; i < len; ++i) {
            const char* value = roup_string_list_get(isa_list, i);
            if (value && value[0]) {
                clause->setIsaExpression("", value);
            }
        }
        roup_string_list_free(isa_list);
    }

    OmpStringList* arch_list = roup_clause_selector_device_arch(roup_clause);
    if (arch_list) {
        int32_t len = roup_string_list_len(arch_list);
        for (int32_t i = 0; i < len; ++i) {
            const char* value = roup_string_list_get(arch_list, i);
            if (value && value[0]) {
                clause->setArchExpression("", value);
            }
        }
        roup_string_list_free(arch_list);
    }

    const char* device_num = roup_clause_selector_device_num(roup_clause);
    if (device_num && device_num[0]) {
        const char* device_num_score = roup_clause_selector_device_num_score(roup_clause);
        clause->setDeviceNumExpression(device_num_score ? device_num_score : "", device_num);
    }

    // Implementation selector (with scores)
    const char* vendor = roup_clause_selector_impl_vendor(roup_clause);
    const char* vendor_score = roup_clause_selector_impl_vendor_score(roup_clause);
    if (vendor && vendor[0]) {
        clause->setImplementationKind(vendor_score ? vendor_score : "", map_context_vendor(vendor));
    }

    OmpStringList* ext_list = roup_clause_selector_impl_extensions(roup_clause);
    OmpStringList* ext_scores = roup_clause_selector_impl_extension_scores(roup_clause);
    if (ext_list) {
        int32_t len = roup_string_list_len(ext_list);
        for (int32_t i = 0; i < len; ++i) {
            const char* value = roup_string_list_get(ext_list, i);
            const char* score = get_score_entry(ext_scores, i);
            if (value && value[0]) {
                clause->setExtensionExpression(score, value);
            }
        }
        roup_string_list_free(ext_list);
    }
    if (ext_scores) {
        roup_string_list_free(ext_scores);
    }

    const char* impl_expr = roup_clause_selector_impl_user_expression(roup_clause);
    const char* impl_expr_score = roup_clause_selector_impl_user_expression_score(roup_clause);
    if (impl_expr && impl_expr[0]) {
        clause->setImplementationExpression(impl_expr_score ? impl_expr_score : "", impl_expr);
    }

    // User selector
    const char* user_cond = roup_clause_selector_user_condition(roup_clause);
    if (user_cond && user_cond[0]) {
        clause->setUserCondition("", user_cond);
    }

    // Construct selector
    OmpDirectiveList* construct_directives = roup_clause_selector_construct_directives(roup_clause);
    OmpStringList* construct_scores = roup_clause_selector_construct_scores(roup_clause);
    if (construct_directives) {
        int32_t len = roup_directive_list_len(construct_directives);
        for (int32_t i = 0; i < len; ++i) {
            OmpDirective* entry = roup_directive_list_get(construct_directives, i);
            if (entry != nullptr) {
                OpenMPDirective* nested =
                    convert_roup_directive_to_ompparser(entry, exprParse, false, debug_variant);
                if (nested != nullptr) {
                    clause->addConstructDirective(get_score_entry(construct_scores, i), nested);
                }
            }
        }
        roup_directive_list_free(construct_directives);
    }
    if (construct_scores) {
        roup_string_list_free(construct_scores);
    }

    // Nested directive (already parsed by ROUP)
    OmpDirective* nested = roup_clause_selector_nested_directive(roup_clause);
    if (nested) {
        OpenMPDirective* nested_dir =
            convert_roup_directive_to_ompparser(nested, exprParse, false, debug_variant);
        if (nested_dir != nullptr && clause->getKind() == OMPC_when) {
            static_cast<OpenMPWhenClause*>(clause)->setVariantDirective(nested_dir);
        } else if (nested_dir != nullptr && clause->getKind() == OMPC_otherwise) {
            static_cast<OpenMPOtherwiseClause*>(clause)->setVariantDirective(nested_dir);
        }
    }

    // Target device selector flag
    if (roup_clause_selector_is_target_device(roup_clause)) {
        clause->setIsTargetDeviceSelector(true);
    }
}

static OpenMPDirectiveKind map_construct_to_directive(const std::string& name) {
    std::string lowered = trim_copy(name);
    if (lowered == "parallel") return OMPD_parallel;
    if (lowered == "for") return OMPD_for;
    if (lowered == "do") return OMPD_do;
    if (lowered == "simd") return OMPD_simd;
    if (lowered == "loop") return OMPD_loop;
    if (lowered == "teams") return OMPD_teams;
    if (lowered == "distribute") return OMPD_distribute;
    if (lowered == "target") return OMPD_target;
    if (lowered == "task") return OMPD_task;
    if (lowered == "sections") return OMPD_sections;
    if (lowered == "section") return OMPD_section;
    if (lowered == "single") return OMPD_single;
    if (lowered == "masked") return OMPD_masked;
    if (lowered == "parallel for") return OMPD_parallel_for;
    if (lowered == "parallel do") return OMPD_parallel_do;
    if (lowered == "parallel loop") return OMPD_parallel_loop;
    if (lowered == "parallel sections") return OMPD_parallel_sections;
    if (lowered == "teams distribute") return OMPD_teams_distribute;
    if (lowered == "teams loop") return OMPD_teams_loop;
    if (lowered == "target teams") return OMPD_target_teams;
    if (lowered == "target teams distribute") return OMPD_target_teams_distribute;
    return OMPD_unknown;
}

static OpenMPDirective* instantiate_directive_for_selector(OpenMPDirectiveKind kind) {
    OpenMPDirective* dir = nullptr;
    if (kind != OMPD_unknown) {
        dir = new OpenMPDirective(kind, current_lang, 0, 0);
    }
    return dir;
}

static OpenMPReductionClauseIdentifier map_reduction_identifier(int32_t code) {
    switch (code) {
        case 0: return OMPC_REDUCTION_IDENTIFIER_plus;
        case 1: return OMPC_REDUCTION_IDENTIFIER_minus;
        case 2: return OMPC_REDUCTION_IDENTIFIER_mul;
        case 3: return OMPC_REDUCTION_IDENTIFIER_bitand;
        case 4: return OMPC_REDUCTION_IDENTIFIER_bitor;
        case 5: return OMPC_REDUCTION_IDENTIFIER_bitxor;
        case 6: return OMPC_REDUCTION_IDENTIFIER_logand;
        case 7: return OMPC_REDUCTION_IDENTIFIER_logor;
        case 8: return OMPC_REDUCTION_IDENTIFIER_min;
        case 9: return OMPC_REDUCTION_IDENTIFIER_max;
        case 10: return OMPC_REDUCTION_IDENTIFIER_eqv;
        case 11: return OMPC_REDUCTION_IDENTIFIER_neqv;
        case 12: return OMPC_REDUCTION_IDENTIFIER_bitand;
        case 13: return OMPC_REDUCTION_IDENTIFIER_bitor;
        case 14: return OMPC_REDUCTION_IDENTIFIER_bitxor;
        case -1: return OMPC_REDUCTION_IDENTIFIER_user;
        default: return OMPC_REDUCTION_IDENTIFIER_unknown;
    }
}

static OpenMPInReductionClauseIdentifier map_in_reduction_identifier(int32_t code) {
    switch (code) {
        case 0: return OMPC_IN_REDUCTION_IDENTIFIER_plus;
        case 1: return OMPC_IN_REDUCTION_IDENTIFIER_minus;
        case 2: return OMPC_IN_REDUCTION_IDENTIFIER_mul;
        case 3: return OMPC_IN_REDUCTION_IDENTIFIER_bitand;
        case 4: return OMPC_IN_REDUCTION_IDENTIFIER_bitor;
        case 5: return OMPC_IN_REDUCTION_IDENTIFIER_bitxor;
        case 6: return OMPC_IN_REDUCTION_IDENTIFIER_logand;
        case 7: return OMPC_IN_REDUCTION_IDENTIFIER_logor;
        case 8: return OMPC_IN_REDUCTION_IDENTIFIER_min;
        case 9: return OMPC_IN_REDUCTION_IDENTIFIER_max;
        case 10: return OMPC_IN_REDUCTION_IDENTIFIER_eqv;
        case 11: return OMPC_IN_REDUCTION_IDENTIFIER_neqv;
        case -1: return OMPC_IN_REDUCTION_IDENTIFIER_user;
        default: return OMPC_IN_REDUCTION_IDENTIFIER_unknown;
    }
}

static OpenMPTaskReductionClauseIdentifier map_task_reduction_identifier(int32_t code) {
    switch (code) {
        case 0: return OMPC_TASK_REDUCTION_IDENTIFIER_plus;
        case 1: return OMPC_TASK_REDUCTION_IDENTIFIER_minus;
        case 2: return OMPC_TASK_REDUCTION_IDENTIFIER_mul;
        case 3: return OMPC_TASK_REDUCTION_IDENTIFIER_bitand;
        case 4: return OMPC_TASK_REDUCTION_IDENTIFIER_bitor;
        case 5: return OMPC_TASK_REDUCTION_IDENTIFIER_bitxor;
        case 6: return OMPC_TASK_REDUCTION_IDENTIFIER_logand;
        case 7: return OMPC_TASK_REDUCTION_IDENTIFIER_logor;
        case 8: return OMPC_TASK_REDUCTION_IDENTIFIER_min;
        case 9: return OMPC_TASK_REDUCTION_IDENTIFIER_max;
        case 10: return OMPC_TASK_REDUCTION_IDENTIFIER_eqv;
        case 11: return OMPC_TASK_REDUCTION_IDENTIFIER_neqv;
        case -1: return OMPC_TASK_REDUCTION_IDENTIFIER_user;
        default: return OMPC_TASK_REDUCTION_IDENTIFIER_unknown;
    }
}

static OpenMPReductionClauseModifier select_reduction_modifier(uint32_t mask) {
    const bool has_task = (mask & ROUP_REDUCTION_MODIFIER_TASK) != 0;
    const bool has_inscan = (mask & ROUP_REDUCTION_MODIFIER_INSCAN) != 0;
    const bool has_default = (mask & ROUP_REDUCTION_MODIFIER_DEFAULT) != 0;

    const int count = static_cast<int>(has_task) + static_cast<int>(has_inscan) + static_cast<int>(has_default);
    if (count == 0) {
        return OMPC_REDUCTION_MODIFIER_unspecified;
    }
    if (count > 1) {
        return OMPC_REDUCTION_MODIFIER_unknown;
    }
    if (has_task) {
        return OMPC_REDUCTION_MODIFIER_task;
    }
    if (has_inscan) {
        return OMPC_REDUCTION_MODIFIER_inscan;
    }
    if (has_default) {
        return OMPC_REDUCTION_MODIFIER_default;
    }
    return OMPC_REDUCTION_MODIFIER_unspecified;
}

static void append_variables_to_clause(OpenMPClause* clause, OmpStringList* list) {
    if (clause == nullptr || list == nullptr) {
        return;
    }

    bool force_space_before_colon = false;
    const bool format_mapper_spacing =
        clause->getKind() == OMPC_to || clause->getKind() == OMPC_from ||
        clause->getKind() == OMPC_link || clause->getKind() == OMPC_map;
    if (clause->getKind() == OMPC_linear) {
        if (const char* first = roup_string_list_get(list, 0)) {
            std::string trimmed_first(first);
            trimmed_first.erase(0, trimmed_first.find_first_not_of(" \t"));
            if (trimmed_first.rfind("val(", 0) == 0 ||
                trimmed_first.rfind("ref(", 0) == 0 ||
                trimmed_first.rfind("uval(", 0) == 0) {
                force_space_before_colon = true;
            }
        }
    }

    int length = roup_string_list_len(list);
    for (int i = 0; i < length; ++i) {
        const char* item = roup_string_list_get(list, i);
        if (item == nullptr) {
            continue;
        }
        std::string expr(item);
        if (force_space_before_colon && i == length - 1 && !expr.empty() && expr.back() != ' ') {
            expr.push_back(' ');
        }
        std::string cleaned = trim_paren_padding(expr);
        if (format_mapper_spacing) {
            cleaned = format_clause_args(cleaned.c_str(), true);
        } else if (!force_space_before_colon) {
            cleaned = normalize_expression(cleaned.c_str());
        }
        clause->addLangExpr(strdup(cleaned.c_str()));
    }
}

static void add_reduction_clause_from_data(
    OpenMPDirective* dir,
    const OmpClause* roup_clause,
    OpenMPClauseKind clause_kind
) {
    if (roup_clause == nullptr) {
        return;
    }

    int32_t operator_code = roup_clause_reduction_operator(roup_clause);
    uint32_t modifier_mask = roup_clause_reduction_modifier_mask(roup_clause);
    const char* user_identifier = roup_clause_reduction_user_identifier(roup_clause);
    const char* modifiers_text = roup_clause_reduction_modifiers_text(roup_clause);

    char* user_identifier_dup = duplicate_c_string(user_identifier);
    char* user_modifier_dup = duplicate_c_string(modifiers_text);

    OpenMPClause* clause_ptr = nullptr;

    if (clause_kind == OMPC_reduction) {
        clause_ptr = OpenMPReductionClause::addReductionClause(
            dir,
            select_reduction_modifier(modifier_mask),
            map_reduction_identifier(operator_code),
            user_modifier_dup,
            user_identifier_dup
        );
    } else if (clause_kind == OMPC_in_reduction) {
        clause_ptr = OpenMPInReductionClause::addInReductionClause(
            dir,
            map_in_reduction_identifier(operator_code),
            user_identifier_dup
        );
        if (user_modifier_dup) {
            free(user_modifier_dup);
        }
    } else {
        clause_ptr = OpenMPTaskReductionClause::addTaskReductionClause(
            dir,
            map_task_reduction_identifier(operator_code),
            user_identifier_dup
        );
        if (user_modifier_dup) {
            free(user_modifier_dup);
        }
    }

    if (clause_ptr == nullptr) {
        if (user_identifier_dup) {
            free(user_identifier_dup);
        }
        if (clause_kind == OMPC_reduction && user_modifier_dup) {
            free(user_modifier_dup);
        }
        return;
    }

    OmpStringList* variables = roup_clause_variables(roup_clause);
    append_variables_to_clause(clause_ptr, variables);
    if (variables) {
        roup_string_list_free(variables);
    }

    if (clause_ptr != nullptr && clause_ptr->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause_ptr);
        clause_ptr->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

// Determine if a clause kind takes a comma-separated list of expressions
static bool is_list_clause(OpenMPClauseKind kind) {
    switch (kind) {
        // Data-scoping attribute clauses (most common)
        case OMPC_private:
        case OMPC_firstprivate:
        case OMPC_lastprivate:
        case OMPC_shared:
        case OMPC_copyin:
        case OMPC_copyprivate:
        // Data-sharing clauses
        case OMPC_linear:
        case OMPC_aligned:
        case OMPC_nontemporal:
        case OMPC_uniform:
        // Scan clauses
        case OMPC_inclusive:
        case OMPC_exclusive:
        // Device clauses
        case OMPC_is_device_ptr:
        case OMPC_use_device_ptr:
        case OMPC_use_device_addr:
        case OMPC_has_device_addr:
        // Map-like clauses
        case OMPC_to:
        case OMPC_from:
        case OMPC_link:
        // Depend clause
        case OMPC_depend:
        // Affinity clause
        case OMPC_sizes:
        // Allocator clauses
        case OMPC_allocate:
            return true;
        default:
            return false;
    }
}

// ============================================================================
// Global State
// ============================================================================

// Language prefix constants - defined once to avoid manual synchronization
static constexpr const char FORTRAN_PREFIX[] = "!$omp";       // Fortran prefix (lowercase)
static constexpr const char FORTRAN_PREFIX_UPPER[] = "!$OMP"; // Fortran prefix (uppercase)
static constexpr const char C_PRAGMA_PREFIX[] = "#pragma";    // C/C++ pragma prefix
// Compile-time string lengths: sizeof() includes null terminator, subtract 1 for actual length
static constexpr size_t FORTRAN_PREFIX_LEN = sizeof(FORTRAN_PREFIX) - 1;
static constexpr size_t C_PRAGMA_PREFIX_LEN = sizeof(C_PRAGMA_PREFIX) - 1;

extern "C" void setLang(OpenMPBaseLang lang) {
    current_lang = lang;
}

// ============================================================================
// Helper Functions
// ============================================================================

static size_t find_fortran_prefix_start(const std::string& text) {
    const size_t start = text.find_first_not_of(" \t");
    if (start == std::string::npos || text.size() - start < FORTRAN_PREFIX_LEN) {
        return std::string::npos;
    }

    const char leading = static_cast<char>(std::tolower(text[start]));
    if (leading != '!' && leading != 'c' && leading != '*') {
        return std::string::npos;
    }

    const size_t marker_pos = start + 1;
    if (marker_pos >= text.size() || text[marker_pos] != '$') {
        return std::string::npos;
    }

    const size_t omp_pos = marker_pos + 1;
    if (omp_pos + 2 >= text.size()) {
        return std::string::npos;
    }

    const char o = static_cast<char>(std::tolower(text[omp_pos]));
    const char m = static_cast<char>(std::tolower(text[omp_pos + 1]));
    const char p = static_cast<char>(std::tolower(text[omp_pos + 2]));
    return (o == 'o' && m == 'm' && p == 'p') ? start : std::string::npos;
}

static size_t find_c_prefix_start(const std::string& text) {
    const size_t start = text.find_first_not_of(" \t");
    if (start == std::string::npos || text.size() - start < C_PRAGMA_PREFIX_LEN) {
        return std::string::npos;
    }

    bool matches = true;
    for (size_t i = 0; i < C_PRAGMA_PREFIX_LEN; ++i) {
        char lhs = static_cast<char>(std::tolower(text[start + i]));
        char rhs = static_cast<char>(std::tolower(C_PRAGMA_PREFIX[i]));
        if (lhs != rhs) {
            matches = false;
            break;
        }
    }
    return matches ? start : std::string::npos;
}

// Map ROUP end directive constants to their paired directive kind
// This is pure enum-based mapping with NO string processing
static OpenMPDirectiveKind getEndDirectivePairedKind(int32_t roup_end_kind) {
    switch (roup_end_kind) {
        // End directives (131-195) -> their paired directive kinds
        case ROUP_OMPD_end_parallel:         return OMPD_parallel;
        case ROUP_OMPD_end_do:               return OMPD_do;
        case ROUP_OMPD_end_simd:             return OMPD_simd;
        case ROUP_OMPD_end_sections:         return OMPD_sections;
        case ROUP_OMPD_end_single:           return OMPD_single;
        case ROUP_OMPD_end_workshare:        return OMPD_workshare;
        case ROUP_OMPD_end_ordered:          return OMPD_ordered;
        case ROUP_OMPD_end_loop:             return OMPD_loop;
        case ROUP_OMPD_end_distribute:       return OMPD_distribute;
        case ROUP_OMPD_end_teams:            return OMPD_teams;
        case ROUP_OMPD_end_taskloop:         return OMPD_taskloop;
        case ROUP_OMPD_end_task:             return OMPD_task;
        case ROUP_OMPD_end_taskgroup:        return OMPD_taskgroup;
        case ROUP_OMPD_end_master:           return OMPD_master;
        case ROUP_OMPD_end_masked:           return OMPD_masked;
        case ROUP_OMPD_end_critical:         return OMPD_critical;
        case ROUP_OMPD_end_atomic:           return OMPD_atomic;
        case ROUP_OMPD_end_parallel_do:      return OMPD_parallel_do;
        case ROUP_OMPD_end_parallel_for:     return OMPD_parallel_for;
        case ROUP_OMPD_end_parallel_sections: return OMPD_parallel_sections;
        case ROUP_OMPD_end_parallel_workshare: return OMPD_parallel_workshare;
        case ROUP_OMPD_end_parallel_master:  return OMPD_parallel_master;
        case ROUP_OMPD_end_do_simd:          return OMPD_do_simd;
        case ROUP_OMPD_end_for_simd:         return OMPD_for_simd;
        case ROUP_OMPD_end_parallel_do_simd: return OMPD_parallel_do_simd;
        case ROUP_OMPD_end_parallel_for_simd: return OMPD_parallel_for_simd;
        case ROUP_OMPD_end_distribute_simd:  return OMPD_distribute_simd;
        case ROUP_OMPD_end_distribute_parallel_do: return OMPD_distribute_parallel_do;
        case ROUP_OMPD_end_distribute_parallel_for: return OMPD_distribute_parallel_for;
        case ROUP_OMPD_end_distribute_parallel_do_simd: return OMPD_distribute_parallel_do_simd;
        case ROUP_OMPD_end_distribute_parallel_for_simd: return OMPD_distribute_parallel_for_simd;
        case ROUP_OMPD_end_target_parallel:  return OMPD_target_parallel;
        case ROUP_OMPD_end_target_parallel_do: return OMPD_target_parallel_do;
        case ROUP_OMPD_end_target_parallel_for: return OMPD_target_parallel_for;
        case ROUP_OMPD_end_target_parallel_do_simd: return OMPD_target_parallel_do_simd;
        case ROUP_OMPD_end_target_parallel_for_simd: return OMPD_target_parallel_for_simd;
        case ROUP_OMPD_end_target_simd:      return OMPD_target_simd;
        case ROUP_OMPD_end_target_teams:     return OMPD_target_teams;
        case ROUP_OMPD_end_target_teams_distribute: return OMPD_target_teams_distribute;
        case ROUP_OMPD_end_target_teams_distribute_parallel_do: return OMPD_target_teams_distribute_parallel_do;
        case ROUP_OMPD_end_target_teams_distribute_parallel_for: return OMPD_target_teams_distribute_parallel_for;
        case ROUP_OMPD_end_target_teams_distribute_parallel_do_simd: return OMPD_target_teams_distribute_parallel_do_simd;
        case ROUP_OMPD_end_target_teams_distribute_parallel_for_simd: return OMPD_target_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_end_target_teams_distribute_simd: return OMPD_target_teams_distribute_simd;
        case ROUP_OMPD_end_target_teams_loop: return OMPD_target_teams_loop;
        case ROUP_OMPD_end_teams_distribute: return OMPD_teams_distribute;
        case ROUP_OMPD_end_teams_distribute_parallel_do: return OMPD_teams_distribute_parallel_do;
        case ROUP_OMPD_end_teams_distribute_parallel_for: return OMPD_teams_distribute_parallel_for;
        case ROUP_OMPD_end_teams_distribute_parallel_do_simd: return OMPD_teams_distribute_parallel_do_simd;
        case ROUP_OMPD_end_teams_distribute_parallel_for_simd: return OMPD_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_end_teams_distribute_simd: return OMPD_teams_distribute_simd;
        case ROUP_OMPD_end_teams_loop:       return OMPD_teams_loop;
        case ROUP_OMPD_end_taskloop_simd:    return OMPD_taskloop_simd;
        case ROUP_OMPD_end_master_taskloop:  return OMPD_master_taskloop;
        case ROUP_OMPD_end_master_taskloop_simd: return OMPD_master_taskloop_simd;
        case ROUP_OMPD_end_masked_taskloop:  return OMPD_masked_taskloop;
        case ROUP_OMPD_end_masked_taskloop_simd: return OMPD_masked_taskloop_simd;
        case ROUP_OMPD_end_parallel_master_taskloop: return OMPD_parallel_master_taskloop;
        case ROUP_OMPD_end_parallel_master_taskloop_simd: return OMPD_parallel_master_taskloop_simd;
        case ROUP_OMPD_end_parallel_masked:      return OMPD_parallel_masked;
        case ROUP_OMPD_end_parallel_masked_taskloop: return OMPD_parallel_masked_taskloop;
        case ROUP_OMPD_end_parallel_masked_taskloop_simd: return OMPD_parallel_masked_taskloop_simd;
        case ROUP_OMPD_end_target_parallel_loop: return OMPD_target_parallel_loop;
        case ROUP_OMPD_end_parallel_loop:    return OMPD_parallel_loop;
        case ROUP_OMPD_end_target_loop:      return OMPD_target_loop;
        case ROUP_OMPD_end_section:          return OMPD_section;
        case ROUP_OMPD_end_unroll:           return OMPD_unroll;
        case ROUP_OMPD_end_tile:             return OMPD_tile;
        case ROUP_OMPD_end_target:           return OMPD_target;
        case ROUP_OMPD_end_target_data:      return OMPD_target_data;
        case ROUP_OMPD_end_target_enter_data: return OMPD_target_enter_data;
        case ROUP_OMPD_end_target_exit_data: return OMPD_target_exit_data;
        case ROUP_OMPD_end_target_update:    return OMPD_target_update;
        // Special end directives that already had unique constants
        case ROUP_OMPD_end_declare_target:   return OMPD_declare_target;
        case ROUP_OMPD_end_declare_variant:  return OMPD_declare_variant;
        case ROUP_OMPD_end_assume:           return OMPD_assume;
        case ROUP_OMPD_end_assumes:          return OMPD_assumes;
        // Bare "end" directive (rare, mainly for error recovery)
        case ROUP_OMPD_end:                  return OMPD_unknown;
        default:                                  return OMPD_unknown;
    }
}

static OpenMPDirectiveKind mapRoupToOmpparserDirective(int32_t roup_kind) {
    // ROUP directive kind mapping using named constants
    // Complete 1:1 mapping of all 131 OpenMP directives
    // See roup_constants.h and src/c_api.rs:directive_name_to_kind()
    switch (roup_kind) {
        case ROUP_OMPD_parallel:       return OMPD_parallel;
        case ROUP_OMPD_for:            return OMPD_for;
        case ROUP_OMPD_do:             return OMPD_do;
        case ROUP_OMPD_simd:           return OMPD_simd;
        case ROUP_OMPD_for_simd:       return OMPD_for_simd;
        case ROUP_OMPD_do_simd:        return OMPD_do_simd;
        case ROUP_OMPD_parallel_for_simd: return OMPD_parallel_for_simd;
        case ROUP_OMPD_parallel_do_simd:  return OMPD_parallel_do_simd;
        case ROUP_OMPD_declare_simd:   return OMPD_declare_simd;
        case ROUP_OMPD_distribute:     return OMPD_distribute;
        case ROUP_OMPD_distribute_simd: return OMPD_distribute_simd;
        case ROUP_OMPD_distribute_parallel_for: return OMPD_distribute_parallel_for;
        case ROUP_OMPD_distribute_parallel_do:  return OMPD_distribute_parallel_do;
        case ROUP_OMPD_distribute_parallel_for_simd: return OMPD_distribute_parallel_for_simd;
        case ROUP_OMPD_distribute_parallel_do_simd:  return OMPD_distribute_parallel_do_simd;
        case ROUP_OMPD_loop:           return OMPD_loop;
        case ROUP_OMPD_scan:           return OMPD_scan;
        case ROUP_OMPD_sections:       return OMPD_sections;
        case ROUP_OMPD_section:        return OMPD_section;
        case ROUP_OMPD_single:         return OMPD_single;
        case ROUP_OMPD_workshare:      return OMPD_workshare;
        case ROUP_OMPD_cancel:         return OMPD_cancel;
        case ROUP_OMPD_cancellation_point: return OMPD_cancellation_point;
        case ROUP_OMPD_allocate:       return OMPD_allocate;
        case ROUP_OMPD_threadprivate:  return OMPD_threadprivate;
        case ROUP_OMPD_declare_reduction: return OMPD_declare_reduction;
        case ROUP_OMPD_declare_mapper: return OMPD_declare_mapper;
        case ROUP_OMPD_parallel_for:   return OMPD_parallel_for;
        case ROUP_OMPD_parallel_do:    return OMPD_parallel_do;
        case ROUP_OMPD_parallel_loop:  return OMPD_parallel_loop;
        case ROUP_OMPD_parallel_sections: return OMPD_parallel_sections;
        case ROUP_OMPD_parallel_single: return OMPD_parallel_single;
        case ROUP_OMPD_parallel_workshare: return OMPD_parallel_workshare;
        case ROUP_OMPD_parallel_master: return OMPD_parallel_master;
        case ROUP_OMPD_master_taskloop: return OMPD_master_taskloop;
        case ROUP_OMPD_master_taskloop_simd: return OMPD_master_taskloop_simd;
        case ROUP_OMPD_parallel_master_taskloop: return OMPD_parallel_master_taskloop;
        case ROUP_OMPD_parallel_master_taskloop_simd: return OMPD_parallel_master_taskloop_simd;
        case ROUP_OMPD_teams:          return OMPD_teams;
        case ROUP_OMPD_metadirective:  return OMPD_metadirective;
        case ROUP_OMPD_declare_variant: return OMPD_declare_variant;
        case ROUP_OMPD_begin_declare_variant: return OMPD_begin_declare_variant;
        case ROUP_OMPD_end_declare_variant: return OMPD_end_declare_variant;
        case ROUP_OMPD_task:           return OMPD_task;
        case ROUP_OMPD_taskloop:       return OMPD_taskloop;
        case ROUP_OMPD_taskloop_simd:  return OMPD_taskloop_simd;
        case ROUP_OMPD_taskyield:      return OMPD_taskyield;
        case ROUP_OMPD_requires:       return OMPD_requires;
        case ROUP_OMPD_target_data:    return OMPD_target_data;
        case ROUP_OMPD_target_data_composite: return OMPD_target_data_composite;
        case ROUP_OMPD_target_enter_data: return OMPD_target_enter_data;
        case ROUP_OMPD_target_update:  return OMPD_target_update;
        case ROUP_OMPD_target_exit_data: return OMPD_target_exit_data;
        case ROUP_OMPD_target:         return OMPD_target;
        case ROUP_OMPD_declare_target: return OMPD_declare_target;
        case ROUP_OMPD_begin_declare_target: return OMPD_begin_declare_target;
        case ROUP_OMPD_end_declare_target: return OMPD_end_declare_target;
        case ROUP_OMPD_master:         return OMPD_master;
        case ROUP_OMPD_end:            return OMPD_end;
        case ROUP_OMPD_barrier:        return OMPD_barrier;
        case ROUP_OMPD_taskwait:       return OMPD_taskwait;
        case ROUP_OMPD_unroll:         return OMPD_unroll;
        case ROUP_OMPD_tile:           return OMPD_tile;
        case ROUP_OMPD_taskgroup:      return OMPD_taskgroup;
        case ROUP_OMPD_flush:          return OMPD_flush;
        case ROUP_OMPD_atomic:         return OMPD_atomic;
        case ROUP_OMPD_critical:       return OMPD_critical;
        case ROUP_OMPD_depobj:         return OMPD_depobj;
        case ROUP_OMPD_ordered:        return OMPD_ordered;
        case ROUP_OMPD_teams_distribute: return OMPD_teams_distribute;
        case ROUP_OMPD_teams_distribute_simd: return OMPD_teams_distribute_simd;
        case ROUP_OMPD_teams_distribute_parallel_for: return OMPD_teams_distribute_parallel_for;
        case ROUP_OMPD_teams_distribute_parallel_for_simd: return OMPD_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_teams_loop:     return OMPD_teams_loop;
        case ROUP_OMPD_target_parallel: return OMPD_target_parallel;
        case ROUP_OMPD_target_parallel_for: return OMPD_target_parallel_for;
        case ROUP_OMPD_target_parallel_for_simd: return OMPD_target_parallel_for_simd;
        case ROUP_OMPD_target_parallel_loop: return OMPD_target_parallel_loop;
        case ROUP_OMPD_target_simd:    return OMPD_target_simd;
        case ROUP_OMPD_target_teams:   return OMPD_target_teams;
        case ROUP_OMPD_target_teams_distribute: return OMPD_target_teams_distribute;
        case ROUP_OMPD_target_teams_distribute_simd: return OMPD_target_teams_distribute_simd;
        case ROUP_OMPD_target_teams_loop: return OMPD_target_teams_loop;
        case ROUP_OMPD_target_teams_distribute_parallel_for: return OMPD_target_teams_distribute_parallel_for;
        case ROUP_OMPD_target_teams_distribute_parallel_for_simd: return OMPD_target_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_teams_distribute_parallel_do: return OMPD_teams_distribute_parallel_do;
        case ROUP_OMPD_teams_distribute_parallel_do_simd: return OMPD_teams_distribute_parallel_do_simd;
        case ROUP_OMPD_target_parallel_do: return OMPD_target_parallel_do;
        case ROUP_OMPD_target_parallel_do_simd: return OMPD_target_parallel_do_simd;
        case ROUP_OMPD_target_teams_distribute_parallel_do: return OMPD_target_teams_distribute_parallel_do;
        case ROUP_OMPD_target_teams_distribute_parallel_do_simd: return OMPD_target_teams_distribute_parallel_do_simd;
        // OpenMP 5.1 directives
        case ROUP_OMPD_error:          return OMPD_error;
        case ROUP_OMPD_nothing:        return OMPD_nothing;
        case ROUP_OMPD_masked:         return OMPD_masked;
        case ROUP_OMPD_scope:          return OMPD_scope;
        case ROUP_OMPD_masked_taskloop: return OMPD_masked_taskloop;
        case ROUP_OMPD_masked_taskloop_simd: return OMPD_masked_taskloop_simd;
        case ROUP_OMPD_parallel_masked: return OMPD_parallel_masked;
        case ROUP_OMPD_parallel_masked_taskloop: return OMPD_parallel_masked_taskloop;
        case ROUP_OMPD_parallel_masked_taskloop_simd: return OMPD_parallel_masked_taskloop_simd;
        case ROUP_OMPD_interop:        return OMPD_interop;
        // OpenMP 5.2 directives
        case ROUP_OMPD_assume:         return OMPD_assume;
        case ROUP_OMPD_end_assume:     return OMPD_end_assume;
        case ROUP_OMPD_assumes:        return OMPD_assumes;
        case ROUP_OMPD_begin_assumes:  return OMPD_begin_assumes;
        case ROUP_OMPD_end_assumes:    return OMPD_end_assumes;
        // OpenMP 6.0 directives
        case ROUP_OMPD_allocators:     return OMPD_allocators;
        case ROUP_OMPD_taskgraph:      return OMPD_taskgraph;
        case ROUP_OMPD_task_iteration: return OMPD_task_iteration;
        case ROUP_OMPD_dispatch:       return OMPD_dispatch;
        case ROUP_OMPD_groupprivate:   return OMPD_groupprivate;
        case ROUP_OMPD_workdistribute: return OMPD_workdistribute;
        case ROUP_OMPD_fuse:           return OMPD_fuse;
        case ROUP_OMPD_interchange:    return OMPD_interchange;
        case ROUP_OMPD_reverse:        return OMPD_reverse;
        case ROUP_OMPD_split:          return OMPD_split;
        case ROUP_OMPD_stripe:         return OMPD_stripe;
        case ROUP_OMPD_declare_induction: return OMPD_declare_induction;
        case ROUP_OMPD_begin_metadirective: return OMPD_begin_metadirective;
        // Missing *_loop and *_loop_simd combinations
        case ROUP_OMPD_parallel_loop_simd: return OMPD_parallel_loop_simd;
        case ROUP_OMPD_teams_loop_simd: return OMPD_teams_loop_simd;
        case ROUP_OMPD_target_loop:    return OMPD_target_loop;
        case ROUP_OMPD_target_loop_simd: return OMPD_target_loop_simd;
        case ROUP_OMPD_target_parallel_loop_simd: return OMPD_target_parallel_loop_simd;
        case ROUP_OMPD_target_teams_loop_simd: return OMPD_target_teams_loop_simd;
        case ROUP_OMPD_distribute_parallel_loop: return OMPD_distribute_parallel_loop;
        case ROUP_OMPD_distribute_parallel_loop_simd: return OMPD_distribute_parallel_loop_simd;
        case ROUP_OMPD_teams_distribute_parallel_loop: return OMPD_teams_distribute_parallel_loop;
        case ROUP_OMPD_teams_distribute_parallel_loop_simd: return OMPD_teams_distribute_parallel_loop_simd;
        case ROUP_OMPD_target_teams_distribute_parallel_loop: return OMPD_target_teams_distribute_parallel_loop;
        case ROUP_OMPD_target_teams_distribute_parallel_loop_simd: return OMPD_target_teams_distribute_parallel_loop_simd;
        // All End* directives (131-195) map to OMPD_end in ompparser
        case ROUP_OMPD_end_parallel:
        case ROUP_OMPD_end_do:
        case ROUP_OMPD_end_simd:
        case ROUP_OMPD_end_sections:
        case ROUP_OMPD_end_single:
        case ROUP_OMPD_end_workshare:
        case ROUP_OMPD_end_ordered:
        case ROUP_OMPD_end_loop:
        case ROUP_OMPD_end_distribute:
        case ROUP_OMPD_end_teams:
        case ROUP_OMPD_end_taskloop:
        case ROUP_OMPD_end_task:
        case ROUP_OMPD_end_taskgroup:
        case ROUP_OMPD_end_master:
        case ROUP_OMPD_end_critical:
        case ROUP_OMPD_end_atomic:
        case ROUP_OMPD_end_parallel_do:
        case ROUP_OMPD_end_parallel_for:
        case ROUP_OMPD_end_parallel_sections:
        case ROUP_OMPD_end_parallel_workshare:
        case ROUP_OMPD_end_parallel_master:
        case ROUP_OMPD_end_do_simd:
        case ROUP_OMPD_end_for_simd:
        case ROUP_OMPD_end_parallel_do_simd:
        case ROUP_OMPD_end_parallel_for_simd:
        case ROUP_OMPD_end_distribute_simd:
        case ROUP_OMPD_end_distribute_parallel_do:
        case ROUP_OMPD_end_distribute_parallel_for:
        case ROUP_OMPD_end_distribute_parallel_do_simd:
        case ROUP_OMPD_end_distribute_parallel_for_simd:
        case ROUP_OMPD_end_target_parallel:
        case ROUP_OMPD_end_target_parallel_do:
        case ROUP_OMPD_end_target_parallel_for:
        case ROUP_OMPD_end_target_parallel_do_simd:
        case ROUP_OMPD_end_target_parallel_for_simd:
        case ROUP_OMPD_end_target_simd:
        case ROUP_OMPD_end_target_teams:
        case ROUP_OMPD_end_target_teams_distribute:
        case ROUP_OMPD_end_target_teams_distribute_parallel_do:
        case ROUP_OMPD_end_target_teams_distribute_parallel_for:
        case ROUP_OMPD_end_target_teams_distribute_parallel_do_simd:
        case ROUP_OMPD_end_target_teams_distribute_parallel_for_simd:
        case ROUP_OMPD_end_target_teams_distribute_simd:
        case ROUP_OMPD_end_target_teams_loop:
        case ROUP_OMPD_end_teams_distribute:
        case ROUP_OMPD_end_teams_distribute_parallel_do:
        case ROUP_OMPD_end_teams_distribute_parallel_for:
        case ROUP_OMPD_end_teams_distribute_parallel_do_simd:
        case ROUP_OMPD_end_teams_distribute_parallel_for_simd:
        case ROUP_OMPD_end_teams_distribute_simd:
        case ROUP_OMPD_end_teams_loop:
        case ROUP_OMPD_end_taskloop_simd:
        case ROUP_OMPD_end_master_taskloop:
        case ROUP_OMPD_end_master_taskloop_simd:
        case ROUP_OMPD_end_parallel_master_taskloop:
        case ROUP_OMPD_end_parallel_master_taskloop_simd:
        case ROUP_OMPD_end_target_parallel_loop:
        case ROUP_OMPD_end_parallel_loop:
        case ROUP_OMPD_end_target_loop:
        case ROUP_OMPD_end_section:
        case ROUP_OMPD_end_unroll:
        case ROUP_OMPD_end_tile:
        case ROUP_OMPD_end_target:
        case ROUP_OMPD_end_target_data:
        case ROUP_OMPD_end_target_enter_data:
        case ROUP_OMPD_end_target_exit_data:
        case ROUP_OMPD_end_target_update:
            return OMPD_end;
        default:                            return OMPD_unknown;
    }
}

static OpenMPClauseKind mapRoupToOmpparserClause(int32_t roup_kind) {
    // ROUP clause kind mapping using named constants from roup_constants.h
    // Complete mapping of all OpenMP clauses
    // Single source of truth: src/c_api.rs:convert_clause()
    switch (roup_kind) {
        case ROUP_OMPC_if:            return OMPC_if;
        case ROUP_OMPC_num_threads:   return OMPC_num_threads;
        case ROUP_OMPC_default:       return OMPC_default;
        case ROUP_OMPC_private:       return OMPC_private;
        case ROUP_OMPC_firstprivate:  return OMPC_firstprivate;
        case ROUP_OMPC_shared:        return OMPC_shared;
        case ROUP_OMPC_copy_in:       return OMPC_copyin;
        case ROUP_OMPC_align:         return OMPC_align;
        case ROUP_OMPC_reduction:     return OMPC_reduction;
        case ROUP_OMPC_lastprivate:   return OMPC_lastprivate;
        case ROUP_OMPC_collapse:      return OMPC_collapse;
        case ROUP_OMPC_ordered:       return OMPC_ordered;
        case ROUP_OMPC_nowait:        return OMPC_nowait;
        case ROUP_OMPC_schedule:      return OMPC_schedule;
        case ROUP_OMPC_allocator:     return OMPC_allocator;
        case ROUP_OMPC_device:        return OMPC_device;
        case ROUP_OMPC_map:           return OMPC_map;
        case ROUP_OMPC_link:          return OMPC_link;
        case ROUP_OMPC_device_type:   return OMPC_device_type;
        case ROUP_OMPC_acq_rel:       return OMPC_acq_rel;
        case ROUP_OMPC_release:       return OMPC_release;
        case ROUP_OMPC_acquire:       return OMPC_acquire;
        case ROUP_OMPC_read:          return OMPC_read;
        case ROUP_OMPC_write:         return OMPC_write;
        case ROUP_OMPC_update:        return OMPC_update;
        case ROUP_OMPC_capture:       return OMPC_capture;
        case ROUP_OMPC_seq_cst:       return OMPC_seq_cst;
        case ROUP_OMPC_relaxed:       return OMPC_relaxed;
        case ROUP_OMPC_hint:          return OMPC_hint;
        case ROUP_OMPC_num_teams:     return OMPC_num_teams;
        case ROUP_OMPC_thread_limit:  return OMPC_thread_limit;
        case ROUP_OMPC_dist_schedule: return OMPC_dist_schedule;
        case ROUP_OMPC_in_reduction:  return OMPC_in_reduction;
        case ROUP_OMPC_depend:        return OMPC_depend;
        case ROUP_OMPC_is_device_ptr: return OMPC_is_device_ptr;
        case ROUP_OMPC_defaultmap:    return OMPC_defaultmap;
        case ROUP_OMPC_uses_allocators: return OMPC_uses_allocators;
        // Additional OpenMP clauses from spec
        case ROUP_OMPC_proc_bind:     return OMPC_proc_bind;
        case ROUP_OMPC_allocate:      return OMPC_allocate;
        case ROUP_OMPC_linear:        return OMPC_linear;
        case ROUP_OMPC_safelen:       return OMPC_safelen;
        case ROUP_OMPC_simdlen:       return OMPC_simdlen;
        case ROUP_OMPC_aligned:       return OMPC_aligned;
        case ROUP_OMPC_nontemporal:   return OMPC_nontemporal;
        case ROUP_OMPC_uniform:       return OMPC_uniform;
        case ROUP_OMPC_inbranch:      return OMPC_inbranch;
        case ROUP_OMPC_notinbranch:   return OMPC_notinbranch;
        case ROUP_OMPC_bind:          return OMPC_bind;
        case ROUP_OMPC_inclusive:     return OMPC_inclusive;
        case ROUP_OMPC_exclusive:     return OMPC_exclusive;
        case ROUP_OMPC_copyprivate:   return OMPC_copyprivate;
        case ROUP_OMPC_parallel:      return OMPC_parallel;
        case ROUP_OMPC_sections:      return OMPC_sections;
        case ROUP_OMPC_for:           return OMPC_for;
        case ROUP_OMPC_do:            return OMPC_do;
        case ROUP_OMPC_taskgroup:     return OMPC_taskgroup;
        case ROUP_OMPC_initializer:   return OMPC_initializer;
        case ROUP_OMPC_final:         return OMPC_final;
        case ROUP_OMPC_untied:        return OMPC_untied;
        case ROUP_OMPC_requires:      return OMPC_requires;
        case ROUP_OMPC_mergeable:     return OMPC_mergeable;
        case ROUP_OMPC_priority:      return OMPC_priority;
        case ROUP_OMPC_affinity:      return OMPC_affinity;
        case ROUP_OMPC_detach:        return OMPC_detach;
        case ROUP_OMPC_grainsize:     return OMPC_grainsize;
        case ROUP_OMPC_num_tasks:     return OMPC_num_tasks;
        case ROUP_OMPC_nogroup:       return OMPC_nogroup;
        case ROUP_OMPC_reverse_offload: return OMPC_reverse_offload;
        case ROUP_OMPC_unified_address: return OMPC_unified_address;
        case ROUP_OMPC_unified_shared_memory: return OMPC_unified_shared_memory;
        case ROUP_OMPC_atomic_default_mem_order: return OMPC_atomic_default_mem_order;
        case ROUP_OMPC_dynamic_allocators: return OMPC_dynamic_allocators;
        case ROUP_OMPC_self_maps:     return OMPC_self_maps;
        case ROUP_OMPC_ext_implementation_defined_requirement: return OMPC_ext_implementation_defined_requirement;
        case ROUP_OMPC_use_device_ptr: return OMPC_use_device_ptr;
        case ROUP_OMPC_sizes:         return OMPC_sizes;
        case ROUP_OMPC_use_device_addr: return OMPC_use_device_addr;
        case ROUP_OMPC_has_device_addr: return OMPC_has_device_addr;
        case ROUP_OMPC_to:            return OMPC_to;
        case ROUP_OMPC_from:          return OMPC_from;
        case ROUP_OMPC_when:          return OMPC_when;
        case ROUP_OMPC_otherwise:     return OMPC_otherwise;
        case ROUP_OMPC_match:         return OMPC_match;
        case ROUP_OMPC_task_reduction: return OMPC_task_reduction;
        case ROUP_OMPC_destroy:       return OMPC_destroy;
        case ROUP_OMPC_depobj_update: return OMPC_depobj_update;
        case ROUP_OMPC_compare:       return OMPC_compare;
        case ROUP_OMPC_partial:       return OMPC_partial;
        case ROUP_OMPC_full:          return OMPC_full;
        case ROUP_OMPC_order:         return OMPC_order;
        // Additional clauses for ompparser compatibility (new numbering starting at 133)
        case ROUP_OMPC_threads:       return OMPC_threads;
        case ROUP_OMPC_simd:          return OMPC_simd;
        case ROUP_OMPC_fail:          return OMPC_fail;
        case ROUP_OMPC_weak:          return OMPC_weak;
        case ROUP_OMPC_at:            return OMPC_at;
        case ROUP_OMPC_severity:      return OMPC_severity;
        case ROUP_OMPC_message:       return OMPC_message;
        case ROUP_OMPC_doacross:      return OMPC_doacross;
        case ROUP_OMPC_absent:        return OMPC_absent;
        case ROUP_OMPC_contains:      return OMPC_contains;
        case ROUP_OMPC_holds:         return OMPC_holds;
        case ROUP_OMPC_graph_id:      return OMPC_graph_id;
        case ROUP_OMPC_graph_reset:   return OMPC_graph_reset;
        case ROUP_OMPC_transparent:   return OMPC_transparent;
        case ROUP_OMPC_replayable:    return OMPC_replayable;
        case ROUP_OMPC_threadset:     return OMPC_threadset;
        case ROUP_OMPC_indirect:      return OMPC_indirect;
        case ROUP_OMPC_local:         return OMPC_local;
        case ROUP_OMPC_init:          return OMPC_init;
        case ROUP_OMPC_init_complete: return OMPC_init_complete;
        case ROUP_OMPC_safesync:      return OMPC_safesync;
        case ROUP_OMPC_device_safesync: return OMPC_device_safesync;
        case ROUP_OMPC_memscope:      return OMPC_memscope;
        case ROUP_OMPC_looprange:     return OMPC_looprange;
        case ROUP_OMPC_permutation:   return OMPC_permutation;
        case ROUP_OMPC_counts:        return OMPC_counts;
        case ROUP_OMPC_induction:     return OMPC_induction;
        case ROUP_OMPC_inductor:      return OMPC_inductor;
        case ROUP_OMPC_collector:     return OMPC_collector;
        case ROUP_OMPC_combiner:      return OMPC_combiner;
        case ROUP_OMPC_adjust_args:   return OMPC_adjust_args;
        case ROUP_OMPC_append_args:   return OMPC_append_args;
        case ROUP_OMPC_apply:         return OMPC_apply;
        case ROUP_OMPC_no_openmp:      return OMPC_no_openmp;
        case ROUP_OMPC_no_openmp_constructs: return OMPC_no_openmp_constructs;
        case ROUP_OMPC_no_openmp_routines: return OMPC_no_openmp_routines;
        case ROUP_OMPC_no_parallelism: return OMPC_no_parallelism;
        case ROUP_OMPC_nocontext:     return OMPC_nocontext;
        case ROUP_OMPC_novariants:    return OMPC_novariants;
        case ROUP_OMPC_enter:         return OMPC_enter;
        case ROUP_OMPC_use:           return OMPC_use;
        default:                        return OMPC_unknown;
    }
}

static OpenMPMapClauseType mapRoupMapType(int32_t code) {
    switch (code) {
        case 0:  return OMPC_MAP_TYPE_to;
        case 1:  return OMPC_MAP_TYPE_from;
        case 2:  return OMPC_MAP_TYPE_tofrom;
        case 3:  return OMPC_MAP_TYPE_alloc;
        case 4:  return OMPC_MAP_TYPE_release;
        case 5:  return OMPC_MAP_TYPE_delete;
        default: return OMPC_MAP_TYPE_unspecified;
    }
}

static OpenMPLinearClauseModifier mapRoupLinearModifier(int32_t code) {
    switch (code) {
        case 0:  return OMPC_LINEAR_MODIFIER_val;
        case 1:  return OMPC_LINEAR_MODIFIER_ref;
        case 2:  return OMPC_LINEAR_MODIFIER_uval;
        default: return OMPC_LINEAR_MODIFIER_unspecified;
    }
}

static OpenMPDependClauseType mapRoupDependType(int32_t code) {
    switch (code) {
        case 0: return OMPC_DEPENDENCE_TYPE_in;
        case 1: return OMPC_DEPENDENCE_TYPE_out;
        case 2: return OMPC_DEPENDENCE_TYPE_inout;
        case 3: return OMPC_DEPENDENCE_TYPE_inoutset;
        case 4: return OMPC_DEPENDENCE_TYPE_mutexinoutset;
        case 5: return OMPC_DEPENDENCE_TYPE_depobj;
        case 6: return OMPC_DEPENDENCE_TYPE_source;
        case 7: return OMPC_DEPENDENCE_TYPE_sink;
        default: return OMPC_DEPENDENCE_TYPE_unknown;
    }
}

static std::vector<OpenMPMapClauseModifier> mapRoupMapModifiers(
    uint32_t mask,
    bool include_mapper
) {
    std::vector<OpenMPMapClauseModifier> result;
    if (mask & ROUP_MAP_MODIFIER_ALWAYS) {
        result.push_back(OMPC_MAP_MODIFIER_always);
    }
    if (mask & ROUP_MAP_MODIFIER_CLOSE) {
        result.push_back(OMPC_MAP_MODIFIER_close);
    }
    if (mask & ROUP_MAP_MODIFIER_PRESENT) {
        result.push_back(OMPC_MAP_MODIFIER_present);
    }
    if (mask & ROUP_MAP_MODIFIER_SELF) {
        result.push_back(OMPC_MAP_MODIFIER_self);
    }
    if (mask & ROUP_MAP_MODIFIER_OMPX_HOLD) {
        result.push_back(OMPC_MAP_MODIFIER_unspecified);
    }
    if (include_mapper) {
        result.push_back(OMPC_MAP_MODIFIER_mapper);
    }
    return result;
}

static OpenMPDepobjUpdateClauseDependeceType mapRoupDepobjUpdateType(int32_t code) {
    switch (code) {
        case 0: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_in;
        case 1: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_out;
        case 2: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_inout;
        case 3: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_inoutset;
        case 4: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_mutexinoutset;
        case 5: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_depobj;
        case 6: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_sink;
        case 7: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_source;
        default: return OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_unknown;
    }
}

static OpenMPAllocateClauseAllocator mapRoupAllocateAllocator(int32_t code) {
    switch (code) {
        case ROUPO_USES_ALLOC_DEFAULT: return OMPC_ALLOCATE_ALLOCATOR_default;
        case ROUPO_USES_ALLOC_LARGE_CAP: return OMPC_ALLOCATE_ALLOCATOR_large_cap;
        case ROUPO_USES_ALLOC_CONST: return OMPC_ALLOCATE_ALLOCATOR_cons_mem;
        case ROUPO_USES_ALLOC_HIGH_BW: return OMPC_ALLOCATE_ALLOCATOR_high_bw;
        case ROUPO_USES_ALLOC_LOW_LAT: return OMPC_ALLOCATE_ALLOCATOR_low_lat;
        case ROUPO_USES_ALLOC_CGROUP: return OMPC_ALLOCATE_ALLOCATOR_cgroup;
        case ROUPO_USES_ALLOC_PTEAM: return OMPC_ALLOCATE_ALLOCATOR_pteam;
        case ROUPO_USES_ALLOC_THREAD: return OMPC_ALLOCATE_ALLOCATOR_thread;
        case ROUPO_USES_ALLOC_USER: return OMPC_ALLOCATE_ALLOCATOR_user;
        default: return OMPC_ALLOCATE_ALLOCATOR_unspecified;
    }
}

static OpenMPAllocatorClauseAllocator mapRoupAllocatorAllocator(int32_t code) {
    switch (code) {
        case ROUPO_USES_ALLOC_DEFAULT: return OMPC_ALLOCATOR_ALLOCATOR_default;
        case ROUPO_USES_ALLOC_LARGE_CAP: return OMPC_ALLOCATOR_ALLOCATOR_large_cap;
        case ROUPO_USES_ALLOC_CONST: return OMPC_ALLOCATOR_ALLOCATOR_cons_mem;
        case ROUPO_USES_ALLOC_HIGH_BW: return OMPC_ALLOCATOR_ALLOCATOR_high_bw;
        case ROUPO_USES_ALLOC_LOW_LAT: return OMPC_ALLOCATOR_ALLOCATOR_low_lat;
        case ROUPO_USES_ALLOC_CGROUP: return OMPC_ALLOCATOR_ALLOCATOR_cgroup;
        case ROUPO_USES_ALLOC_PTEAM: return OMPC_ALLOCATOR_ALLOCATOR_pteam;
        case ROUPO_USES_ALLOC_THREAD: return OMPC_ALLOCATOR_ALLOCATOR_thread;
        case ROUPO_USES_ALLOC_USER: return OMPC_ALLOCATOR_ALLOCATOR_user;
        default: return OMPC_ALLOCATOR_ALLOCATOR_unknown;
    }
}

static OpenMPUsesAllocatorsClauseAllocator mapRoupUsesAllocator(int32_t code) {
    switch (code) {
        case ROUPO_USES_ALLOC_DEFAULT: return OMPC_USESALLOCATORS_ALLOCATOR_default;
        case ROUPO_USES_ALLOC_LARGE_CAP: return OMPC_USESALLOCATORS_ALLOCATOR_large_cap;
        case ROUPO_USES_ALLOC_CONST: return OMPC_USESALLOCATORS_ALLOCATOR_cons_mem;
        case ROUPO_USES_ALLOC_HIGH_BW: return OMPC_USESALLOCATORS_ALLOCATOR_high_bw;
        case ROUPO_USES_ALLOC_LOW_LAT: return OMPC_USESALLOCATORS_ALLOCATOR_low_lat;
        case ROUPO_USES_ALLOC_CGROUP: return OMPC_USESALLOCATORS_ALLOCATOR_cgroup;
        case ROUPO_USES_ALLOC_PTEAM: return OMPC_USESALLOCATORS_ALLOCATOR_pteam;
        case ROUPO_USES_ALLOC_THREAD: return OMPC_USESALLOCATORS_ALLOCATOR_thread;
        case ROUPO_USES_ALLOC_USER: return OMPC_USESALLOCATORS_ALLOCATOR_user;
        default: return OMPC_USESALLOCATORS_ALLOCATOR_unspecified;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

extern "C" {

OpenMPDirective* parseOpenMP(const char* input, void* exprParse(const char* expr)) {
    const bool debug_logging = std::getenv("ROUP_DEBUG_COMPAT") != nullptr;
    if (!input || input[0] == '\0') {
        return nullptr;
    }

    // Validate input length using constant from ROUP C API
    // Use strnlen to safely handle potentially untrusted/non-null-terminated input
    const size_t input_len = strnlen(input, ROUP_MAX_PRAGMA_LENGTH);
    if (input_len == ROUP_MAX_PRAGMA_LENGTH) {
        return nullptr;  // Input too long or not null-terminated within limit
    }

    // Determine input format based on current language mode
    std::string input_str(input, input_len);
    if (debug_logging) {
        fprintf(stderr, "[compat] raw input=\"%s\"\n", input_str.c_str());
    }

    // Handle different language pragmas
    if (current_lang == Lang_Fortran) {
        // Fortran uses !$omp prefix - add if missing (case-insensitive check)
        const size_t prefix_pos = find_fortran_prefix_start(input_str);
        if (prefix_pos == std::string::npos) {
            const size_t trimmed_start = input_str.find_first_not_of(" \t");
            const std::string body =
                (trimmed_start == std::string::npos) ? std::string() : input_str.substr(trimmed_start);
            input_str = std::string(FORTRAN_PREFIX) + " " + body;
        } else if (prefix_pos > 0) {
            input_str.erase(0, prefix_pos);
        }
    } else {
        // C/C++ use #pragma omp prefix - add if missing
        const size_t prefix_pos = find_c_prefix_start(input_str);
        if (prefix_pos == std::string::npos) {
            const size_t trimmed_start = input_str.find_first_not_of(" \t");
            std::string body =
                (trimmed_start == std::string::npos) ? std::string() : input_str.substr(trimmed_start);
            if (body.rfind("omp", 0) != 0) {
                body = std::string("omp ") + body;
            }
            input_str = std::string(C_PRAGMA_PREFIX) + " " + body;
        } else if (prefix_pos > 0) {
            input_str.erase(0, prefix_pos);
        }
    }
    if (debug_logging) {
        fprintf(stderr, "[compat] normalized=\"%s\"\n", input_str.c_str());
    }

    // Call ROUP parser with correct language
    int32_t roup_lang = (current_lang == Lang_Fortran) ? ROUP_LANG_FORTRAN_FREE : ROUP_LANG_C;
    std::string parse_input = input_str;
    std::string end_critical_name;
    OmpDirective* roup_dir = roup_parse_with_language(parse_input.c_str(), roup_lang);
    if (debug_logging) {
        fprintf(stderr, "[compat] roup_parse returned %p\n", (void*)roup_dir);
    }
    if (!roup_dir) {
        auto stripped = strip_end_directive_parameter(parse_input);
        if (stripped.first != parse_input) {
            parse_input.swap(stripped.first);
            end_critical_name.swap(stripped.second);
            roup_dir = roup_parse_with_language(parse_input.c_str(), roup_lang);
        }
    }
    if (!roup_dir) {
        if (std::getenv("ROUP_DEBUG_PARSE_FAIL") != nullptr) {
            fprintf(stderr, "ROUP parse failed (lang=%d): \"%s\"\n",
                    roup_lang,
                    parse_input.c_str());
        }
        return nullptr;
    }

    // Convert already-parsed ROUP directive to ompparser AST (no string parsing)
    OpenMPDirective* converted = convert_roup_directive_to_ompparser(roup_dir, exprParse, true, debug_logging);
    if (converted && !end_critical_name.empty() && converted->getKind() == OMPD_end) {
        OpenMPEndDirective* end_dir = static_cast<OpenMPEndDirective*>(converted);
        OpenMPDirective* paired = end_dir->getPairedDirective();
        if (paired && paired->getKind() == OMPD_critical) {
            auto* crit = static_cast<OpenMPCriticalDirective*>(paired);
            crit->setCriticalName(end_critical_name.c_str());
        }
    }
    return converted;
} // end parseOpenMP

} // extern "C"


// ==== Typed clause conversion helpers (no string parsing). NOTE: Unsupported kinds emit warnings. ====
static void warn_unsupported_clause(OpenMPClauseKind ck) {
    fprintf(stderr, "[compat] unsupported clause kind=%d; consider adding typed conversion or ompparser support\n",
            static_cast<int>(ck));
}

static void convert_generic_clause(OpenMPDirective* dir, const OmpClause* /*rc*/, OpenMPClauseKind ck) {
    OpenMPClause* clause = dir->addOpenMPClause(static_cast<int>(ck), "");
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_map_clause(OpenMPDirective* dir, const OmpClause* rc) {
    OpenMPMapClauseType map_type = mapRoupMapType(roup_clause_map_type(rc));
    const uint32_t mod_mask = roup_clause_map_modifier_mask(rc);
    const char* mapper = roup_clause_map_mapper(rc);
    const bool has_mapper = mapper != nullptr && mapper[0] != '\0';

    std::vector<OpenMPMapClauseModifier> mods = mapRoupMapModifiers(mod_mask, has_mapper);
    OpenMPMapClauseModifier m1 = OMPC_MAP_MODIFIER_unspecified;
    OpenMPMapClauseModifier m2 = OMPC_MAP_MODIFIER_unspecified;
    OpenMPMapClauseModifier m3 = OMPC_MAP_MODIFIER_unspecified;
    if (!mods.empty()) m1 = mods[0];
    if (mods.size() > 1) m2 = mods[1];
    if (mods.size() > 2) m3 = mods[2];
    if (mods.size() > 3) {
        warn_unsupported_clause(OMPC_map);
    }

    OpenMPClause* clause =
        OpenMPMapClause::addMapClause(dir, m1, m2, m3, map_type, has_mapper ? mapper : "");

    OmpStringList* vars = roup_clause_variables(rc);
    append_variables_to_clause(clause, vars);
    if (vars) {
        roup_string_list_free(vars);
    }
    if (roup_clause_map_iterator_count(rc) > 0) {
        warn_unsupported_clause(OMPC_map);
    }
    if (map_type == OMPC_MAP_TYPE_unspecified) {
        warn_unsupported_clause(OMPC_map);
    }

    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void handle_dist_schedule_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t kind = roup_clause_dist_schedule_kind(rc);
    const char* chunk = roup_clause_dist_schedule_chunk(rc);
    OpenMPDistScheduleClauseKind ompkind = OMPC_DIST_SCHEDULE_KIND_unknown;
    switch (kind) {
        case 0: ompkind = OMPC_DIST_SCHEDULE_KIND_static; break;
        default: ompkind = OMPC_DIST_SCHEDULE_KIND_unknown; break;
    }
    if (ompkind == OMPC_DIST_SCHEDULE_KIND_unknown) {
        warn_unsupported_clause(OMPC_dist_schedule);
    }
    OpenMPClause* clause = OpenMPDistScheduleClause::addDistScheduleClause(dir, ompkind);
    if (clause && chunk && chunk[0]) {
        static_cast<OpenMPDistScheduleClause*>(clause)->setChunkSize(chunk);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void handle_schedule_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t kind = roup_clause_schedule_kind(rc);
    uint32_t mask = roup_clause_schedule_modifier_mask(rc);
    const char* chunk = roup_clause_schedule_chunk(rc);
    OpenMPScheduleClauseKind ompkind = OMPC_SCHEDULE_KIND_unspecified;
    switch (kind) {
        case 0: ompkind = OMPC_SCHEDULE_KIND_static; break;
        case 1: ompkind = OMPC_SCHEDULE_KIND_dynamic; break;
        case 2: ompkind = OMPC_SCHEDULE_KIND_guided; break;
        case 3: ompkind = OMPC_SCHEDULE_KIND_auto; break;
        case 4: ompkind = OMPC_SCHEDULE_KIND_runtime; break;
        default: ompkind = OMPC_SCHEDULE_KIND_unspecified; break;
    }
    OpenMPScheduleClauseModifier mod1 = OMPC_SCHEDULE_MODIFIER_unspecified;
    OpenMPScheduleClauseModifier mod2 = OMPC_SCHEDULE_MODIFIER_unspecified;
    if (mask & ROUP_SCHEDULE_MODIFIER_MONOTONIC) mod1 = OMPC_SCHEDULE_MODIFIER_monotonic;
    if (mask & ROUP_SCHEDULE_MODIFIER_NONMONOTONIC) mod1 = OMPC_SCHEDULE_MODIFIER_nonmonotonic;
    if (mask & ROUP_SCHEDULE_MODIFIER_SIMD) mod2 = OMPC_SCHEDULE_MODIFIER_simd;
    if ((mask & ROUP_SCHEDULE_MODIFIER_MONOTONIC) && (mask & ROUP_SCHEDULE_MODIFIER_NONMONOTONIC)) {
        warn_unsupported_clause(OMPC_schedule);
    }
    OpenMPClause* clause =
        OpenMPScheduleClause::addScheduleClause(dir, mod1, mod2, ompkind, chunk ? strdup(chunk) : nullptr);
    if (clause && chunk && chunk[0]) {
        static_cast<OpenMPScheduleClause*>(clause)->setChunkSize(chunk);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_clause_with_payload(
    OpenMPDirective* dir,
    const OmpClause* rc,
    OpenMPClauseKind ck,
    std::vector<OpenMPUsesAllocatorsClause*>& uses_allocators_clauses,
    void* exprParse(const char*),
    bool debug_logging) {
    switch (ck) {
        case OMPC_reduction:
        case OMPC_task_reduction:
        case OMPC_in_reduction:
            add_reduction_clause_from_data(dir, rc, ck);
            break;
        case OMPC_detach:
            convert_generic_clause(dir, rc, ck);
            warn_unsupported_clause(ck);
            break;
        case OMPC_depobj_update:
            convert_depobj_update_clause(dir, rc);
            break;
        case OMPC_affinity:
            convert_affinity_clause(dir, rc);
            break;
        case OMPC_linear:
            convert_linear_clause(dir, rc);
            break;
        default:
            warn_unsupported_clause(ck);
            break;
    }
}

static std::vector<std::vector<const char *>*> collect_depend_iterators(const OmpClause* rc) {
    std::vector<std::vector<const char *>*> defs;
    int32_t count = roup_clause_depend_iterator_count(rc);
    for (int32_t i = 0; i < count; ++i) {
        auto* entry = new std::vector<const char*>();
        entry->push_back(duplicate_c_string(roup_clause_depend_iterator_type(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_depend_iterator_name(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_depend_iterator_start(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_depend_iterator_end(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_depend_iterator_step(rc, i)));
        defs.push_back(entry);
    }
    return defs;
}

static std::vector<std::vector<const char *>*> collect_affinity_iterators(const OmpClause* rc) {
    std::vector<std::vector<const char *>*> defs;
    int32_t count = roup_clause_affinity_iterator_count(rc);
    for (int32_t i = 0; i < count; ++i) {
        auto* entry = new std::vector<const char*>();
        entry->push_back(duplicate_c_string(roup_clause_affinity_iterator_type(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_affinity_iterator_name(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_affinity_iterator_start(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_affinity_iterator_end(rc, i)));
        entry->push_back(duplicate_c_string(roup_clause_affinity_iterator_step(rc, i)));
        defs.push_back(entry);
    }
    return defs;
}

static void convert_depend_clause(OpenMPDirective* dir, const OmpClause* rc) {
    OpenMPDependClauseModifier modifier =
        (roup_clause_depend_has_iterators(rc) || roup_clause_depend_iterator_count(rc) > 0)
            ? OMPC_DEPEND_MODIFIER_iterator
            : OMPC_DEPEND_MODIFIER_unspecified;
    OpenMPDependClauseType dep_type = mapRoupDependType(roup_clause_depend_type(rc));

    OpenMPClause* clause = OpenMPDependClause::addDependClause(dir, modifier, dep_type);
    if (!clause) {
        return;
    }

    std::vector<std::vector<const char *>*> iter_defs = collect_depend_iterators(rc);
    if (!iter_defs.empty()) {
        static_cast<OpenMPDependClause*>(clause)->setDependIteratorsDefinitionClass(&iter_defs);
    }

    OmpStringList* vars = roup_clause_variables(rc);
    append_variables_to_clause(clause, vars);
    if (vars) {
        roup_string_list_free(vars);
    }
    if (dep_type == OMPC_DEPENDENCE_TYPE_unknown) {
        warn_unsupported_clause(OMPC_depend);
    }
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_depobj_update_clause(OpenMPDirective* dir, const OmpClause* rc) {
    OpenMPDepobjUpdateClauseDependeceType type = mapRoupDepobjUpdateType(roup_clause_depobj_update_dependence(rc));
    OpenMPClause* clause = OpenMPDepobjUpdateClause::addDepobjUpdateClause(dir, type);
    if (type == OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_unknown) {
        warn_unsupported_clause(OMPC_depobj_update);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_affinity_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t mod_code = roup_clause_affinity_modifier(rc);
    OpenMPAffinityClauseModifier mod = OMPC_AFFINITY_MODIFIER_unspecified;
    if (mod_code == 1) {
        mod = OMPC_AFFINITY_MODIFIER_iterator;
    }
    if (mod_code < 0 || mod_code > 1) {
        warn_unsupported_clause(OMPC_affinity);
    }

    OpenMPClause* clause = OpenMPAffinityClause::addAffinityClause(dir, mod);
    if (!clause) {
        return;
    }

    std::vector<std::vector<const char *>*> iter_defs = collect_affinity_iterators(rc);
    OpenMPAffinityClause* affinity_clause = static_cast<OpenMPAffinityClause*>(clause);
    for (auto* def : iter_defs) {
        affinity_clause->addIteratorsDefinitionClass(def);
    }

    OmpStringList* vars = roup_clause_variables(rc);
    append_variables_to_clause(clause, vars);
    if (vars) {
        roup_string_list_free(vars);
    }
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_linear_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t mod_code = roup_clause_linear_modifier(rc);
    OpenMPLinearClauseModifier mod = mapRoupLinearModifier(mod_code);
    if (mod == OMPC_LINEAR_MODIFIER_unspecified && (mod_code < 0 || mod_code > 2)) {
        warn_unsupported_clause(OMPC_linear);
    }
    OpenMPClause* clause = OpenMPLinearClause::addLinearClause(dir, mod);
    if (!clause) {
        return;
    }
    const char* step = roup_clause_linear_step(rc);
    if (step && step[0]) {
        static_cast<OpenMPLinearClause*>(clause)->setUserDefinedStep(step);
    }
    // Modifier means modifier-first syntax (val/ref/uval(variable):step)
    if (mod != OMPC_LINEAR_MODIFIER_unspecified) {
        static_cast<OpenMPLinearClause*>(clause)->setModifierFirstSyntax(true);
    }

    OmpStringList* vars = roup_clause_variables(rc);
    append_variables_to_clause(clause, vars);
    if (vars) {
        roup_string_list_free(vars);
    }
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_aligned_clause(OpenMPDirective* dir, const OmpClause* rc, OpenMPClauseKind clause_kind) {
    const char* alignment = roup_clause_aligned_alignment(rc);
    OpenMPClause* clause = nullptr;
    if (clause_kind == OMPC_align) {
        clause = dir->addOpenMPClause(OMPC_align, "");
        const char* expr = (alignment && alignment[0]) ? alignment : roup_clause_arguments(rc);
        if (clause && expr && expr[0]) {
            clause->addLangExpr(strdup(expr));
        }
    } else {
        clause = OpenMPAlignedClause::addAlignedClause(dir);
        if (clause && alignment && alignment[0]) {
            static_cast<OpenMPAlignedClause*>(clause)->setUserDefinedAlignment(alignment);
        }
        OmpStringList* vars = roup_clause_variables(rc);
        append_variables_to_clause(clause, vars);
        if (vars) {
            roup_string_list_free(vars);
        }
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_ordered_clause(OpenMPDirective* dir, const OmpClause* rc) {
    const char* expr = roup_clause_arguments(rc);
    OpenMPClause* clause = dir->addOpenMPClause(OMPC_ordered, "");
    if (clause && expr && expr[0]) {
        clause->addLangExpr(strdup(expr));
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_allocate_clause(OpenMPDirective* dir, const OmpClause* rc) {
    const char* allocator = roup_clause_allocate_allocator(rc);
    const int32_t kind_code = roup_clause_allocate_kind(rc);
    OpenMPAllocateClauseAllocator alloc_kind = mapRoupAllocateAllocator(kind_code);
    OpenMPClause* clause = OpenMPAllocateClause::addAllocateClause(
        dir, alloc_kind, duplicate_c_string(allocator));
    if (alloc_kind == OMPC_ALLOCATE_ALLOCATOR_unspecified) {
        warn_unsupported_clause(OMPC_allocate);
    }
    if (!clause) {
        return;
    }

    OmpStringList* vars = roup_clause_variables(rc);
    if (vars && clause->getClausePosition() == -1) {
        // For allocate, keep original spacing from ROUP list (no extra parens)
        int length = roup_string_list_len(vars);
        for (int i = 0; i < length; ++i) {
            const char* item = roup_string_list_get(vars, i);
            if (item) {
                clause->addLangExpr(strdup(normalize_expression(item).c_str()));
            }
        }
    } else {
        append_variables_to_clause(clause, vars);
    }
    if (vars) roup_string_list_free(vars);
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_order_clause(OpenMPDirective* dir, const OmpClause* rc) {
    OpenMPOrderClauseModifier mod = OMPC_ORDER_MODIFIER_unspecified;
    OpenMPOrderClauseKind kind = OMPC_ORDER_unspecified;
    int32_t m = roup_clause_order_modifier(rc);
    if (m == 0) mod = OMPC_ORDER_MODIFIER_reproducible;
    else if (m == 1) mod = OMPC_ORDER_MODIFIER_unconstrained;
    int32_t k = roup_clause_order_kind(rc);
    if (k == 0) {
        kind = OMPC_ORDER_concurrent;
    }
    OpenMPClause* clause = OpenMPOrderClause::addOrderClause(dir, mod, kind);
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_variables_clause(OpenMPDirective* dir, const OmpClause* rc, OpenMPClauseKind ck) {
    OpenMPClause* clause = dir->addOpenMPClause(static_cast<int>(ck), "");
    OmpStringList* vars = roup_clause_variables(rc);
    append_variables_to_clause(clause, vars);
    if (vars) {
        roup_string_list_free(vars);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_num_threads_clause(OpenMPDirective* dir, const OmpClause* rc) {
    const char* expr = roup_clause_arguments(rc);
    OpenMPClause* clause = dir->addOpenMPClause(OMPC_num_threads, "");
    if (clause && expr && expr[0]) {
        clause->addLangExpr(strdup(expr));
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_collapse_clause(OpenMPDirective* dir, const OmpClause* rc) {
    const char* expr = roup_clause_arguments(rc);
    OpenMPClause* clause = dir->addOpenMPClause(OMPC_collapse, "");
    if (clause && expr && expr[0]) {
        clause->addLangExpr(strdup(expr));
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_if_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t mod_code = roup_clause_if_modifier(rc);
    OpenMPIfClauseModifier mod = OMPC_IF_MODIFIER_unspecified;
    switch (mod_code) {
        case ROUPO_IF_MODIFIER_PARALLEL: mod = OMPC_IF_MODIFIER_parallel; break;
        case ROUPO_IF_MODIFIER_TASK: mod = OMPC_IF_MODIFIER_task; break;
        case ROUPO_IF_MODIFIER_TASKLOOP: mod = OMPC_IF_MODIFIER_taskloop; break;
        case ROUPO_IF_MODIFIER_TARGET: mod = OMPC_IF_MODIFIER_target; break;
        case ROUPO_IF_MODIFIER_TARGET_DATA: mod = OMPC_IF_MODIFIER_target_data; break;
        case ROUPO_IF_MODIFIER_TARGET_ENTER_DATA: mod = OMPC_IF_MODIFIER_target_enter_data; break;
        case ROUPO_IF_MODIFIER_TARGET_EXIT_DATA: mod = OMPC_IF_MODIFIER_target_exit_data; break;
        case ROUPO_IF_MODIFIER_TARGET_UPDATE: mod = OMPC_IF_MODIFIER_target_update; break;
        case ROUPO_IF_MODIFIER_SIMD: mod = OMPC_IF_MODIFIER_simd; break;
        case ROUPO_IF_MODIFIER_CANCEL: mod = OMPC_IF_MODIFIER_cancel; break;
        default: mod = OMPC_IF_MODIFIER_unspecified; break;
    }
    const char* expr = roup_clause_if_expression(rc);
    if (std::getenv("ROUP_DEBUG_COMPAT") != nullptr) {
        fprintf(stderr, "[compat] if clause expr=\"%s\"\n", expr ? expr : "(null)");
    }
    char* user_mod = nullptr;
    if (mod == OMPC_IF_MODIFIER_user && expr && expr[0]) {
        user_mod = duplicate_c_string(expr);
    }
    OpenMPClause* clause = OpenMPIfClause::addIfClause(dir, mod, user_mod);
    if (clause && expr && expr[0]) {
        clause->addLangExpr(strdup(expr));
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_proc_bind_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t policy = roup_clause_proc_bind_policy(rc);
    OpenMPProcBindClauseKind kind = OMPC_PROC_BIND_unknown;
    switch (policy) {
        case 0: kind = OMPC_PROC_BIND_master; break;
        case 1: kind = OMPC_PROC_BIND_close; break;
        case 2: kind = OMPC_PROC_BIND_spread; break;
        case 3: kind = OMPC_PROC_BIND_primary; break;
        default: kind = OMPC_PROC_BIND_unknown; break;
    }
    OpenMPClause* clause = OpenMPProcBindClause::addProcBindClause(dir, kind);
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_bind_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t code = roup_clause_bind_modifier(rc);
    OpenMPBindClauseBinding binding = OMPC_BIND_unspecified;
    switch (code) {
        case 0: binding = OMPC_BIND_teams; break;
        case 1: binding = OMPC_BIND_parallel; break;
        case 2: binding = OMPC_BIND_thread; break;
        case 3: binding = OMPC_BIND_user; break;
        default: binding = OMPC_BIND_unspecified; break;
    }
    OpenMPClause* clause = OpenMPBindClause::addBindClause(dir, binding);
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_atomic_default_mem_order_clause(OpenMPDirective* dir, const OmpClause* rc) {
    OpenMPAtomicDefaultMemOrderClauseKind kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown;
    bool unsupported = false;
    int32_t v = roup_clause_atomic_default_mem_order(rc);
    switch (v) {
        case 0: kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_seq_cst; break;
        case 1: kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_acq_rel; break;
        case 4: kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_relaxed; break;
        case 2:
        case 3:
            unsupported = true;
            kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown;
            break;
        default:
            break;
    }
    OpenMPClause* clause = OpenMPAtomicDefaultMemOrderClause::addAtomicDefaultMemOrderClause(dir, kind);
    if (unsupported) {
        warn_unsupported_clause(OMPC_atomic_default_mem_order);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_size_expr_clause(OpenMPDirective* dir, const OmpClause* rc, OpenMPClauseKind ck) {
    const char* expr = (ck == OMPC_grainsize) ? roup_clause_grainsize_expr(rc) : roup_clause_num_tasks_expr(rc);
    int32_t mod_code = (ck == OMPC_grainsize) ? roup_clause_grainsize_modifier(rc) : roup_clause_num_tasks_modifier(rc);
    OpenMPGrainsizeClauseModifier gmod = OMPC_GRAINSIZE_MODIFIER_unspecified;
    OpenMPNumTasksClauseModifier nmod = OMPC_NUM_TASKS_MODIFIER_unspecified;
    if (ck == OMPC_grainsize && mod_code == 1) gmod = OMPC_GRAINSIZE_MODIFIER_strict;
    if (ck == OMPC_num_tasks && mod_code == 1) nmod = OMPC_NUM_TASKS_MODIFIER_strict;
    OpenMPClause* clause = nullptr;
    if (ck == OMPC_grainsize) {
        clause = dir->addOpenMPClause(OMPC_grainsize, gmod);
    } else {
        clause = dir->addOpenMPClause(OMPC_num_tasks, nmod);
    }
    if (clause && expr && expr[0]) clause->addLangExpr(strdup(expr));
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_defaultmap_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t behavior = roup_clause_defaultmap_behavior(rc);
    int32_t category = roup_clause_defaultmap_category(rc);
    OpenMPDefaultmapClauseBehavior beh = OMPC_DEFAULTMAP_BEHAVIOR_unspecified;
    OpenMPDefaultmapClauseCategory cat = OMPC_DEFAULTMAP_CATEGORY_unspecified;
    bool warn = false;
    switch (behavior) {
        case 0: beh = OMPC_DEFAULTMAP_BEHAVIOR_unspecified; break;
        case 1: beh = OMPC_DEFAULTMAP_BEHAVIOR_alloc; break;
        case 2: beh = OMPC_DEFAULTMAP_BEHAVIOR_to; break;
        case 3: beh = OMPC_DEFAULTMAP_BEHAVIOR_from; break;
        case 4: beh = OMPC_DEFAULTMAP_BEHAVIOR_tofrom; break;
        case 5: beh = OMPC_DEFAULTMAP_BEHAVIOR_firstprivate; break;
        case 6: beh = OMPC_DEFAULTMAP_BEHAVIOR_none; break;
        case 7: beh = OMPC_DEFAULTMAP_BEHAVIOR_default; break;
        case 8: beh = OMPC_DEFAULTMAP_BEHAVIOR_present; break;
        default: warn = true; break;
    }
    switch (category) {
        case 0: cat = OMPC_DEFAULTMAP_CATEGORY_unspecified; break;
        case 1: cat = OMPC_DEFAULTMAP_CATEGORY_scalar; break;
        case 2: cat = OMPC_DEFAULTMAP_CATEGORY_aggregate; break;
        case 3: cat = OMPC_DEFAULTMAP_CATEGORY_pointer; break;
        case 4: cat = OMPC_DEFAULTMAP_CATEGORY_all; break;
        case 5: cat = OMPC_DEFAULTMAP_CATEGORY_allocatable; break;
        default: warn = true; break;
    }
    OpenMPClause* clause = OpenMPDefaultmapClause::addDefaultmapClause(dir, beh, cat);
    if (warn) {
        warn_unsupported_clause(OMPC_defaultmap);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_uses_allocators_clause(OpenMPDirective* dir, const OmpClause* rc, std::vector<OpenMPUsesAllocatorsClause*>& uses_allocators_clauses) {
    int32_t count = roup_clause_uses_allocators_count(rc);
    OpenMPUsesAllocatorsClause* clause =
        static_cast<OpenMPUsesAllocatorsClause*>(OpenMPUsesAllocatorsClause::addUsesAllocatorsClause(dir));
    if (!clause) {
        return;
    }
    for (int32_t i = 0; i < count; ++i) {
        int32_t kind = roup_clause_uses_allocator_kind(rc, i);
        const char* user = roup_clause_uses_allocator_user(rc, i);
        const char* traits = roup_clause_uses_allocator_traits(rc, i);
        OpenMPUsesAllocatorsClauseAllocator allocator = mapRoupUsesAllocator(kind);
        clause->addUsesAllocatorsAllocatorSequence(allocator, traits ? traits : "", user ? user : "");
        if (allocator == OMPC_USESALLOCATORS_ALLOCATOR_unspecified ||
            allocator == OMPC_USESALLOCATORS_ALLOCATOR_unknown) {
            warn_unsupported_clause(OMPC_uses_allocators);
        }
    }
    uses_allocators_clauses.push_back(clause);
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_device_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t mod_code = roup_clause_device_modifier(rc);
    OpenMPDeviceClauseModifier mod = OMPC_DEVICE_MODIFIER_unspecified;
    if (mod_code == 0) mod = OMPC_DEVICE_MODIFIER_ancestor;
    else if (mod_code == 1) mod = OMPC_DEVICE_MODIFIER_device_num;
    else if (mod_code != 2) warn_unsupported_clause(OMPC_device);
    OpenMPClause* clause = OpenMPDeviceClause::addDeviceClause(dir, mod);
    if (!clause) {
        return;
    }
    const char* expr = roup_clause_device_expression(rc);
    if (expr && expr[0]) clause->addLangExpr(strdup(expr));
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_lastprivate_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t mod = roup_clause_lastprivate_modifier(rc);
    OpenMPLastprivateClauseModifier omod = OMPC_LASTPRIVATE_MODIFIER_unspecified;
    if (mod == 1) omod = OMPC_LASTPRIVATE_MODIFIER_conditional;
    OpenMPClause* clause = OpenMPLastprivateClause::addLastprivateClause(dir, omod);
    OmpStringList* vars = roup_clause_variables(rc);
    append_variables_to_clause(clause, vars);
    if (vars) roup_string_list_free(vars);
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_allocator_like_clause(OpenMPDirective* dir, const OmpClause* rc, OpenMPClauseKind ck) {
    const int32_t kind_code = roup_clause_allocator_kind(rc);
    const char* user_alloc = roup_clause_arguments(rc);
    OpenMPAllocatorClauseAllocator allocator = mapRoupAllocatorAllocator(kind_code);
    OpenMPClause* clause =
        OpenMPAllocatorClause::addAllocatorClause(dir, allocator, duplicate_c_string(user_alloc));
    if (allocator == OMPC_ALLOCATOR_ALLOCATOR_unknown) {
        warn_unsupported_clause(ck);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_default_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t sharing = roup_clause_default_data_sharing(rc);
    OpenMPDefaultClauseKind kind = OMPC_DEFAULT_unknown;
    switch (sharing) {
        case 0: kind = OMPC_DEFAULT_shared; break;
        case 1: kind = OMPC_DEFAULT_none; break;
        case 2: kind = OMPC_DEFAULT_private; break;
        case 3: kind = OMPC_DEFAULT_firstprivate; break;
        case 4: kind = OMPC_DEFAULT_variant; break;
        default: kind = OMPC_DEFAULT_unknown; break;
    }
    OpenMPClause* clause = OpenMPDefaultClause::addDefaultClause(dir, kind);
    if (kind == OMPC_DEFAULT_unknown) {
        warn_unsupported_clause(OMPC_default);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_device_type_clause(OpenMPDirective* dir, const OmpClause* rc) {
    int32_t kind = roup_clause_device_type_kind(rc);
    OpenMPDeviceTypeClauseKind ompkind = OMPC_DEVICE_TYPE_unknown;
    if (kind == 0) ompkind = OMPC_DEVICE_TYPE_host;
    else if (kind == 1) ompkind = OMPC_DEVICE_TYPE_nohost;
    else if (kind == 2) ompkind = OMPC_DEVICE_TYPE_any;
    OpenMPClause* clause = OpenMPDeviceTypeClause::addDeviceTypeClause(dir, ompkind);
    if (ompkind == OMPC_DEVICE_TYPE_unknown) {
        warn_unsupported_clause(OMPC_device_type);
    }
    if (clause && clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_atomic_ordered_clause(OpenMPDirective* dir, const OmpClause* rc) {
    (void)rc;
    convert_generic_clause(dir, rc, OMPC_ordered);
}

static void convert_atomic_clause(OpenMPDirective* dir, const OmpClause* rc, OpenMPClauseKind ck) {
    OpenMPClause* clause = dir->addOpenMPClause(static_cast<int>(ck), "");
    if (!clause) {
        return;
    }
    if (ck == OMPC_hint) {
        const char* expr = roup_clause_arguments(rc);
        if (expr && expr[0]) {
            clause->addLangExpr(strdup(expr));
        }
    }
    if (clause->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause);
        clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}

static void convert_allocators_clause(OpenMPDirective* dir, const OmpClause* rc) {
    convert_generic_clause(dir, rc, OMPC_allocate);
}
