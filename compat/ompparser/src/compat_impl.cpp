/*
 * OpenMPIR.cpp - Minimal ompparser compatibility implementation using ROUP
 *
 * This provides ONLY the implementation (.cpp), using ompparser's headers
 * from the git submodule at compat/ompparser/ompparser/src/
 *
 * Copyright (c) 2025 ROUP Project
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <OpenMPIR.h>
#include <cstdlib>
#include <cstring>
#include <cstdint>
#include <sstream>
#include <string>
#include <vector>

// Include ROUP constants (auto-generated by build.rs from src/c_api.rs)
#include <roup_constants.h>

// Forward declarations for new requires helpers in the ROUP C API
extern "C" int32_t roup_clause_requires_count(const OmpClause* clause);
extern "C" int32_t roup_clause_requires_modifier(const OmpClause* clause, int32_t index);
extern "C" const char* roup_requires_modifier_name(int32_t code);

static constexpr uint32_t ROUP_REDUCTION_MODIFIER_TASK = 1u << 0;
static constexpr uint32_t ROUP_REDUCTION_MODIFIER_INSCAN = 1u << 1;
static constexpr uint32_t ROUP_REDUCTION_MODIFIER_DEFAULT = 1u << 2;

// Uses-allocators codes returned by ROUP C API (mirror src/c_api.rs ordering)
enum RoupUsesAllocatorsKind {
    ROUPO_USES_ALLOC_DEFAULT = 0,
    ROUPO_USES_ALLOC_LARGE_CAP = 1,
    ROUPO_USES_ALLOC_CONST = 2,
    ROUPO_USES_ALLOC_HIGH_BW = 3,
    ROUPO_USES_ALLOC_LOW_LAT = 4,
    ROUPO_USES_ALLOC_CGROUP = 5,
    ROUPO_USES_ALLOC_PTEAM = 6,
    ROUPO_USES_ALLOC_THREAD = 7,
    ROUPO_USES_ALLOC_USER = 8,
};

// ============================================================================
// ROUP C API Forward Declarations
// ============================================================================

extern "C" {
    // Opaque types from ROUP
    struct OmpDirective;
    struct OmpClause;
    struct OmpClauseIterator;
    struct OmpStringList;

    // Core parsing
    OmpDirective* roup_parse(const char* input);
    OmpDirective* roup_parse_with_language(const char* input, int32_t language);
    void roup_directive_free(OmpDirective* directive);

    // Directive queries
    int32_t roup_directive_kind(const OmpDirective* directive);
    int32_t roup_directive_clause_count(const OmpDirective* directive);
    OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);
    const char* roup_directive_name(const OmpDirective* directive);
    const char* roup_directive_parameter(const OmpDirective* directive);

    // Iterator operations (updated API with out parameter)
    int32_t roup_clause_iterator_next(OmpClauseIterator* iter, const OmpClause** out);
    void roup_clause_iterator_free(OmpClauseIterator* iter);

    // Clause queries
    int32_t roup_clause_kind(const OmpClause* clause);
    const char* roup_clause_arguments(const OmpClause* clause);
    int32_t roup_clause_reduction_operator(const OmpClause* clause);
    uint32_t roup_clause_reduction_modifier_mask(const OmpClause* clause);
    const char* roup_clause_reduction_user_identifier(const OmpClause* clause);
    const char* roup_clause_reduction_modifiers_text(const OmpClause* clause);
    int32_t roup_clause_reduction_space_after_colon(const OmpClause* clause);
    OmpStringList* roup_clause_variables(const OmpClause* clause);
    int32_t roup_string_list_len(const OmpStringList* list);
    const char* roup_string_list_get(const OmpStringList* list, int32_t index);
    void roup_string_list_free(OmpStringList* list);

    int32_t roup_clause_defaultmap_behavior(const OmpClause* clause);
    int32_t roup_clause_defaultmap_category(const OmpClause* clause);
    int32_t roup_clause_uses_allocators_count(const OmpClause* clause);
    int32_t roup_clause_uses_allocator_kind(const OmpClause* clause, int32_t index);
    const char* roup_clause_uses_allocator_user(const OmpClause* clause, int32_t index);
    const char* roup_clause_uses_allocator_traits(const OmpClause* clause, int32_t index);
}

// Helper function to extract string after directive name for clause data
static std::string extract_clause_text(const std::string& full_input, const char* directive_name) {
    // Find where the directive name ends
    std::string needle = std::string(directive_name);
    size_t pos = full_input.find(needle);
    if (pos == std::string::npos) {
        return "";
    }

    // Skip past the directive name and any whitespace
    pos += needle.length();
    while (pos < full_input.length() && std::isspace(full_input[pos])) {
        pos++;
    }

    return full_input.substr(pos);
}

// Forward declaration for format_iterator
static std::string format_iterator(const char* expr);

// Helper function to format mapper expressions for ompparser compatibility
// Expected format: "mapper(name) : items" with space before the colon
static std::string format_mapper(const char* expr) {
    if (expr == nullptr || expr[0] == '\0') {
        return "";
    }

    std::string input(expr);
    std::string result;

    // Check if this contains "mapper("
    size_t mapper_pos = input.find("mapper(");
    if (mapper_pos == std::string::npos) {
        // Not a mapper expression, return as-is
        return input;
    }

    // Find the matching closing parenthesis for mapper
    size_t i = mapper_pos + 7;  // after "mapper("
    int paren_depth = 1;
    while (i < input.length() && paren_depth > 0) {
        if (input[i] == '(') {
            paren_depth++;
        } else if (input[i] == ')') {
            paren_depth--;
        }
        i++;
    }

    // Now i is after the closing ')'
    // Check if there's a colon immediately after (with optional spaces)
    while (i < input.length() && input[i] == ' ') {
        i++;
    }

    if (i < input.length() && input[i] == ':') {
        // Insert space before the colon
        result = input.substr(0, i) + " : " + input.substr(i + 1);
        // Skip any spaces after the colon in the original
        size_t j = i + 1;
        while (j < input.length() && input[j] == ' ') {
            j++;
        }
        if (j > i + 1) {
            // Remove extra spaces
            result = input.substr(0, i) + " : " + input.substr(j);
        }
    } else {
        // No colon after mapper, return as-is
        result = input;
    }

    return result;
}

// Helper function to add spaces after commas and colons for ompparser formatting
// ompparser expects: "a, b, c" not "a,b,c" and "modifier: value" not "modifier:value"
static std::string format_clause_args(const char* args, bool space_after_colon = true) {
    if (args == nullptr || args[0] == '\0') {
        return "";
    }

    // First, handle iterator expressions if present
    std::string input = format_iterator(args);
    // Then handle mapper expressions
    input = format_mapper(input.c_str());

    std::string result;
    int paren_depth = 0;

    for (size_t i = 0; i < input.length(); ++i) {
        char c = input[i];

        if (c == '(') {
            paren_depth++;
            result += c;
        } else if (c == ')') {
            paren_depth--;
            result += c;
        } else if (c == ',' && paren_depth == 0) {
            result += ", ";  // Add space after comma
            // Skip any existing spaces
            while (i + 1 < input.length() && input[i + 1] == ' ') {
                i++;
            }
        } else if (c == ':' && space_after_colon && paren_depth == 0) {
            result += ": ";  // Add space after colon
            // Skip any existing spaces
            while (i + 1 < input.length() && input[i + 1] == ' ') {
                i++;
            }
        } else {
            result += c;
        }
    }

    return result;
}

// Helper function to normalize expression formatting for ompparser compatibility
// Removes spaces after commas INSIDE parentheses: "foo(x, y)" -> "foo(x,y)"
// But preserves spaces at top level (handled elsewhere)
static std::string normalize_expression(const char* expr) {
    if (expr == nullptr || expr[0] == '\0') {
        return "";
    }

    std::string result;
    std::string input(expr);
    int paren_depth = 0;
    bool skip_next_space = false;

    for (size_t i = 0; i < input.length(); ++i) {
        char c = input[i];

        if (c == '(') {
            paren_depth++;
            result += c;
            skip_next_space = false;
        } else if (c == ')') {
            paren_depth--;
            result += c;
            skip_next_space = false;
        } else if (c == ',' && paren_depth > 0) {
            // Inside parentheses - add comma without space
            result += c;
            skip_next_space = true;  // Skip the next space if present
        } else if (c == ' ' && skip_next_space) {
            // Skip this space (after comma inside parentheses)
            skip_next_space = false;
        } else {
            result += c;
            skip_next_space = false;
        }
    }

    return result;
}

// Helper function to format iterator expressions for ompparser compatibility
// Expected format: "iterator ( type var=start:end:step, ... ) : items"
// - Space after "iterator("
// - NO spaces around colons in range specs (start:end:step)
// - Spaces after commas between iterator definitions
// - Space before ")" and space after ") :"
static std::string format_iterator(const char* expr) {
    if (expr == nullptr || expr[0] == '\0') {
        return "";
    }

    std::string input(expr);

    // Check if this contains "iterator("
    size_t iter_pos = input.find("iterator(");
    // Also check for already-formatted "iterator ( "
    size_t iter_formatted_pos = input.find("iterator ( ");

    if (iter_pos == std::string::npos && iter_formatted_pos == std::string::npos) {
        // Not an iterator expression, return as-is
        return input;
    }

    // Use the first occurrence
    if (iter_pos == std::string::npos) {
        iter_pos = iter_formatted_pos;
    } else if (iter_formatted_pos != std::string::npos && iter_formatted_pos < iter_pos) {
        iter_pos = iter_formatted_pos;
    }

    // Build result string carefully
    std::string result;
    result = input.substr(0, iter_pos);
    result += "iterator ( ";  // Standardize to "iterator ( "

    // Skip past "iterator(" or "iterator ( " and any spaces
    size_t i = iter_pos;
    if (input.substr(i, 11) == "iterator ( ") {
        i += 11;
    } else if (input.substr(i, 9) == "iterator(") {
        i += 9;
    }
    while (i < input.length() && input[i] == ' ') {
        i++;
    }

    // Find the matching closing paren for iterator(...)
    int paren_depth = 1;
    size_t iter_content_start = i;
    size_t iter_content_end = i;

    while (i < input.length() && paren_depth > 0) {
        if (input[i] == '(') {
            paren_depth++;
        } else if (input[i] == ')') {
            paren_depth--;
            if (paren_depth == 0) {
                iter_content_end = i;
                break;
            }
        }
        i++;
    }

    // Now process the content between the parentheses
    std::string iter_content = input.substr(iter_content_start, iter_content_end - iter_content_start);

    // Process iterator content to format it correctly:
    // - Remove spaces around colons in range specs (var=start:end:step)
    // - Ensure space after commas between variables
    // - Preserve spaces in type names and identifiers
    std::string formatted_content;
    bool in_range_spec = false;

    for (size_t j = 0; j < iter_content.length(); j++) {
        char c = iter_content[j];

        if (c == '=') {
            // Start of range spec
            formatted_content += c;
            in_range_spec = true;
            // Skip any spaces after =
            while (j + 1 < iter_content.length() && iter_content[j + 1] == ' ') {
                j++;
            }
        } else if (c == ':' && in_range_spec) {
            // Colon in range spec - remove surrounding spaces
            while (!formatted_content.empty() && formatted_content.back() == ' ') {
                formatted_content.pop_back();
            }
            formatted_content += ':';
            // Skip spaces after colon
            while (j + 1 < iter_content.length() && iter_content[j + 1] == ' ') {
                j++;
            }
        } else if (c == ',') {
            // Comma between iterator variables
            // Remove trailing spaces before comma
            while (!formatted_content.empty() && formatted_content.back() == ' ') {
                formatted_content.pop_back();
            }
            formatted_content += ", ";
            in_range_spec = false;
            // Skip spaces after comma
            while (j + 1 < iter_content.length() && iter_content[j + 1] == ' ') {
                j++;
            }
        } else if (c == ' ' && in_range_spec) {
            // Skip all spaces within range specs
            continue;
        } else {
            formatted_content += c;
        }
    }

    // Remove trailing spaces
    while (!formatted_content.empty() && formatted_content.back() == ' ') {
        formatted_content.pop_back();
    }

    // Build the final result
    result += formatted_content;
    result += " )";  // Space before closing paren

    // Skip the closing paren in input and handle what comes after
    i = iter_content_end + 1;

    // Skip spaces
    while (i < input.length() && input[i] == ' ') {
        i++;
    }

    // Check for " : items" pattern
    if (i < input.length() && input[i] == ':') {
        result += " : ";
        i++;
        // Skip spaces after colon
        while (i < input.length() && input[i] == ' ') {
            i++;
        }
    }

    // Append the rest
    result += input.substr(i);

    return result;
}

// Helper function to split comma-separated list and add each item to clause
// This is critical for ompparser compatibility - it expects individual items
static void add_list_expressions(OpenMPClause* clause, const char* args) {
    if (clause == nullptr || args == nullptr || args[0] == '\0') {
        return;
    }

    // Args should already be formatted by format_clause_args before calling this function
    // DO NOT call format_iterator again here to avoid double-formatting
    std::string args_str(args);
    std::stringstream ss(args_str);
    std::string item;

    // Handle nested parentheses for complex arguments like linear(val(a,b,c):2)
    int paren_depth = 0;
    std::string current_item;

    for (size_t i = 0; i < args_str.length(); ++i) {
        char c = args_str[i];

        if (c == '(') {
            paren_depth++;
            current_item += c;
        } else if (c == ')') {
            paren_depth--;
            current_item += c;
        } else if (c == ',' && paren_depth == 0) {
            // Found a separator at top level
            // Trim whitespace
            size_t start = current_item.find_first_not_of(" \t\n\r\f\v");
            size_t end = current_item.find_last_not_of(" \t\n\r\f\v");

            if (start != std::string::npos && end != std::string::npos) {
                std::string trimmed = current_item.substr(start, end - start + 1);
                if (!trimmed.empty()) {
                    // Normalize expression: remove spaces inside function calls
                    std::string normalized = normalize_expression(trimmed.c_str());
                    clause->addLangExpr(strdup(normalized.c_str()));
                }
            }
            current_item.clear();
        } else {
            current_item += c;
        }
    }

    // Add the last item
    size_t start = current_item.find_first_not_of(" \t\n\r\f\v");
    size_t end = current_item.find_last_not_of(" \t\n\r\f\v");

    if (start != std::string::npos && end != std::string::npos) {
        std::string trimmed = current_item.substr(start, end - start + 1);
        if (!trimmed.empty()) {
            // Normalize expression: remove spaces inside function calls
            std::string normalized = normalize_expression(trimmed.c_str());
            clause->addLangExpr(strdup(normalized.c_str()));
        }
    }
}

static char* duplicate_c_string(const char* input) {
    if (input == nullptr) {
        return nullptr;
    }
    return strdup(input);
}

static std::string join_variables_from_list(OmpStringList* list) {
    if (!list) {
        return {};
    }
    int length = roup_string_list_len(list);
    std::string result;
    for (int i = 0; i < length; ++i) {
        const char* item = roup_string_list_get(list, i);
        if (!item) {
            continue;
        }
        if (!result.empty()) {
            result += ", ";
        }
        result += item;
    }
    return result;
}

static OpenMPReductionClauseIdentifier map_reduction_identifier(int32_t code) {
    switch (code) {
        case 0: return OMPC_REDUCTION_IDENTIFIER_plus;
        case 1: return OMPC_REDUCTION_IDENTIFIER_minus;
        case 2: return OMPC_REDUCTION_IDENTIFIER_mul;
        case 3: return OMPC_REDUCTION_IDENTIFIER_bitand;
        case 4: return OMPC_REDUCTION_IDENTIFIER_bitor;
        case 5: return OMPC_REDUCTION_IDENTIFIER_bitxor;
        case 6: return OMPC_REDUCTION_IDENTIFIER_logand;
        case 7: return OMPC_REDUCTION_IDENTIFIER_logor;
        case 8: return OMPC_REDUCTION_IDENTIFIER_min;
        case 9: return OMPC_REDUCTION_IDENTIFIER_max;
        case 10: return OMPC_REDUCTION_IDENTIFIER_eqv;
        case 11: return OMPC_REDUCTION_IDENTIFIER_neqv;
        case 12: return OMPC_REDUCTION_IDENTIFIER_bitand;
        case 13: return OMPC_REDUCTION_IDENTIFIER_bitor;
        case 14: return OMPC_REDUCTION_IDENTIFIER_bitxor;
        case -1: return OMPC_REDUCTION_IDENTIFIER_user;
        default: return OMPC_REDUCTION_IDENTIFIER_unknown;
    }
}

static OpenMPInReductionClauseIdentifier map_in_reduction_identifier(int32_t code) {
    switch (code) {
        case 0: return OMPC_IN_REDUCTION_IDENTIFIER_plus;
        case 1: return OMPC_IN_REDUCTION_IDENTIFIER_minus;
        case 2: return OMPC_IN_REDUCTION_IDENTIFIER_mul;
        case 3: return OMPC_IN_REDUCTION_IDENTIFIER_bitand;
        case 4: return OMPC_IN_REDUCTION_IDENTIFIER_bitor;
        case 5: return OMPC_IN_REDUCTION_IDENTIFIER_bitxor;
        case 6: return OMPC_IN_REDUCTION_IDENTIFIER_logand;
        case 7: return OMPC_IN_REDUCTION_IDENTIFIER_logor;
        case 8: return OMPC_IN_REDUCTION_IDENTIFIER_min;
        case 9: return OMPC_IN_REDUCTION_IDENTIFIER_max;
        case 10: return OMPC_IN_REDUCTION_IDENTIFIER_eqv;
        case 11: return OMPC_IN_REDUCTION_IDENTIFIER_neqv;
        case -1: return OMPC_IN_REDUCTION_IDENTIFIER_user;
        default: return OMPC_IN_REDUCTION_IDENTIFIER_unknown;
    }
}

static OpenMPTaskReductionClauseIdentifier map_task_reduction_identifier(int32_t code) {
    switch (code) {
        case 0: return OMPC_TASK_REDUCTION_IDENTIFIER_plus;
        case 1: return OMPC_TASK_REDUCTION_IDENTIFIER_minus;
        case 2: return OMPC_TASK_REDUCTION_IDENTIFIER_mul;
        case 3: return OMPC_TASK_REDUCTION_IDENTIFIER_bitand;
        case 4: return OMPC_TASK_REDUCTION_IDENTIFIER_bitor;
        case 5: return OMPC_TASK_REDUCTION_IDENTIFIER_bitxor;
        case 6: return OMPC_TASK_REDUCTION_IDENTIFIER_logand;
        case 7: return OMPC_TASK_REDUCTION_IDENTIFIER_logor;
        case 8: return OMPC_TASK_REDUCTION_IDENTIFIER_min;
        case 9: return OMPC_TASK_REDUCTION_IDENTIFIER_max;
        case 10: return OMPC_TASK_REDUCTION_IDENTIFIER_eqv;
        case 11: return OMPC_TASK_REDUCTION_IDENTIFIER_neqv;
        case -1: return OMPC_TASK_REDUCTION_IDENTIFIER_user;
        default: return OMPC_TASK_REDUCTION_IDENTIFIER_unknown;
    }
}

static OpenMPReductionClauseModifier select_reduction_modifier(uint32_t mask) {
    const bool has_task = (mask & ROUP_REDUCTION_MODIFIER_TASK) != 0;
    const bool has_inscan = (mask & ROUP_REDUCTION_MODIFIER_INSCAN) != 0;
    const bool has_default = (mask & ROUP_REDUCTION_MODIFIER_DEFAULT) != 0;

    const int count = static_cast<int>(has_task) + static_cast<int>(has_inscan) + static_cast<int>(has_default);
    if (count == 0) {
        return OMPC_REDUCTION_MODIFIER_unspecified;
    }
    if (count > 1) {
        return OMPC_REDUCTION_MODIFIER_unknown;
    }
    if (has_task) {
        return OMPC_REDUCTION_MODIFIER_task;
    }
    if (has_inscan) {
        return OMPC_REDUCTION_MODIFIER_inscan;
    }
    if (has_default) {
        return OMPC_REDUCTION_MODIFIER_default;
    }
    return OMPC_REDUCTION_MODIFIER_unspecified;
}

static void append_variables_to_clause(OpenMPClause* clause, OmpStringList* list) {
    if (clause == nullptr || list == nullptr) {
        return;
    }

    std::string joined = join_variables_from_list(list);
    if (!joined.empty()) {
        add_list_expressions(clause, joined.c_str());
    }
}

static void add_reduction_clause_from_data(
    OpenMPDirective* dir,
    const OmpClause* roup_clause,
    OpenMPClauseKind clause_kind
) {
    if (roup_clause == nullptr) {
        return;
    }

    int32_t operator_code = roup_clause_reduction_operator(roup_clause);
    uint32_t modifier_mask = roup_clause_reduction_modifier_mask(roup_clause);
    const char* user_identifier = roup_clause_reduction_user_identifier(roup_clause);
    const char* modifiers_text = roup_clause_reduction_modifiers_text(roup_clause);

    char* user_identifier_dup = duplicate_c_string(user_identifier);
    char* user_modifier_dup = duplicate_c_string(modifiers_text);

    OpenMPClause* clause_ptr = nullptr;

    if (clause_kind == OMPC_reduction) {
        clause_ptr = OpenMPReductionClause::addReductionClause(
            dir,
            select_reduction_modifier(modifier_mask),
            map_reduction_identifier(operator_code),
            user_modifier_dup,
            user_identifier_dup
        );
    } else if (clause_kind == OMPC_in_reduction) {
        clause_ptr = OpenMPInReductionClause::addInReductionClause(
            dir,
            map_in_reduction_identifier(operator_code),
            user_identifier_dup
        );
        if (user_modifier_dup) {
            free(user_modifier_dup);
        }
    } else {
        clause_ptr = OpenMPTaskReductionClause::addTaskReductionClause(
            dir,
            map_task_reduction_identifier(operator_code),
            user_identifier_dup
        );
        if (user_modifier_dup) {
            free(user_modifier_dup);
        }
    }

    if (clause_ptr == nullptr) {
        if (user_identifier_dup) {
            free(user_identifier_dup);
        }
        if (clause_kind == OMPC_reduction && user_modifier_dup) {
            free(user_modifier_dup);
        }
        return;
    }

    OmpStringList* variables = roup_clause_variables(roup_clause);
    append_variables_to_clause(clause_ptr, variables);
    if (variables) {
        roup_string_list_free(variables);
    }

    if (clause_ptr != nullptr && clause_ptr->getClausePosition() == -1) {
        dir->getClausesInOriginalOrder()->push_back(clause_ptr);
        clause_ptr->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
    }
}
#include "compat_impl_reduction_handler.cpp"

// Determine if a clause kind takes a comma-separated list of expressions
static bool is_list_clause(OpenMPClauseKind kind) {
    switch (kind) {
        // Data-scoping attribute clauses (most common)
        case OMPC_private:
        case OMPC_firstprivate:
        case OMPC_lastprivate:
        case OMPC_shared:
        case OMPC_copyin:
        case OMPC_copyprivate:
        // Data-sharing clauses
        case OMPC_linear:
        case OMPC_aligned:
        case OMPC_nontemporal:
        case OMPC_uniform:
        // Scan clauses
        case OMPC_inclusive:
        case OMPC_exclusive:
        // Device clauses
        case OMPC_is_device_ptr:
        case OMPC_use_device_ptr:
        case OMPC_use_device_addr:
        case OMPC_has_device_addr:
        // Map-like clauses
        case OMPC_to:
        case OMPC_from:
        case OMPC_link:
        // Depend clause
        case OMPC_depend:
        // Affinity clause
        case OMPC_affinity:
        // Allocator clauses
        case OMPC_allocate:
            return true;
        default:
            return false;
    }
}

// ============================================================================
// Global State
// ============================================================================

static OpenMPBaseLang current_lang = Lang_C;

// Language prefix constants - defined once to avoid manual synchronization
static constexpr const char FORTRAN_PREFIX[] = "!$omp";       // Fortran prefix (lowercase)
static constexpr const char FORTRAN_PREFIX_UPPER[] = "!$OMP"; // Fortran prefix (uppercase)
static constexpr const char C_PRAGMA_PREFIX[] = "#pragma";    // C/C++ pragma prefix
// Compile-time string lengths: sizeof() includes null terminator, subtract 1 for actual length
static constexpr size_t FORTRAN_PREFIX_LEN = sizeof(FORTRAN_PREFIX) - 1;
static constexpr size_t C_PRAGMA_PREFIX_LEN = sizeof(C_PRAGMA_PREFIX) - 1;

extern "C" void setLang(OpenMPBaseLang lang) {
    current_lang = lang;
}

// ============================================================================
// Helper Functions
// ============================================================================

// Map ROUP end directive constants to their paired directive kind
// This is pure enum-based mapping with NO string processing
static OpenMPDirectiveKind getEndDirectivePairedKind(int32_t roup_end_kind) {
    switch (roup_end_kind) {
        // End directives (131-195) -> their paired directive kinds
        case ROUP_OMPD_end_parallel:         return OMPD_parallel;
        case ROUP_OMPD_end_do:               return OMPD_do;
        case ROUP_OMPD_end_simd:             return OMPD_simd;
        case ROUP_OMPD_end_sections:         return OMPD_sections;
        case ROUP_OMPD_end_single:           return OMPD_single;
        case ROUP_OMPD_end_workshare:        return OMPD_workshare;
        case ROUP_OMPD_end_ordered:          return OMPD_ordered;
        case ROUP_OMPD_end_loop:             return OMPD_loop;
        case ROUP_OMPD_end_distribute:       return OMPD_distribute;
        case ROUP_OMPD_end_teams:            return OMPD_teams;
        case ROUP_OMPD_end_taskloop:         return OMPD_taskloop;
        case ROUP_OMPD_end_task:             return OMPD_task;
        case ROUP_OMPD_end_taskgroup:        return OMPD_taskgroup;
        case ROUP_OMPD_end_master:           return OMPD_master;
        case ROUP_OMPD_end_masked:           return OMPD_masked;
        case ROUP_OMPD_end_critical:         return OMPD_critical;
        case ROUP_OMPD_end_atomic:           return OMPD_atomic;
        case ROUP_OMPD_end_parallel_do:      return OMPD_parallel_do;
        case ROUP_OMPD_end_parallel_for:     return OMPD_parallel_for;
        case ROUP_OMPD_end_parallel_sections: return OMPD_parallel_sections;
        case ROUP_OMPD_end_parallel_workshare: return OMPD_parallel_workshare;
        case ROUP_OMPD_end_parallel_master:  return OMPD_parallel_master;
        case ROUP_OMPD_end_do_simd:          return OMPD_do_simd;
        case ROUP_OMPD_end_for_simd:         return OMPD_for_simd;
        case ROUP_OMPD_end_parallel_do_simd: return OMPD_parallel_do_simd;
        case ROUP_OMPD_end_parallel_for_simd: return OMPD_parallel_for_simd;
        case ROUP_OMPD_end_distribute_simd:  return OMPD_distribute_simd;
        case ROUP_OMPD_end_distribute_parallel_do: return OMPD_distribute_parallel_do;
        case ROUP_OMPD_end_distribute_parallel_for: return OMPD_distribute_parallel_for;
        case ROUP_OMPD_end_distribute_parallel_do_simd: return OMPD_distribute_parallel_do_simd;
        case ROUP_OMPD_end_distribute_parallel_for_simd: return OMPD_distribute_parallel_for_simd;
        case ROUP_OMPD_end_target_parallel:  return OMPD_target_parallel;
        case ROUP_OMPD_end_target_parallel_do: return OMPD_target_parallel_do;
        case ROUP_OMPD_end_target_parallel_for: return OMPD_target_parallel_for;
        case ROUP_OMPD_end_target_parallel_do_simd: return OMPD_target_parallel_do_simd;
        case ROUP_OMPD_end_target_parallel_for_simd: return OMPD_target_parallel_for_simd;
        case ROUP_OMPD_end_target_simd:      return OMPD_target_simd;
        case ROUP_OMPD_end_target_teams:     return OMPD_target_teams;
        case ROUP_OMPD_end_target_teams_distribute: return OMPD_target_teams_distribute;
        case ROUP_OMPD_end_target_teams_distribute_parallel_do: return OMPD_target_teams_distribute_parallel_do;
        case ROUP_OMPD_end_target_teams_distribute_parallel_for: return OMPD_target_teams_distribute_parallel_for;
        case ROUP_OMPD_end_target_teams_distribute_parallel_do_simd: return OMPD_target_teams_distribute_parallel_do_simd;
        case ROUP_OMPD_end_target_teams_distribute_parallel_for_simd: return OMPD_target_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_end_target_teams_distribute_simd: return OMPD_target_teams_distribute_simd;
        case ROUP_OMPD_end_target_teams_loop: return OMPD_target_teams_loop;
        case ROUP_OMPD_end_teams_distribute: return OMPD_teams_distribute;
        case ROUP_OMPD_end_teams_distribute_parallel_do: return OMPD_teams_distribute_parallel_do;
        case ROUP_OMPD_end_teams_distribute_parallel_for: return OMPD_teams_distribute_parallel_for;
        case ROUP_OMPD_end_teams_distribute_parallel_do_simd: return OMPD_teams_distribute_parallel_do_simd;
        case ROUP_OMPD_end_teams_distribute_parallel_for_simd: return OMPD_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_end_teams_distribute_simd: return OMPD_teams_distribute_simd;
        case ROUP_OMPD_end_teams_loop:       return OMPD_teams_loop;
        case ROUP_OMPD_end_taskloop_simd:    return OMPD_taskloop_simd;
        case ROUP_OMPD_end_master_taskloop:  return OMPD_master_taskloop;
        case ROUP_OMPD_end_master_taskloop_simd: return OMPD_master_taskloop_simd;
        case ROUP_OMPD_end_masked_taskloop:  return OMPD_masked_taskloop;
        case ROUP_OMPD_end_masked_taskloop_simd: return OMPD_masked_taskloop_simd;
        case ROUP_OMPD_end_parallel_master_taskloop: return OMPD_parallel_master_taskloop;
        case ROUP_OMPD_end_parallel_master_taskloop_simd: return OMPD_parallel_master_taskloop_simd;
        case ROUP_OMPD_end_parallel_masked:      return OMPD_parallel_masked;
        case ROUP_OMPD_end_parallel_masked_taskloop: return OMPD_parallel_masked_taskloop;
        case ROUP_OMPD_end_parallel_masked_taskloop_simd: return OMPD_parallel_masked_taskloop_simd;
        case ROUP_OMPD_end_target_parallel_loop: return OMPD_target_parallel_loop;
        case ROUP_OMPD_end_parallel_loop:    return OMPD_parallel_loop;
        case ROUP_OMPD_end_target_loop:      return OMPD_target_loop;
        case ROUP_OMPD_end_section:          return OMPD_section;
        case ROUP_OMPD_end_unroll:           return OMPD_unroll;
        case ROUP_OMPD_end_tile:             return OMPD_tile;
        case ROUP_OMPD_end_target:           return OMPD_target;
        case ROUP_OMPD_end_target_data:      return OMPD_target_data;
        case ROUP_OMPD_end_target_enter_data: return OMPD_target_enter_data;
        case ROUP_OMPD_end_target_exit_data: return OMPD_target_exit_data;
        case ROUP_OMPD_end_target_update:    return OMPD_target_update;
        // Special end directives that already had unique constants
        case ROUP_OMPD_end_declare_target:   return OMPD_declare_target;
        case ROUP_OMPD_end_declare_variant:  return OMPD_declare_variant;
        case ROUP_OMPD_end_assume:           return OMPD_assume;
        case ROUP_OMPD_end_assumes:          return OMPD_assumes;
        // Bare "end" directive (rare, mainly for error recovery)
        case ROUP_OMPD_end:                  return OMPD_unknown;
        default:                                  return OMPD_unknown;
    }
}

static OpenMPDirectiveKind mapRoupToOmpparserDirective(int32_t roup_kind) {
    // ROUP directive kind mapping using named constants
    // Complete 1:1 mapping of all 131 OpenMP directives
    // See roup_constants.h and src/c_api.rs:directive_name_to_kind()
    switch (roup_kind) {
        case ROUP_OMPD_parallel:       return OMPD_parallel;
        case ROUP_OMPD_for:            return OMPD_for;
        case ROUP_OMPD_do:             return OMPD_do;
        case ROUP_OMPD_simd:           return OMPD_simd;
        case ROUP_OMPD_for_simd:       return OMPD_for_simd;
        case ROUP_OMPD_do_simd:        return OMPD_do_simd;
        case ROUP_OMPD_parallel_for_simd: return OMPD_parallel_for_simd;
        case ROUP_OMPD_parallel_do_simd:  return OMPD_parallel_do_simd;
        case ROUP_OMPD_declare_simd:   return OMPD_declare_simd;
        case ROUP_OMPD_distribute:     return OMPD_distribute;
        case ROUP_OMPD_distribute_simd: return OMPD_distribute_simd;
        case ROUP_OMPD_distribute_parallel_for: return OMPD_distribute_parallel_for;
        case ROUP_OMPD_distribute_parallel_do:  return OMPD_distribute_parallel_do;
        case ROUP_OMPD_distribute_parallel_for_simd: return OMPD_distribute_parallel_for_simd;
        case ROUP_OMPD_distribute_parallel_do_simd:  return OMPD_distribute_parallel_do_simd;
        case ROUP_OMPD_loop:           return OMPD_loop;
        case ROUP_OMPD_scan:           return OMPD_scan;
        case ROUP_OMPD_sections:       return OMPD_sections;
        case ROUP_OMPD_section:        return OMPD_section;
        case ROUP_OMPD_single:         return OMPD_single;
        case ROUP_OMPD_workshare:      return OMPD_workshare;
        case ROUP_OMPD_cancel:         return OMPD_cancel;
        case ROUP_OMPD_cancellation_point: return OMPD_cancellation_point;
        case ROUP_OMPD_allocate:       return OMPD_allocate;
        case ROUP_OMPD_threadprivate:  return OMPD_threadprivate;
        case ROUP_OMPD_declare_reduction: return OMPD_declare_reduction;
        case ROUP_OMPD_declare_mapper: return OMPD_declare_mapper;
        case ROUP_OMPD_parallel_for:   return OMPD_parallel_for;
        case ROUP_OMPD_parallel_do:    return OMPD_parallel_do;
        case ROUP_OMPD_parallel_loop:  return OMPD_parallel_loop;
        case ROUP_OMPD_parallel_sections: return OMPD_parallel_sections;
        case ROUP_OMPD_parallel_single: return OMPD_parallel_single;
        case ROUP_OMPD_parallel_workshare: return OMPD_parallel_workshare;
        case ROUP_OMPD_parallel_master: return OMPD_parallel_master;
        case ROUP_OMPD_master_taskloop: return OMPD_master_taskloop;
        case ROUP_OMPD_master_taskloop_simd: return OMPD_master_taskloop_simd;
        case ROUP_OMPD_parallel_master_taskloop: return OMPD_parallel_master_taskloop;
        case ROUP_OMPD_parallel_master_taskloop_simd: return OMPD_parallel_master_taskloop_simd;
        case ROUP_OMPD_teams:          return OMPD_teams;
        case ROUP_OMPD_metadirective:  return OMPD_metadirective;
        case ROUP_OMPD_declare_variant: return OMPD_declare_variant;
        case ROUP_OMPD_begin_declare_variant: return OMPD_begin_declare_variant;
        case ROUP_OMPD_end_declare_variant: return OMPD_end_declare_variant;
        case ROUP_OMPD_task:           return OMPD_task;
        case ROUP_OMPD_taskloop:       return OMPD_taskloop;
        case ROUP_OMPD_taskloop_simd:  return OMPD_taskloop_simd;
        case ROUP_OMPD_taskyield:      return OMPD_taskyield;
        case ROUP_OMPD_requires:       return OMPD_requires;
        case ROUP_OMPD_target_data:    return OMPD_target_data;
        case ROUP_OMPD_target_data_composite: return OMPD_target_data_composite;
        case ROUP_OMPD_target_enter_data: return OMPD_target_enter_data;
        case ROUP_OMPD_target_update:  return OMPD_target_update;
        case ROUP_OMPD_target_exit_data: return OMPD_target_exit_data;
        case ROUP_OMPD_target:         return OMPD_target;
        case ROUP_OMPD_declare_target: return OMPD_declare_target;
        case ROUP_OMPD_begin_declare_target: return OMPD_begin_declare_target;
        case ROUP_OMPD_end_declare_target: return OMPD_end_declare_target;
        case ROUP_OMPD_master:         return OMPD_master;
        case ROUP_OMPD_end:            return OMPD_end;
        case ROUP_OMPD_barrier:        return OMPD_barrier;
        case ROUP_OMPD_taskwait:       return OMPD_taskwait;
        case ROUP_OMPD_unroll:         return OMPD_unroll;
        case ROUP_OMPD_tile:           return OMPD_tile;
        case ROUP_OMPD_taskgroup:      return OMPD_taskgroup;
        case ROUP_OMPD_flush:          return OMPD_flush;
        case ROUP_OMPD_atomic:         return OMPD_atomic;
        case ROUP_OMPD_critical:       return OMPD_critical;
        case ROUP_OMPD_depobj:         return OMPD_depobj;
        case ROUP_OMPD_ordered:        return OMPD_ordered;
        case ROUP_OMPD_teams_distribute: return OMPD_teams_distribute;
        case ROUP_OMPD_teams_distribute_simd: return OMPD_teams_distribute_simd;
        case ROUP_OMPD_teams_distribute_parallel_for: return OMPD_teams_distribute_parallel_for;
        case ROUP_OMPD_teams_distribute_parallel_for_simd: return OMPD_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_teams_loop:     return OMPD_teams_loop;
        case ROUP_OMPD_target_parallel: return OMPD_target_parallel;
        case ROUP_OMPD_target_parallel_for: return OMPD_target_parallel_for;
        case ROUP_OMPD_target_parallel_for_simd: return OMPD_target_parallel_for_simd;
        case ROUP_OMPD_target_parallel_loop: return OMPD_target_parallel_loop;
        case ROUP_OMPD_target_simd:    return OMPD_target_simd;
        case ROUP_OMPD_target_teams:   return OMPD_target_teams;
        case ROUP_OMPD_target_teams_distribute: return OMPD_target_teams_distribute;
        case ROUP_OMPD_target_teams_distribute_simd: return OMPD_target_teams_distribute_simd;
        case ROUP_OMPD_target_teams_loop: return OMPD_target_teams_loop;
        case ROUP_OMPD_target_teams_distribute_parallel_for: return OMPD_target_teams_distribute_parallel_for;
        case ROUP_OMPD_target_teams_distribute_parallel_for_simd: return OMPD_target_teams_distribute_parallel_for_simd;
        case ROUP_OMPD_teams_distribute_parallel_do: return OMPD_teams_distribute_parallel_do;
        case ROUP_OMPD_teams_distribute_parallel_do_simd: return OMPD_teams_distribute_parallel_do_simd;
        case ROUP_OMPD_target_parallel_do: return OMPD_target_parallel_do;
        case ROUP_OMPD_target_parallel_do_simd: return OMPD_target_parallel_do_simd;
        case ROUP_OMPD_target_teams_distribute_parallel_do: return OMPD_target_teams_distribute_parallel_do;
        case ROUP_OMPD_target_teams_distribute_parallel_do_simd: return OMPD_target_teams_distribute_parallel_do_simd;
        // OpenMP 5.1 directives
        case ROUP_OMPD_error:          return OMPD_error;
        case ROUP_OMPD_nothing:        return OMPD_nothing;
        case ROUP_OMPD_masked:         return OMPD_masked;
        case ROUP_OMPD_scope:          return OMPD_scope;
        case ROUP_OMPD_masked_taskloop: return OMPD_masked_taskloop;
        case ROUP_OMPD_masked_taskloop_simd: return OMPD_masked_taskloop_simd;
        case ROUP_OMPD_parallel_masked: return OMPD_parallel_masked;
        case ROUP_OMPD_parallel_masked_taskloop: return OMPD_parallel_masked_taskloop;
        case ROUP_OMPD_parallel_masked_taskloop_simd: return OMPD_parallel_masked_taskloop_simd;
        case ROUP_OMPD_interop:        return OMPD_interop;
        // OpenMP 5.2 directives
        case ROUP_OMPD_assume:         return OMPD_assume;
        case ROUP_OMPD_end_assume:     return OMPD_end_assume;
        case ROUP_OMPD_assumes:        return OMPD_assumes;
        case ROUP_OMPD_begin_assumes:  return OMPD_begin_assumes;
        case ROUP_OMPD_end_assumes:    return OMPD_end_assumes;
        // OpenMP 6.0 directives
        case ROUP_OMPD_allocators:     return OMPD_allocators;
        case ROUP_OMPD_taskgraph:      return OMPD_taskgraph;
        case ROUP_OMPD_task_iteration: return OMPD_task_iteration;
        case ROUP_OMPD_dispatch:       return OMPD_dispatch;
        case ROUP_OMPD_groupprivate:   return OMPD_groupprivate;
        case ROUP_OMPD_workdistribute: return OMPD_workdistribute;
        case ROUP_OMPD_fuse:           return OMPD_fuse;
        case ROUP_OMPD_interchange:    return OMPD_interchange;
        case ROUP_OMPD_reverse:        return OMPD_reverse;
        case ROUP_OMPD_split:          return OMPD_split;
        case ROUP_OMPD_stripe:         return OMPD_stripe;
        case ROUP_OMPD_declare_induction: return OMPD_declare_induction;
        case ROUP_OMPD_begin_metadirective: return OMPD_begin_metadirective;
        // Missing *_loop and *_loop_simd combinations
        case ROUP_OMPD_parallel_loop_simd: return OMPD_parallel_loop_simd;
        case ROUP_OMPD_teams_loop_simd: return OMPD_teams_loop_simd;
        case ROUP_OMPD_target_loop:    return OMPD_target_loop;
        case ROUP_OMPD_target_loop_simd: return OMPD_target_loop_simd;
        case ROUP_OMPD_target_parallel_loop_simd: return OMPD_target_parallel_loop_simd;
        case ROUP_OMPD_target_teams_loop_simd: return OMPD_target_teams_loop_simd;
        case ROUP_OMPD_distribute_parallel_loop: return OMPD_distribute_parallel_loop;
        case ROUP_OMPD_distribute_parallel_loop_simd: return OMPD_distribute_parallel_loop_simd;
        case ROUP_OMPD_teams_distribute_parallel_loop: return OMPD_teams_distribute_parallel_loop;
        case ROUP_OMPD_teams_distribute_parallel_loop_simd: return OMPD_teams_distribute_parallel_loop_simd;
        case ROUP_OMPD_target_teams_distribute_parallel_loop: return OMPD_target_teams_distribute_parallel_loop;
        case ROUP_OMPD_target_teams_distribute_parallel_loop_simd: return OMPD_target_teams_distribute_parallel_loop_simd;
        // All End* directives (131-195) map to OMPD_end in ompparser
        case ROUP_OMPD_end_parallel:
        case ROUP_OMPD_end_do:
        case ROUP_OMPD_end_simd:
        case ROUP_OMPD_end_sections:
        case ROUP_OMPD_end_single:
        case ROUP_OMPD_end_workshare:
        case ROUP_OMPD_end_ordered:
        case ROUP_OMPD_end_loop:
        case ROUP_OMPD_end_distribute:
        case ROUP_OMPD_end_teams:
        case ROUP_OMPD_end_taskloop:
        case ROUP_OMPD_end_task:
        case ROUP_OMPD_end_taskgroup:
        case ROUP_OMPD_end_master:
        case ROUP_OMPD_end_critical:
        case ROUP_OMPD_end_atomic:
        case ROUP_OMPD_end_parallel_do:
        case ROUP_OMPD_end_parallel_for:
        case ROUP_OMPD_end_parallel_sections:
        case ROUP_OMPD_end_parallel_workshare:
        case ROUP_OMPD_end_parallel_master:
        case ROUP_OMPD_end_do_simd:
        case ROUP_OMPD_end_for_simd:
        case ROUP_OMPD_end_parallel_do_simd:
        case ROUP_OMPD_end_parallel_for_simd:
        case ROUP_OMPD_end_distribute_simd:
        case ROUP_OMPD_end_distribute_parallel_do:
        case ROUP_OMPD_end_distribute_parallel_for:
        case ROUP_OMPD_end_distribute_parallel_do_simd:
        case ROUP_OMPD_end_distribute_parallel_for_simd:
        case ROUP_OMPD_end_target_parallel:
        case ROUP_OMPD_end_target_parallel_do:
        case ROUP_OMPD_end_target_parallel_for:
        case ROUP_OMPD_end_target_parallel_do_simd:
        case ROUP_OMPD_end_target_parallel_for_simd:
        case ROUP_OMPD_end_target_simd:
        case ROUP_OMPD_end_target_teams:
        case ROUP_OMPD_end_target_teams_distribute:
        case ROUP_OMPD_end_target_teams_distribute_parallel_do:
        case ROUP_OMPD_end_target_teams_distribute_parallel_for:
        case ROUP_OMPD_end_target_teams_distribute_parallel_do_simd:
        case ROUP_OMPD_end_target_teams_distribute_parallel_for_simd:
        case ROUP_OMPD_end_target_teams_distribute_simd:
        case ROUP_OMPD_end_target_teams_loop:
        case ROUP_OMPD_end_teams_distribute:
        case ROUP_OMPD_end_teams_distribute_parallel_do:
        case ROUP_OMPD_end_teams_distribute_parallel_for:
        case ROUP_OMPD_end_teams_distribute_parallel_do_simd:
        case ROUP_OMPD_end_teams_distribute_parallel_for_simd:
        case ROUP_OMPD_end_teams_distribute_simd:
        case ROUP_OMPD_end_teams_loop:
        case ROUP_OMPD_end_taskloop_simd:
        case ROUP_OMPD_end_master_taskloop:
        case ROUP_OMPD_end_master_taskloop_simd:
        case ROUP_OMPD_end_parallel_master_taskloop:
        case ROUP_OMPD_end_parallel_master_taskloop_simd:
        case ROUP_OMPD_end_target_parallel_loop:
        case ROUP_OMPD_end_parallel_loop:
        case ROUP_OMPD_end_target_loop:
        case ROUP_OMPD_end_section:
        case ROUP_OMPD_end_unroll:
        case ROUP_OMPD_end_tile:
        case ROUP_OMPD_end_target:
        case ROUP_OMPD_end_target_data:
        case ROUP_OMPD_end_target_enter_data:
        case ROUP_OMPD_end_target_exit_data:
        case ROUP_OMPD_end_target_update:
            return OMPD_end;
        default:                            return OMPD_unknown;
    }
}

static OpenMPClauseKind mapRoupToOmpparserClause(int32_t roup_kind) {
    // ROUP clause kind mapping using named constants from roup_constants.h
    // Complete mapping of all OpenMP clauses
    // Single source of truth: src/c_api.rs:convert_clause()
    switch (roup_kind) {
        case ROUP_OMPC_if:            return OMPC_if;
        case ROUP_OMPC_num_threads:   return OMPC_num_threads;
        case ROUP_OMPC_default:       return OMPC_default;
        case ROUP_OMPC_private:       return OMPC_private;
        case ROUP_OMPC_firstprivate:  return OMPC_firstprivate;
        case ROUP_OMPC_shared:        return OMPC_shared;
        case ROUP_OMPC_copy_in:       return OMPC_copyin;
        case ROUP_OMPC_align:         return OMPC_align;
        case ROUP_OMPC_reduction:     return OMPC_reduction;
        case ROUP_OMPC_lastprivate:   return OMPC_lastprivate;
        case ROUP_OMPC_collapse:      return OMPC_collapse;
        case ROUP_OMPC_ordered:       return OMPC_ordered;
        case ROUP_OMPC_nowait:        return OMPC_nowait;
        case ROUP_OMPC_schedule:      return OMPC_schedule;
        case ROUP_OMPC_allocator:     return OMPC_allocator;
        case ROUP_OMPC_device:        return OMPC_device;
        case ROUP_OMPC_map:           return OMPC_map;
        case ROUP_OMPC_link:          return OMPC_link;
        case ROUP_OMPC_device_type:   return OMPC_device_type;
        case ROUP_OMPC_acq_rel:       return OMPC_acq_rel;
        case ROUP_OMPC_release:       return OMPC_release;
        case ROUP_OMPC_acquire:       return OMPC_acquire;
        case ROUP_OMPC_read:          return OMPC_read;
        case ROUP_OMPC_write:         return OMPC_write;
        case ROUP_OMPC_update:        return OMPC_update;
        case ROUP_OMPC_capture:       return OMPC_capture;
        case ROUP_OMPC_seq_cst:       return OMPC_seq_cst;
        case ROUP_OMPC_relaxed:       return OMPC_relaxed;
        case ROUP_OMPC_hint:          return OMPC_hint;
        case ROUP_OMPC_num_teams:     return OMPC_num_teams;
        case ROUP_OMPC_thread_limit:  return OMPC_thread_limit;
        case ROUP_OMPC_dist_schedule: return OMPC_dist_schedule;
        case ROUP_OMPC_in_reduction:  return OMPC_in_reduction;
        case ROUP_OMPC_depend:        return OMPC_depend;
        case ROUP_OMPC_is_device_ptr: return OMPC_is_device_ptr;
        case ROUP_OMPC_defaultmap:    return OMPC_defaultmap;
        case ROUP_OMPC_uses_allocators: return OMPC_uses_allocators;
        // Additional OpenMP clauses from spec
        case ROUP_OMPC_proc_bind:     return OMPC_proc_bind;
        case ROUP_OMPC_allocate:      return OMPC_allocate;
        case ROUP_OMPC_linear:        return OMPC_linear;
        case ROUP_OMPC_safelen:       return OMPC_safelen;
        case ROUP_OMPC_simdlen:       return OMPC_simdlen;
        case ROUP_OMPC_aligned:       return OMPC_aligned;
        case ROUP_OMPC_nontemporal:   return OMPC_nontemporal;
        case ROUP_OMPC_uniform:       return OMPC_uniform;
        case ROUP_OMPC_inbranch:      return OMPC_inbranch;
        case ROUP_OMPC_notinbranch:   return OMPC_notinbranch;
        case ROUP_OMPC_bind:          return OMPC_bind;
        case ROUP_OMPC_inclusive:     return OMPC_inclusive;
        case ROUP_OMPC_exclusive:     return OMPC_exclusive;
        case ROUP_OMPC_copyprivate:   return OMPC_copyprivate;
        case ROUP_OMPC_parallel:      return OMPC_parallel;
        case ROUP_OMPC_sections:      return OMPC_sections;
        case ROUP_OMPC_for:           return OMPC_for;
        case ROUP_OMPC_do:            return OMPC_do;
        case ROUP_OMPC_taskgroup:     return OMPC_taskgroup;
        case ROUP_OMPC_initializer:   return OMPC_initializer;
        case ROUP_OMPC_final:         return OMPC_final;
        case ROUP_OMPC_untied:        return OMPC_untied;
        case ROUP_OMPC_requires:      return OMPC_requires;
        case ROUP_OMPC_mergeable:     return OMPC_mergeable;
        case ROUP_OMPC_priority:      return OMPC_priority;
        case ROUP_OMPC_affinity:      return OMPC_affinity;
        case ROUP_OMPC_detach:        return OMPC_detach;
        case ROUP_OMPC_grainsize:     return OMPC_grainsize;
        case ROUP_OMPC_num_tasks:     return OMPC_num_tasks;
        case ROUP_OMPC_nogroup:       return OMPC_nogroup;
        case ROUP_OMPC_reverse_offload: return OMPC_reverse_offload;
        case ROUP_OMPC_unified_address: return OMPC_unified_address;
        case ROUP_OMPC_unified_shared_memory: return OMPC_unified_shared_memory;
        case ROUP_OMPC_atomic_default_mem_order: return OMPC_atomic_default_mem_order;
        case ROUP_OMPC_dynamic_allocators: return OMPC_dynamic_allocators;
        case ROUP_OMPC_self_maps:     return OMPC_unknown; // not in ompparser
        case ROUP_OMPC_ext_implementation_defined_requirement: return OMPC_ext_implementation_defined_requirement;
        case ROUP_OMPC_use_device_ptr: return OMPC_use_device_ptr;
        case ROUP_OMPC_sizes:         return OMPC_sizes;
        case ROUP_OMPC_use_device_addr: return OMPC_use_device_addr;
        case ROUP_OMPC_has_device_addr: return OMPC_has_device_addr;
        case ROUP_OMPC_to:            return OMPC_to;
        case ROUP_OMPC_from:          return OMPC_from;
        case ROUP_OMPC_when:          return OMPC_when;
        case ROUP_OMPC_otherwise:     return OMPC_otherwise;
        case ROUP_OMPC_match:         return OMPC_match;
        case ROUP_OMPC_task_reduction: return OMPC_task_reduction;
        case ROUP_OMPC_destroy:       return OMPC_destroy;
        case ROUP_OMPC_depobj_update: return OMPC_depobj_update;
        case ROUP_OMPC_compare:       return OMPC_compare;
        case ROUP_OMPC_compare_capture: return OMPC_unknown; // "compare capture" handled as two clauses
        case ROUP_OMPC_partial:       return OMPC_partial;
        case ROUP_OMPC_full:          return OMPC_full;
        case ROUP_OMPC_order:         return OMPC_order;
        // Additional clauses for ompparser compatibility (new numbering starting at 133)
        case ROUP_OMPC_threads:       return OMPC_threads;
        case ROUP_OMPC_simd:          return OMPC_simd;
        default:                        return OMPC_unknown;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

extern "C" {

OpenMPDirective* parseOpenMP(const char* input, void* exprParse(const char* expr)) {
    if (!input || input[0] == '\0') {
        return nullptr;
    }

    // Validate input length using constant from ROUP C API
    // Use strnlen to safely handle potentially untrusted/non-null-terminated input
    const size_t input_len = strnlen(input, ROUP_MAX_PRAGMA_LENGTH);
    if (input_len == ROUP_MAX_PRAGMA_LENGTH) {
        return nullptr;  // Input too long or not null-terminated within limit
    }

    // Determine input format based on current language mode
    std::string input_str(input, input_len);

    // Handle different language pragmas
    if (current_lang == Lang_Fortran) {
        // Fortran uses !$omp prefix - add if missing (case-insensitive check)
        const bool has_prefix =
            input_str.length() >= FORTRAN_PREFIX_LEN &&
            (input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX) == 0 ||
             input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX_UPPER) == 0);
        if (!has_prefix) {
            input_str = std::string(FORTRAN_PREFIX) + " " + input_str;
        }
    } else {
        // C/C++ use #pragma omp prefix - add if missing
        // compare() returns 0 if strings match, non-zero otherwise
        if (input_str.compare(0, C_PRAGMA_PREFIX_LEN, C_PRAGMA_PREFIX) != 0) {
            input_str = std::string(C_PRAGMA_PREFIX) + " " + input_str;
        }
    }

    // Call ROUP parser with correct language
    int32_t roup_lang = (current_lang == Lang_Fortran) ? ROUP_LANG_FORTRAN_FREE : ROUP_LANG_C;
    OmpDirective* roup_dir = roup_parse_with_language(input_str.c_str(), roup_lang);
    if (!roup_dir) {
        return nullptr;
    }

    // Get directive kind from ROUP
    int32_t roup_kind = roup_directive_kind(roup_dir);
    OpenMPDirectiveKind kind = mapRoupToOmpparserDirective(roup_kind);

    // Create ompparser-compatible directive
    // Use appropriate subclass based on directive kind for proper polymorphic behavior
    OpenMPDirective* dir = nullptr;
    switch (kind) {
        case OMPD_atomic:
            dir = new OpenMPAtomicDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_end:
            {
                // End directives - use enum-based mapping (NO string processing!)
                // Get paired directive kind using ROUP enum constant
                OpenMPDirectiveKind paired_kind = getEndDirectivePairedKind(roup_kind);

                // Create end directive
                OpenMPEndDirective* end_dir = new OpenMPEndDirective();
                end_dir->setBaseLang(current_lang);

                // Create paired directive (simplified version without clauses)
                // The paired directive is mainly for toString purposes
                if (paired_kind != OMPD_unknown) {
                    OpenMPDirective* paired_dir = nullptr;

                    // For critical end directive, create OpenMPCriticalDirective to avoid bad_alloc
                    // when generatePragmaString() tries to access getCriticalName()
                    if (paired_kind == OMPD_critical) {
                        OpenMPCriticalDirective* crit_dir = new OpenMPCriticalDirective();
                        crit_dir->setBaseLang(current_lang);

                        // WORKAROUND: ROUP doesn't parse parameters for end directives (e.g., "end critical(name)")
                        // We need to extract the name from the original input string
                        // TODO: Add proper support for this in ROUP parser
                        std::string name_str;
                        const char* name_start = strstr(input_str.c_str(), "critical");
                        if (name_start) {
                            name_start += 8; // skip "critical"
                            // Skip whitespace
                            while (*name_start && isspace(*name_start)) name_start++;
                            if (*name_start == '(') {
                                name_start++; // skip '('
                                const char* name_end = strchr(name_start, ')');
                                if (name_end) {
                                    name_str = std::string(name_start, name_end - name_start);
                                }
                            }
                        }

                        crit_dir->setCriticalName(name_str.c_str());
                        paired_dir = crit_dir;
                    } else {
                        paired_dir = new OpenMPDirective(paired_kind, current_lang, 0, 0);
                    }

                    end_dir->setPairedDirective(paired_dir);
                }

                dir = end_dir;
            }
            break;
        case OMPD_requires:
            dir = new OpenMPRequiresDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_allocate:
            dir = new OpenMPAllocateDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_threadprivate:
            dir = new OpenMPThreadprivateDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_groupprivate:
            dir = new OpenMPGroupprivateDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_flush:
            dir = new OpenMPFlushDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_critical:
            {
                OpenMPCriticalDirective* crit_dir = new OpenMPCriticalDirective();
                crit_dir->setBaseLang(current_lang);
                // Set empty region name to avoid bad_alloc when toString() is called
                crit_dir->setCriticalName("");
                dir = crit_dir;
            }
            break;
        case OMPD_depobj:
            dir = new OpenMPDepobjDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_ordered:
            dir = new OpenMPOrderedDirective();
            dir->setBaseLang(current_lang);
            break;
        case OMPD_declare_simd:
            {
                OpenMPDeclareSimdDirective* ds_dir = new OpenMPDeclareSimdDirective();
                ds_dir->setBaseLang(current_lang);
                // Set empty proc name to avoid bad_alloc when getProcName() is called
                ds_dir->addProcName("");
                dir = ds_dir;
            }
            break;
        case OMPD_declare_reduction:
            {
                OpenMPDeclareReductionDirective* dr_dir = new OpenMPDeclareReductionDirective();
                dr_dir->setBaseLang(current_lang);
                // Set empty identifier and combiner to avoid bad_alloc
                dr_dir->setIdentifier("NOTPARSED");
                dr_dir->setCombiner("NOTPARSED");
                dir = dr_dir;
            }
            break;
        case OMPD_declare_mapper:
            {
                OpenMPDeclareMapperDirective* dm_dir =
                    new OpenMPDeclareMapperDirective(OMPD_DECLARE_MAPPER_IDENTIFIER_unspecified);
                dm_dir->setBaseLang(current_lang);
                // Set empty strings to avoid bad_alloc
                dm_dir->setUserDefinedIdentifier("");
                dm_dir->setDeclareMapperType("");
                dm_dir->setDeclareMapperVar("");
                dir = dm_dir;
            }
            break;
        case OMPD_declare_target:
        case OMPD_begin_declare_target:
            {
                OpenMPDeclareTargetDirective* dt_dir = new OpenMPDeclareTargetDirective();
                dt_dir->setBaseLang(current_lang);
                // Initialize to avoid segfault - declare target can be empty or have clauses
                dir = dt_dir;
            }
            break;
        case OMPD_end_declare_target:
            // End declare target is a standalone directive, not an OpenMPEndDirective
            // It uses the base OpenMPDirective class
            dir = new OpenMPDirective(kind, current_lang, 0, 0);
            break;
        default:
            // Generic directive for all other cases (including complex directives that need parameters)
            dir = new OpenMPDirective(kind, current_lang, 0, 0);
            break;
    }

    // Handle directive-specific parameters (e.g., variable lists for allocate/threadprivate)
    const char* param = roup_directive_parameter(roup_dir);
    if (param != nullptr && param[0] != '\0') {
        // For most directives, remove outer parentheses: "(a,b,c)" -> "a,b,c"
        // Exception: declare reduction and declare simd need the full parameter as-is
        std::string param_str(param);
        if (kind != OMPD_declare_reduction && kind != OMPD_declare_simd) {
            if (param_str.length() >= 2 && param_str.front() == '(' && param_str.back() == ')') {
                param_str = param_str.substr(1, param_str.length() - 2);
            }
        }

        // Allocate persistent storage for the parameter string
        // ompparser's addXxxList methods store the pointer, they don't copy the string
        char* persistent_param = strdup(param_str.c_str());

        // For directives that have special list methods
        if (kind == OMPD_allocate) {
            OpenMPAllocateDirective* alloc_dir = static_cast<OpenMPAllocateDirective*>(dir);
            alloc_dir->addAllocateList(persistent_param);
        } else if (kind == OMPD_threadprivate) {
            OpenMPThreadprivateDirective* tp_dir = static_cast<OpenMPThreadprivateDirective*>(dir);
            tp_dir->addThreadprivateList(persistent_param);
        } else if (kind == OMPD_groupprivate) {
            OpenMPGroupprivateDirective* gp_dir = static_cast<OpenMPGroupprivateDirective*>(dir);
            gp_dir->addGroupprivateList(persistent_param);
        } else if (kind == OMPD_cancel || kind == OMPD_cancellation_point) {
            // For cancel and cancellation_point directives, the parameter is the construct type
            // (parallel, sections, for, do, taskgroup) which needs to be added as a clause
            std::string construct_type_str(param_str);
            if (construct_type_str == "parallel") {
                dir->addOpenMPClause(OMPC_parallel);
            } else if (construct_type_str == "sections") {
                dir->addOpenMPClause(OMPC_sections);
            } else if (construct_type_str == "for") {
                dir->addOpenMPClause(OMPC_for);
            } else if (construct_type_str == "do") {
                dir->addOpenMPClause(OMPC_do);
            } else if (construct_type_str == "taskgroup") {
                dir->addOpenMPClause(OMPC_taskgroup);
            }
            // Don't need to free persistent_param here since we don't use it
            free(persistent_param);
        } else if (kind == OMPD_scan) {
            // For scan directive, the parameter is either "inclusive(list)" or "exclusive(list)"
            // We need to parse it and add the appropriate clause with the variable list
            std::string scan_param_str(param_str);

            // Check if it starts with "inclusive(" or "exclusive("
            if (scan_param_str.find("inclusive(") == 0) {
                // Extract the list from "inclusive(a,b,c)" -> "a,b,c"
                size_t start = strlen("inclusive(");
                size_t end = scan_param_str.rfind(')');
                if (end != std::string::npos && end > start) {
                    std::string list = scan_param_str.substr(start, end - start);
                    // Format the list with spaces after commas
                    std::string formatted_list = format_clause_args(list.c_str(), false);
                    // Add inclusive clause with the variable list
                    OpenMPClause* clause = dir->addOpenMPClause(OMPC_inclusive, "");
                    if (clause != nullptr) {
                        add_list_expressions(clause, formatted_list.c_str());
                    }
                }
            } else if (scan_param_str.find("exclusive(") == 0) {
                // Extract the list from "exclusive(a,b,c)" -> "a,b,c"
                size_t start = strlen("exclusive(");
                size_t end = scan_param_str.rfind(')');
                if (end != std::string::npos && end > start) {
                    std::string list = scan_param_str.substr(start, end - start);
                    // Format the list with spaces after commas
                    std::string formatted_list = format_clause_args(list.c_str(), false);
                    // Add exclusive clause with the variable list
                    OpenMPClause* clause = dir->addOpenMPClause(OMPC_exclusive, "");
                    if (clause != nullptr) {
                        add_list_expressions(clause, formatted_list.c_str());
                    }
                }
            }
            free(persistent_param);
        } else if (kind == OMPD_critical) {
            // Critical directive takes an optional name
            OpenMPCriticalDirective* crit_dir = static_cast<OpenMPCriticalDirective*>(dir);
            crit_dir->setCriticalName(persistent_param);
        } else if (kind == OMPD_depobj) {
            // Depobj directive takes a depobj-object variable
            OpenMPDepobjDirective* depobj_dir = static_cast<OpenMPDepobjDirective*>(dir);
            depobj_dir->addDepobj(persistent_param);
        } else if (kind == OMPD_flush) {
            // Flush directive takes an optional list
            OpenMPFlushDirective* flush_dir = static_cast<OpenMPFlushDirective*>(dir);
            flush_dir->addFlushList(persistent_param);
        } else if (kind == OMPD_ordered) {
            // Ordered directive can take a depend clause argument
            // For now, store it as is
            free(persistent_param);
        } else if (kind == OMPD_declare_reduction) {
            // Parse declare reduction parameter: (operator : type-list : combiner) initializer(...)
            // Format from ROUP: "(+ : const, int : a) initializer(omp_priv=foo(c,a,d))"
            OpenMPDeclareReductionDirective* dr_dir = static_cast<OpenMPDeclareReductionDirective*>(dir);
            std::string param_full(persistent_param);

            // Simple parsing: find the three colons that separate operator, types, and combiner
            // Format: (op : types : combiner) [initializer(...)]
            if (!param_full.empty() && param_full[0] == '(') {
                size_t close_paren = param_full.find(')');
                if (close_paren != std::string::npos) {
                    std::string spec = param_full.substr(1, close_paren - 1);  // Remove outer parens

                    // Find first colon (after operator)
                    size_t colon1 = spec.find(':');
                    if (colon1 != std::string::npos) {
                        std::string op = spec.substr(0, colon1);
                        // Trim
                        size_t op_start = op.find_first_not_of(" \t");
                        size_t op_end = op.find_last_not_of(" \t");
                        if (op_start != std::string::npos && op_end != std::string::npos) {
                            op = op.substr(op_start, op_end - op_start + 1);
                        }
                        dr_dir->setIdentifier(op);

                        // Find second colon (after types)
                        size_t colon2 = spec.find(':', colon1 + 1);
                        if (colon2 != std::string::npos) {
                            std::string types = spec.substr(colon1 + 1, colon2 - colon1 - 1);

                            // Split types by comma
                            std::stringstream ss(types);
                            std::string type;
                            while (std::getline(ss, type, ',')) {
                                size_t start = type.find_first_not_of(" \t");
                                size_t end = type.find_last_not_of(" \t");
                                if (start != std::string::npos && end != std::string::npos) {
                                    type = type.substr(start, end - start + 1);
                                    dr_dir->addTypenameList(strdup(type.c_str()));
                                }
                            }

                            // Get combiner
                            std::string combiner = spec.substr(colon2 + 1);
                            size_t comb_start = combiner.find_first_not_of(" \t");
                            size_t comb_end = combiner.find_last_not_of(" \t");
                            if (comb_start != std::string::npos && comb_end != std::string::npos) {
                                combiner = combiner.substr(comb_start, comb_end - comb_start + 1);
                            }
                            dr_dir->setCombiner(combiner.c_str());
                        }
                    }

                    // Handle initializer clause
                    size_t init_pos = param_full.find("initializer", close_paren);
                    if (init_pos != std::string::npos) {
                        size_t init_paren = param_full.find('(', init_pos);
                        if (init_paren != std::string::npos) {
                            // Find matching closing parenthesis (handle nested parentheses)
                            int paren_depth = 1;
                            size_t init_close = init_paren + 1;
                            while (init_close < param_full.length() && paren_depth > 0) {
                                if (param_full[init_close] == '(') {
                                    paren_depth++;
                                } else if (param_full[init_close] == ')') {
                                    paren_depth--;
                                }
                                if (paren_depth > 0) {
                                    init_close++;
                                }
                            }
                            if (paren_depth == 0 && init_close < param_full.length()) {
                                std::string init_expr = param_full.substr(init_paren + 1, init_close - init_paren - 1);
                                // Create initializer clause using static method
                                // Use OMPC_INITIALIZER_PRIV_user and pass the expression as user-defined priv
                                char* persistent_init_expr = strdup(init_expr.c_str());
                                OpenMPClause* init_clause = OpenMPInitializerClause::addInitializerClause(
                                    dr_dir, OMPC_INITIALIZER_PRIV_user, persistent_init_expr);

                                // Add to clauses_in_original_order (static methods don't do this automatically)
                                if (init_clause != nullptr && init_clause->getClausePosition() == -1) {
                                    dr_dir->getClausesInOriginalOrder()->push_back(init_clause);
                                    init_clause->setClausePosition(dr_dir->getClausesInOriginalOrder()->size() - 1);
                                }
                            }
                        }
                    }
                }
            }
            free(persistent_param);
        } else if (kind == OMPD_declare_simd) {
            // Parse declare simd parameter: (proc-name) [clauses...]
            // The parameter contains everything after "declare simd"
            OpenMPDeclareSimdDirective* ds_dir = static_cast<OpenMPDeclareSimdDirective*>(dir);
            std::string param_full(persistent_param);

            // Check if it starts with '(' - if so, extract the proc name
            if (!param_full.empty() && param_full[0] == '(') {
                size_t paren_end = param_full.find(')');
                if (paren_end != std::string::npos) {
                    std::string proc_name = param_full.substr(1, paren_end - 1);
                    // Trim whitespace
                    size_t start = proc_name.find_first_not_of(" \t");
                    size_t end = proc_name.find_last_not_of(" \t");
                    if (start != std::string::npos && end != std::string::npos) {
                        proc_name = proc_name.substr(start, end - start + 1);
                    }
                    // Replace empty proc name with non-empty to avoid bad_alloc
                    if (!proc_name.empty()) {
                        // Clear the default empty proc name first
                        ds_dir->addProcName(strdup(proc_name.c_str()));
                    }
                }
            }
            free(persistent_param);
        } else if (kind == OMPD_declare_mapper) {
            // Parse declare mapper parameter: "(default : type var)" or "(id : type var)" or "(type var)"
            OpenMPDeclareMapperDirective* dm_dir = static_cast<OpenMPDeclareMapperDirective*>(dir);
            std::string mapper_spec(persistent_param);

            // Find the last space to separate type from var
            size_t last_space = mapper_spec.rfind(' ');
            if (last_space != std::string::npos) {
                // Include the space in var_part to preserve spacing in toString()
                std::string var_part = mapper_spec.substr(last_space);
                std::string type_part = mapper_spec.substr(0, last_space);

                // Check if there's a single colon (mapper identifier present)
                // Must handle Fortran :: type separator - only single : followed by non-colon is an identifier separator
                size_t colon_pos = std::string::npos;
                for (size_t i = 0; i < type_part.length(); ++i) {
                    if (type_part[i] == ':') {
                        // Check if next char is also ':' (Fortran type separator)
                        if (i + 1 < type_part.length() && type_part[i + 1] == ':') {
                            // Skip the second colon too
                            i++;
                            continue;
                        }
                        // Single colon found - this is the identifier separator
                        colon_pos = i;
                        break;
                    }
                }

                if (colon_pos != std::string::npos) {
                    // Extract identifier
                    std::string id_part = type_part.substr(0, colon_pos);
                    // Trim whitespace
                    size_t id_start = id_part.find_first_not_of(" \t");
                    size_t id_end = id_part.find_last_not_of(" \t");
                    if (id_start != std::string::npos && id_end != std::string::npos) {
                        id_part = id_part.substr(id_start, id_end - id_start + 1);
                    }

                    // Extract type after colon
                    type_part = type_part.substr(colon_pos + 1);
                    size_t type_start = type_part.find_first_not_of(" \t");
                    if (type_start != std::string::npos) {
                        type_part = type_part.substr(type_start);
                    }

                    // Set identifier
                    if (id_part == "default") {
                        dm_dir->setIdentifier(OMPD_DECLARE_MAPPER_IDENTIFIER_default);
                    } else {
                        dm_dir->setIdentifier(OMPD_DECLARE_MAPPER_IDENTIFIER_user);
                        dm_dir->setUserDefinedIdentifier(id_part);
                    }
                } else {
                    // No identifier, just type and var
                    dm_dir->setIdentifier(OMPD_DECLARE_MAPPER_IDENTIFIER_unspecified);
                }

                // Set type and var
                // For Fortran, remove trailing :: from type (ompparser adds it back)
                if (current_lang == Lang_Fortran && type_part.length() >= 2 &&
                    type_part.substr(type_part.length() - 2) == "::") {
                    type_part = type_part.substr(0, type_part.length() - 2);
                    // Trim trailing whitespace after removing ::
                    size_t end = type_part.find_last_not_of(" \t");
                    if (end != std::string::npos) {
                        type_part = type_part.substr(0, end + 1);
                    }
                    // For Fortran, also trim leading whitespace from var (ompparser adds space)
                    size_t start = var_part.find_first_not_of(" \t");
                    if (start != std::string::npos) {
                        var_part = var_part.substr(start);
                    }
                }
                dm_dir->setDeclareMapperType(strdup(type_part.c_str()));
                dm_dir->setDeclareMapperVar(strdup(var_part.c_str()));
            }
            free(persistent_param);
        } else if (kind == OMPD_declare_target || kind == OMPD_begin_declare_target) {
            // Declare target can have a parameter list of variables: "(x,y,z)"
            // This is not a clause, it's the list of variables to be declared as target
            // We need to add it using addExtendedList method (which makes a copy as std::string)
            OpenMPDeclareTargetDirective* dt_dir = static_cast<OpenMPDeclareTargetDirective*>(dir);
            dt_dir->addExtendedList(persistent_param);
            free(persistent_param);
        } else {
            // Free parameter for other directives that don't use it
            free(persistent_param);
        }
    }

    // Convert clauses using ompparser's addOpenMPClause method
    // Extract clause arguments from ROUP to populate ompparser structures
    OmpClauseIterator* iter = roup_directive_clauses_iter(roup_dir);
    if (iter) {
        const OmpClause* roup_clause;
        while (roup_clause_iterator_next(iter, &roup_clause) == 1) {
            int32_t roup_kind_clause = roup_clause_kind(roup_clause);
            OpenMPClauseKind clause_kind = mapRoupToOmpparserClause(roup_kind_clause);

            // Get clause arguments from ROUP
            const char* args = roup_clause_arguments(roup_clause);

            // SPECIAL CASE: For depobj directive, ROUP returns Update (81) instead of DepobjUpdate (89)
            // This is because "update" is context-sensitive and ROUP's parser treats it as atomic update
            // We need to convert it to depobj_update when in depobj directive context
            if (kind == OMPD_depobj && roup_kind_clause == 81) {  // 81 is ROUP_OMPC_update
                clause_kind = OMPC_depobj_update;
            }

            // SPECIAL CASE: For metadirective, ROUP returns Default (2) instead of Otherwise (144)
            // This is because "default" is context-sensitive - in metadirective it's the otherwise selector
            // We need to convert it to otherwise when in metadirective directive context
            if (kind == OMPD_metadirective && roup_kind_clause == 2) {  // 2 is ROUP_OMPC_default
                clause_kind = OMPC_otherwise;
            }

            // Handle special clauses that need structured API calls
            if (clause_kind == OMPC_map) {
                // Map clause needs very special handling - it has modifiers and type
                // Format: "[modifier[,modifier...]:] type: list"
                // For now, we'll parse the type and add the clause using OpenMPMapClause::addMapClause
                // This avoids the varargs issue with std::string construction from nullptr

                OpenMPMapClauseModifier modifier1 = OMPC_MAP_MODIFIER_unspecified;
                OpenMPMapClauseModifier modifier2 = OMPC_MAP_MODIFIER_unspecified;
                OpenMPMapClauseModifier modifier3 = OMPC_MAP_MODIFIER_unspecified;
                OpenMPMapClauseType type = OMPC_MAP_TYPE_unspecified;
                std::string mapper_identifier = "";
                std::string variables_str;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);

                    // Look for type: to, from, tofrom, alloc, release, delete
                    size_t colon_pos = args_str.find(':');
                    if (colon_pos != std::string::npos) {
                        std::string type_and_modifiers = args_str.substr(0, colon_pos);
                        variables_str = args_str.substr(colon_pos + 1);

                        // Trim whitespace from variables
                        variables_str.erase(0, variables_str.find_first_not_of(" \t"));
                        variables_str.erase(variables_str.find_last_not_of(" \t") + 1);

                        // Split type_and_modifiers by comma to get modifiers and type
                        // The last token is the type, others are modifiers
                        std::vector<std::string> tokens;
                        std::stringstream ss(type_and_modifiers);
                        std::string token;
                        while (std::getline(ss, token, ',')) {
                            // Trim token
                            token.erase(0, token.find_first_not_of(" \t"));
                            token.erase(token.find_last_not_of(" \t") + 1);
                            if (!token.empty()) {
                                tokens.push_back(token);
                            }
                        }

                        if (!tokens.empty()) {
                            // Last token is the type
                            std::string type_str = tokens.back();
                            if (type_str == "to") {
                                type = OMPC_MAP_TYPE_to;
                            } else if (type_str == "from") {
                                type = OMPC_MAP_TYPE_from;
                            } else if (type_str == "tofrom") {
                                type = OMPC_MAP_TYPE_tofrom;
                            } else if (type_str == "alloc") {
                                type = OMPC_MAP_TYPE_alloc;
                            } else if (type_str == "release") {
                                type = OMPC_MAP_TYPE_release;
                            } else if (type_str == "delete") {
                                type = OMPC_MAP_TYPE_delete;
                            }

                            // Parse modifiers (if any)
                            for (size_t i = 0; i + 1 < tokens.size(); i++) {
                                OpenMPMapClauseModifier mod = OMPC_MAP_MODIFIER_unspecified;
                                if (tokens[i] == "always") {
                                    mod = OMPC_MAP_MODIFIER_always;
                                } else if (tokens[i] == "close") {
                                    mod = OMPC_MAP_MODIFIER_close;
                                } else if (tokens[i].find("mapper") == 0) {
                                    mod = OMPC_MAP_MODIFIER_mapper;
                                    // Extract mapper identifier: mapper(name)
                                    size_t lparen = tokens[i].find('(');
                                    size_t rparen = tokens[i].find(')');
                                    if (lparen != std::string::npos && rparen != std::string::npos) {
                                        mapper_identifier = tokens[i].substr(lparen + 1, rparen - lparen - 1);
                                    }
                                }

                                if (modifier1 == OMPC_MAP_MODIFIER_unspecified) {
                                    modifier1 = mod;
                                } else if (modifier2 == OMPC_MAP_MODIFIER_unspecified) {
                                    modifier2 = mod;
                                } else if (modifier3 == OMPC_MAP_MODIFIER_unspecified) {
                                    modifier3 = mod;
                                }
                            }
                        }
                    } else {
                        // No colon - might be just a variable list with implicit tofrom
                        type = OMPC_MAP_TYPE_tofrom;
                        variables_str = args_str;
                    }
                }

                // Use static method to add map clause
                OpenMPClause* map_clause = OpenMPMapClause::addMapClause(
                    dir, modifier1, modifier2, modifier3, type, mapper_identifier);

                // Add variables if present
                if (map_clause != nullptr && !variables_str.empty()) {
                    add_list_expressions(map_clause, variables_str.c_str());
                }

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (map_clause != nullptr && map_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(map_clause);
                    map_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_allocator) {
                // Allocator clause needs special handling with enum
                // Map allocator name to enum value
                OpenMPAllocatorClauseAllocator allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_user;
                char* user_allocator = nullptr;

                if (args != nullptr && args[0] != '\0') {
                    std::string allocator_name(args);
                    // Map known allocator names to enum values
                    if (allocator_name == "omp_default_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_default;
                    } else if (allocator_name == "omp_large_cap_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_large_cap;
                    } else if (allocator_name == "omp_const_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_cons_mem;
                    } else if (allocator_name == "omp_high_bw_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_high_bw;
                    } else if (allocator_name == "omp_low_lat_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_low_lat;
                    } else if (allocator_name == "omp_cgroup_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_cgroup;
                    } else if (allocator_name == "omp_pteam_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_pteam;
                    } else if (allocator_name == "omp_thread_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_thread;
                    } else {
                        // User-defined allocator
                        allocator_kind = OMPC_ALLOCATOR_ALLOCATOR_user;
                        user_allocator = strdup(args);
                    }
                }
                dir->addOpenMPClause(OMPC_allocator, allocator_kind, user_allocator);
            } else if (clause_kind == OMPC_reduction || clause_kind == OMPC_in_reduction || clause_kind == OMPC_task_reduction) {
                add_reduction_clause_from_data(dir, roup_clause, clause_kind);
            } else if (clause_kind == OMPC_depend) {
                // Depend clause needs special handling with type and variables
                // Format: "type:var1,var2" or "iterator(...):type:var1,var2"
                OpenMPDependClauseModifier modifier = OMPC_DEPEND_MODIFIER_unspecified;
                OpenMPDependClauseType depend_type = OMPC_DEPENDENCE_TYPE_unknown;
                std::string variables_str;
                std::vector<std::vector<const char*>*> iterators;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);

                    // Check for iterator modifier
                    size_t iterator_pos = args_str.find("iterator");
                    if (iterator_pos != std::string::npos) {
                        modifier = OMPC_DEPEND_MODIFIER_iterator;

                        // Find the opening parenthesis after "iterator"
                        size_t paren_start = args_str.find('(', iterator_pos);
                        if (paren_start != std::string::npos) {
                            size_t paren_depth = 1;
                            size_t i = paren_start + 1;
                            size_t iter_content_start = i;

                            // Find the matching closing parenthesis
                            while (i < args_str.length() && paren_depth > 0) {
                                if (args_str[i] == '(') paren_depth++;
                                else if (args_str[i] == ')') {
                                    paren_depth--;
                                    if (paren_depth == 0) break;
                                }
                                i++;
                            }

                            // Extract iterator content
                            std::string iter_content = args_str.substr(iter_content_start, i - iter_content_start);

                            // Parse iterator definitions: "int bba=4:120:2, char huj=2:677"
                            size_t pos = 0;
                            while (pos < iter_content.length()) {
                                // Skip whitespace
                                while (pos < iter_content.length() && std::isspace(iter_content[pos])) pos++;
                                if (pos >= iter_content.length()) break;

                                // Find the next comma (or end)
                                size_t comma_pos = iter_content.find(',', pos);
                                if (comma_pos == std::string::npos) comma_pos = iter_content.length();

                                std::string one_iterator = iter_content.substr(pos, comma_pos - pos);
                                // Trim the whole iterator string first
                                one_iterator.erase(0, one_iterator.find_first_not_of(" \t"));
                                one_iterator.erase(one_iterator.find_last_not_of(" \t") + 1);

                                // Parse: "type name=begin:end:step" or "type name=begin:end"
                                std::vector<const char*>* iter_def = new std::vector<const char*>();

                                // Find type (everything before the last space before '=')
                                // First, normalize spaces around '=' by removing them
                                size_t eq_pos = one_iterator.find('=');
                                if (eq_pos != std::string::npos) {
                                    std::string before_eq = one_iterator.substr(0, eq_pos);
                                    // Trim trailing spaces before =
                                    before_eq.erase(before_eq.find_last_not_of(" \t") + 1);

                                    size_t last_space = before_eq.find_last_of(" \t");

                                    std::string type_str, name_str;
                                    if (last_space != std::string::npos) {
                                        type_str = before_eq.substr(0, last_space);
                                        name_str = before_eq.substr(last_space + 1);
                                        // Trim type
                                        type_str.erase(0, type_str.find_first_not_of(" \t"));
                                        type_str.erase(type_str.find_last_not_of(" \t") + 1);
                                    } else {
                                        type_str = "";
                                        name_str = before_eq;
                                    }

                                    // Parse range: begin:end:step
                                    std::string range_str = one_iterator.substr(eq_pos + 1);
                                    range_str.erase(0, range_str.find_first_not_of(" \t"));
                                    range_str.erase(range_str.find_last_not_of(" \t") + 1);

                                    size_t colon1 = range_str.find(':');
                                    size_t colon2 = range_str.find(':', colon1 + 1);

                                    std::string begin_str, end_str, step_str;
                                    if (colon1 != std::string::npos) {
                                        begin_str = range_str.substr(0, colon1);
                                        // Trim begin_str
                                        begin_str.erase(0, begin_str.find_first_not_of(" \t"));
                                        begin_str.erase(begin_str.find_last_not_of(" \t") + 1);

                                        if (colon2 != std::string::npos) {
                                            end_str = range_str.substr(colon1 + 1, colon2 - colon1 - 1);
                                            // Trim end_str
                                            end_str.erase(0, end_str.find_first_not_of(" \t"));
                                            end_str.erase(end_str.find_last_not_of(" \t") + 1);

                                            step_str = range_str.substr(colon2 + 1);
                                            // Trim step_str
                                            step_str.erase(0, step_str.find_first_not_of(" \t"));
                                            step_str.erase(step_str.find_last_not_of(" \t") + 1);
                                        } else {
                                            end_str = range_str.substr(colon1 + 1);
                                            // Trim end_str
                                            end_str.erase(0, end_str.find_first_not_of(" \t"));
                                            end_str.erase(end_str.find_last_not_of(" \t") + 1);
                                            step_str = "";
                                        }
                                    }

                                    // Add to iterator definition (5 elements: type, name, begin, end, step)
                                    iter_def->push_back(strdup(type_str.c_str()));
                                    iter_def->push_back(strdup(name_str.c_str()));
                                    iter_def->push_back(strdup(begin_str.c_str()));
                                    iter_def->push_back(strdup(end_str.c_str()));
                                    iter_def->push_back(strdup(step_str.c_str()));

                                    iterators.push_back(iter_def);
                                }

                                pos = comma_pos + 1;
                            }

                            // Skip past iterator(...) to find the type:variables part
                            args_str = args_str.substr(i + 1);
                        }
                    }

                    // Find the type:variables split
                    size_t colon_pos = args_str.find(':');
                    if (colon_pos != std::string::npos) {
                        std::string type_str = args_str.substr(0, colon_pos);
                        // Trim spaces
                        type_str.erase(0, type_str.find_first_not_of(" \t,"));
                        type_str.erase(type_str.find_last_not_of(" \t,") + 1);

                        variables_str = args_str.substr(colon_pos + 1);
                        variables_str.erase(0, variables_str.find_first_not_of(" \t"));
                        variables_str.erase(variables_str.find_last_not_of(" \t") + 1);

                        // Map type string to enum
                        if (type_str == "in") {
                            depend_type = OMPC_DEPENDENCE_TYPE_in;
                        } else if (type_str == "out") {
                            depend_type = OMPC_DEPENDENCE_TYPE_out;
                        } else if (type_str == "inout") {
                            depend_type = OMPC_DEPENDENCE_TYPE_inout;
                        } else if (type_str == "inoutset") {
                            depend_type = OMPC_DEPENDENCE_TYPE_inoutset;
                        } else if (type_str == "mutexinoutset") {
                            depend_type = OMPC_DEPENDENCE_TYPE_mutexinoutset;
                        } else if (type_str == "depobj") {
                            depend_type = OMPC_DEPENDENCE_TYPE_depobj;
                        } else if (type_str == "source") {
                            depend_type = OMPC_DEPENDENCE_TYPE_source;
                        } else if (type_str == "sink") {
                            depend_type = OMPC_DEPENDENCE_TYPE_sink;
                        }
                    } else {
                        // No colon - just a depend type (e.g., "source")
                        std::string type_str = args_str;
                        // Trim spaces
                        type_str.erase(0, type_str.find_first_not_of(" \t,"));
                        type_str.erase(type_str.find_last_not_of(" \t,") + 1);

                        // Map type string to enum
                        if (type_str == "in") {
                            depend_type = OMPC_DEPENDENCE_TYPE_in;
                        } else if (type_str == "out") {
                            depend_type = OMPC_DEPENDENCE_TYPE_out;
                        } else if (type_str == "inout") {
                            depend_type = OMPC_DEPENDENCE_TYPE_inout;
                        } else if (type_str == "inoutset") {
                            depend_type = OMPC_DEPENDENCE_TYPE_inoutset;
                        } else if (type_str == "mutexinoutset") {
                            depend_type = OMPC_DEPENDENCE_TYPE_mutexinoutset;
                        } else if (type_str == "depobj") {
                            depend_type = OMPC_DEPENDENCE_TYPE_depobj;
                        } else if (type_str == "source") {
                            depend_type = OMPC_DEPENDENCE_TYPE_source;
                        } else if (type_str == "sink") {
                            depend_type = OMPC_DEPENDENCE_TYPE_sink;
                        }
                    }
                }

                // Check if a depend clause with the same type, modifier, and iterator already exists
                // Only merge clauses if they have compatible iterators:
                // - Both have no iterator, OR
                // - Both have the same exact iterator (same number and same definitions)
                OpenMPClause* depend_clause = nullptr;
                std::vector<OpenMPClause*>* existing_clauses = dir->getClausesInOriginalOrder();
                for (auto* clause : *existing_clauses) {
                    if (clause->getKind() == OMPC_depend) {
                        OpenMPDependClause* dc = static_cast<OpenMPDependClause*>(clause);
                        if (dc->getType() == depend_type && dc->getModifier() == modifier) {
                            // Check iterator compatibility
                            bool can_merge = false;
                            if (iterators.empty() && dc->getDependIteratorsDefinitionClass()->empty()) {
                                // Both have no iterator - can merge
                                can_merge = true;
                            } else if (!iterators.empty() && !dc->getDependIteratorsDefinitionClass()->empty()) {
                                // Both have iterators - check if they're identical
                                auto* existing_iters = dc->getDependIteratorsDefinitionClass();
                                if (iterators.size() == existing_iters->size()) {
                                    // Same number of iterators - check if they're identical
                                    bool all_match = true;
                                    for (size_t idx = 0; idx < iterators.size() && all_match; ++idx) {
                                        auto* new_iter = iterators[idx];
                                        auto* exist_iter = (*existing_iters)[idx];
                                        // Each iterator has 5 elements: type, name, begin, end, step
                                        if (new_iter->size() != exist_iter->size()) {
                                            all_match = false;
                                        } else {
                                            for (size_t j = 0; j < new_iter->size() && all_match; ++j) {
                                                if (strcmp((*new_iter)[j], (*exist_iter)[j]) != 0) {
                                                    all_match = false;
                                                }
                                            }
                                        }
                                    }
                                    can_merge = all_match;
                                }
                            }

                            if (can_merge) {
                                depend_clause = clause;
                                break;
                            }
                        }
                    }
                }

                // If no existing clause found, create a new one
                if (depend_clause == nullptr) {
                    depend_clause = OpenMPDependClause::addDependClause(dir, modifier, depend_type);

                    // Add iterator definitions if present (only for new clause)
                    if (depend_clause != nullptr && !iterators.empty()) {
                        OpenMPDependClause* typed_clause = static_cast<OpenMPDependClause*>(depend_clause);
                        typed_clause->setDependIteratorsDefinitionClass(&iterators);
                    }

                    // Add to clauses_in_original_order (static methods don't do this automatically)
                    if (depend_clause != nullptr && depend_clause->getClausePosition() == -1) {
                        dir->getClausesInOriginalOrder()->push_back(depend_clause);
                        depend_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                    }
                }

                // Add variables to the clause (new or existing)
                if (depend_clause != nullptr && !variables_str.empty()) {
                    // For depend clause, we need to add the variables as lang expressions
                    // Not as dependence vector (that's only for sink type)
                    if (depend_type == OMPC_DEPENDENCE_TYPE_sink) {
                        OpenMPDependClause* typed_clause = static_cast<OpenMPDependClause*>(depend_clause);
                        typed_clause->addDependenceVector(strdup(variables_str.c_str()));
                    } else {
                        // For non-sink depend types, add variables as expressions
                        add_list_expressions(depend_clause, variables_str.c_str());
                    }
                }
            } else if (clause_kind == OMPC_lastprivate) {
                // Lastprivate clause needs special handling for conditional modifier
                // Format: "conditional: var1, var2" or just "var1, var2"
                OpenMPLastprivateClauseModifier modifier = OMPC_LASTPRIVATE_MODIFIER_unspecified;
                std::string variables_str;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    size_t colon_pos = args_str.find(':');

                    if (colon_pos != std::string::npos) {
                        // Has modifier
                        std::string modifier_str = args_str.substr(0, colon_pos);
                        modifier_str.erase(0, modifier_str.find_first_not_of(" \t"));
                        modifier_str.erase(modifier_str.find_last_not_of(" \t") + 1);

                        variables_str = args_str.substr(colon_pos + 1);

                        if (modifier_str == "conditional") {
                            modifier = OMPC_LASTPRIVATE_MODIFIER_conditional;
                        }
                    } else {
                        // No modifier
                        variables_str = args_str;
                    }
                }

                // Create clause with modifier
                OpenMPClause* lp_clause = OpenMPLastprivateClause::addLastprivateClause(dir, modifier);

                // Add variables with proper formatting
                if (lp_clause != nullptr && !variables_str.empty()) {
                    std::string formatted = format_clause_args(variables_str.c_str(), true);
                    add_list_expressions(lp_clause, formatted.c_str());
                }

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (lp_clause != nullptr && lp_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(lp_clause);
                    lp_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_linear) {
                // Linear clause needs special handling for modifier and step
                // Format: "modifier(vars):step" or "vars:step" or just "vars"
                OpenMPLinearClauseModifier modifier = OMPC_LINEAR_MODIFIER_unspecified;
                std::string variables_str;
                std::string step_str;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);

                    // Check for modifier: val(), ref(), uval()
                    if (args_str.find("val(") == 0) {
                        modifier = OMPC_LINEAR_MODIFIER_val;
                        // Extract content inside val(...)
                        size_t start = 4;  // after "val("
                        size_t end = args_str.find(')', start);
                        if (end != std::string::npos) {
                            variables_str = args_str.substr(start, end - start);
                            // Check for step after closing paren
                            if (end + 1 < args_str.length() && args_str[end + 1] == ':') {
                                step_str = args_str.substr(end + 2);
                            }
                        }
                    } else if (args_str.find("ref(") == 0) {
                        modifier = OMPC_LINEAR_MODIFIER_ref;
                        size_t start = 4;
                        size_t end = args_str.find(')', start);
                        if (end != std::string::npos) {
                            variables_str = args_str.substr(start, end - start);
                            if (end + 1 < args_str.length() && args_str[end + 1] == ':') {
                                step_str = args_str.substr(end + 2);
                            }
                        }
                    } else if (args_str.find("uval(") == 0) {
                        modifier = OMPC_LINEAR_MODIFIER_uval;
                        size_t start = 5;
                        size_t end = args_str.find(')', start);
                        if (end != std::string::npos) {
                            variables_str = args_str.substr(start, end - start);
                            if (end + 1 < args_str.length() && args_str[end + 1] == ':') {
                                step_str = args_str.substr(end + 2);
                            }
                        }
                    } else {
                        // No modifier - check for step with colon
                        size_t colon_pos = args_str.rfind(':');  // Find last colon
                        if (colon_pos != std::string::npos) {
                            variables_str = args_str.substr(0, colon_pos);
                            step_str = args_str.substr(colon_pos + 1);
                        } else {
                            variables_str = args_str;
                        }
                    }
                }

                // Check if we can merge with an existing linear clause with the same modifier and step
                OpenMPClause* linear_clause = nullptr;
                OpenMPLinearClause* typed_linear = nullptr;

                // Trim step string for comparison
                std::string trimmed_step = step_str;
                trimmed_step.erase(0, trimmed_step.find_first_not_of(" \t"));
                trimmed_step.erase(trimmed_step.find_last_not_of(" \t") + 1);

                // Look for existing linear clause with same modifier and step
                std::map<OpenMPClauseKind, std::vector<OpenMPClause*>*>* all_clauses = dir->getAllClauses();
                if (all_clauses != nullptr) {
                    auto it = all_clauses->find(OMPC_linear);
                    if (it != all_clauses->end() && it->second != nullptr) {
                        for (OpenMPClause* clause : *(it->second)) {
                            OpenMPLinearClause* existing_linear = static_cast<OpenMPLinearClause*>(clause);
                            if (existing_linear != nullptr) {
                                // Check if modifier matches
                                if (existing_linear->getModifier() == modifier) {
                                    // Check if step matches
                                    std::string existing_step = existing_linear->getUserDefinedStep();
                                    if (existing_step == trimmed_step) {
                                        // Found a match - use this clause
                                        linear_clause = clause;
                                        typed_linear = existing_linear;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // If no existing clause found, create a new one
                if (linear_clause == nullptr) {
                    linear_clause = OpenMPLinearClause::addLinearClause(dir, modifier);
                    typed_linear = static_cast<OpenMPLinearClause*>(linear_clause);

                    // Set syntax flag: true if modifier(vars), false if vars or vars:step
                    if (typed_linear && modifier != OMPC_LINEAR_MODIFIER_unspecified) {
                        typed_linear->setModifierFirstSyntax(true);
                    }

                    // Set step using the special method (not addLangExpr)
                    if (typed_linear && !trimmed_step.empty()) {
                        typed_linear->setUserDefinedStep(trimmed_step.c_str());
                    }

                    // Add to clauses_in_original_order (static methods don't do this automatically)
                    if (linear_clause != nullptr && linear_clause->getClausePosition() == -1) {
                        dir->getClausesInOriginalOrder()->push_back(linear_clause);
                        linear_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                    }
                }

                // Add variables with proper formatting (to new or existing clause)
                if (linear_clause != nullptr && !variables_str.empty()) {
                    std::string formatted_vars = format_clause_args(variables_str.c_str(), false);
                    add_list_expressions(linear_clause, formatted_vars.c_str());
                }
            } else if (clause_kind == OMPC_allocate && args != nullptr && args[0] != '\0') {
                // Allocate clause can have allocator:variables or just variables
                // Format: "allocator: var1, var2" or "var1, var2"
                std::string args_str(args);
                size_t colon_pos = args_str.find(':');

                if (colon_pos != std::string::npos) {
                    // Has allocator specification
                    std::string allocator_str = args_str.substr(0, colon_pos);
                    allocator_str.erase(0, allocator_str.find_first_not_of(" \t"));
                    allocator_str.erase(allocator_str.find_last_not_of(" \t") + 1);

                    std::string variables_str = args_str.substr(colon_pos + 1);

                    // Map allocator name to enum
                    OpenMPAllocateClauseAllocator allocator_kind = OMPC_ALLOCATE_ALLOCATOR_user;
                    char* user_allocator = nullptr;

                    if (allocator_str == "omp_default_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_default;
                    } else if (allocator_str == "omp_large_cap_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_large_cap;
                    } else if (allocator_str == "omp_const_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_cons_mem;
                    } else if (allocator_str == "omp_high_bw_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_high_bw;
                    } else if (allocator_str == "omp_low_lat_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_low_lat;
                    } else if (allocator_str == "omp_cgroup_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_cgroup;
                    } else if (allocator_str == "omp_pteam_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_pteam;
                    } else if (allocator_str == "omp_thread_mem_alloc") {
                        allocator_kind = OMPC_ALLOCATE_ALLOCATOR_thread;
                    } else {
                        // User-defined allocator
                        user_allocator = strdup(allocator_str.c_str());
                    }

                    OpenMPClause* alloc_clause = OpenMPAllocateClause::addAllocateClause(
                        dir, allocator_kind, user_allocator);

                    // Add variables with proper formatting
                    if (alloc_clause != nullptr && !variables_str.empty()) {
                        std::string formatted = format_clause_args(variables_str.c_str(), true);
                        add_list_expressions(alloc_clause, formatted.c_str());
                    }

                    // Add to clauses_in_original_order (static methods don't do this automatically)
                    if (alloc_clause != nullptr && alloc_clause->getClausePosition() == -1) {
                        dir->getClausesInOriginalOrder()->push_back(alloc_clause);
                        alloc_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                    }
                } else {
                    // No allocator - just variables
                    OpenMPClause* alloc_clause = dir->addOpenMPClause(OMPC_allocate, "");
                    if (alloc_clause != nullptr) {
                        std::string formatted = format_clause_args(args, false);
                        add_list_expressions(alloc_clause, formatted.c_str());
                    }
                }
            } else if (clause_kind == OMPC_order) {
                // Order clause: order(concurrent) or order(reproducible:concurrent)
                OpenMPOrderClauseModifier modifier = OMPC_ORDER_MODIFIER_unspecified;
                OpenMPOrderClauseKind kind = OMPC_ORDER_unspecified;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    size_t colon_pos = args_str.find(':');

                    if (colon_pos != std::string::npos) {
                        // Has modifier
                        std::string modifier_str = args_str.substr(0, colon_pos);
                        modifier_str.erase(0, modifier_str.find_first_not_of(" \t"));
                        modifier_str.erase(modifier_str.find_last_not_of(" \t") + 1);

                        std::string kind_str = args_str.substr(colon_pos + 1);
                        kind_str.erase(0, kind_str.find_first_not_of(" \t"));
                        kind_str.erase(kind_str.find_last_not_of(" \t") + 1);

                        if (modifier_str == "reproducible") {
                            modifier = OMPC_ORDER_MODIFIER_reproducible;
                        } else if (modifier_str == "unconstrained") {
                            modifier = OMPC_ORDER_MODIFIER_unconstrained;
                        }

                        if (kind_str == "concurrent") {
                            kind = OMPC_ORDER_concurrent;
                        }
                    } else {
                        // No modifier
                        std::string kind_str = args_str;
                        kind_str.erase(0, kind_str.find_first_not_of(" \t"));
                        kind_str.erase(kind_str.find_last_not_of(" \t") + 1);

                        if (kind_str == "concurrent") {
                            kind = OMPC_ORDER_concurrent;
                        }
                    }
                }

                // Create order clause
                OpenMPClause* order_clause = nullptr;
                if (modifier != OMPC_ORDER_MODIFIER_unspecified) {
                    order_clause = OpenMPOrderClause::addOrderClause(dir, modifier, kind);
                } else {
                    order_clause = OpenMPOrderClause::addOrderClause(dir, kind);
                }

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (order_clause != nullptr && order_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(order_clause);
                    order_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_schedule) {
                // Schedule clause: schedule([modifier[,modifier]:]kind[,chunk])
                // Format: "monotonic,simd:runtime,2" or "runtime,2" or "static"
                OpenMPScheduleClauseModifier modifier1 = OMPC_SCHEDULE_MODIFIER_unspecified;
                OpenMPScheduleClauseModifier modifier2 = OMPC_SCHEDULE_MODIFIER_unspecified;
                OpenMPScheduleClauseKind kind = OMPC_SCHEDULE_KIND_unspecified;
                std::string chunk_size;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);

                    // Check for modifiers (before colon)
                    size_t colon_pos = args_str.find(':');
                    std::string kind_and_chunk;

                    if (colon_pos != std::string::npos) {
                        // Has modifiers
                        std::string modifiers_str = args_str.substr(0, colon_pos);
                        kind_and_chunk = args_str.substr(colon_pos + 1);

                        // Parse modifiers (comma-separated)
                        std::vector<std::string> modifiers;
                        std::stringstream ss(modifiers_str);
                        std::string mod;
                        while (std::getline(ss, mod, ',')) {
                            mod.erase(0, mod.find_first_not_of(" \t"));
                            mod.erase(mod.find_last_not_of(" \t") + 1);
                            if (!mod.empty()) {
                                modifiers.push_back(mod);
                            }
                        }

                        // Map modifiers to enums
                        for (size_t i = 0; i < modifiers.size() && i < 2; i++) {
                            OpenMPScheduleClauseModifier m = OMPC_SCHEDULE_MODIFIER_unspecified;
                            if (modifiers[i] == "monotonic") {
                                m = OMPC_SCHEDULE_MODIFIER_monotonic;
                            } else if (modifiers[i] == "nonmonotonic") {
                                m = OMPC_SCHEDULE_MODIFIER_nonmonotonic;
                            } else if (modifiers[i] == "simd") {
                                m = OMPC_SCHEDULE_MODIFIER_simd;
                            }

                            if (i == 0) {
                                modifier1 = m;
                            } else {
                                modifier2 = m;
                            }
                        }
                    } else {
                        // No modifiers
                        kind_and_chunk = args_str;
                    }

                    // Parse kind and chunk (comma-separated)
                    size_t comma_pos = kind_and_chunk.find(',');
                    std::string kind_str;

                    if (comma_pos != std::string::npos) {
                        kind_str = kind_and_chunk.substr(0, comma_pos);
                        chunk_size = kind_and_chunk.substr(comma_pos + 1);
                        // Trim
                        chunk_size.erase(0, chunk_size.find_first_not_of(" \t"));
                        chunk_size.erase(chunk_size.find_last_not_of(" \t") + 1);
                    } else {
                        kind_str = kind_and_chunk;
                    }

                    // Trim kind
                    kind_str.erase(0, kind_str.find_first_not_of(" \t"));
                    kind_str.erase(kind_str.find_last_not_of(" \t") + 1);

                    // Map kind to enum
                    if (kind_str == "static") {
                        kind = OMPC_SCHEDULE_KIND_static;
                    } else if (kind_str == "dynamic") {
                        kind = OMPC_SCHEDULE_KIND_dynamic;
                    } else if (kind_str == "guided") {
                        kind = OMPC_SCHEDULE_KIND_guided;
                    } else if (kind_str == "auto") {
                        kind = OMPC_SCHEDULE_KIND_auto;
                    } else if (kind_str == "runtime") {
                        kind = OMPC_SCHEDULE_KIND_runtime;
                    }
                }

                // Create schedule clause
                OpenMPClause* schedule_clause = OpenMPScheduleClause::addScheduleClause(
                    dir, modifier1, modifier2, kind, nullptr);

                // Set chunk size if present
                if (schedule_clause != nullptr && !chunk_size.empty()) {
                    OpenMPScheduleClause* typed_schedule = static_cast<OpenMPScheduleClause*>(schedule_clause);
                    typed_schedule->setChunkSize(chunk_size.c_str());
                }

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (schedule_clause != nullptr && schedule_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(schedule_clause);
                    schedule_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_dist_schedule) {
                // Dist_schedule clause: dist_schedule(kind[,chunk])
                // Format: "static,2" or "static"
                OpenMPDistScheduleClauseKind kind = OMPC_DIST_SCHEDULE_KIND_static;
                std::string chunk_size;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);

                    // Parse kind and chunk (comma-separated)
                    size_t comma_pos = args_str.find(',');
                    std::string kind_str;

                    if (comma_pos != std::string::npos) {
                        kind_str = args_str.substr(0, comma_pos);
                        chunk_size = args_str.substr(comma_pos + 1);
                        // Trim
                        chunk_size.erase(0, chunk_size.find_first_not_of(" \t"));
                        chunk_size.erase(chunk_size.find_last_not_of(" \t") + 1);
                    } else {
                        kind_str = args_str;
                    }

                    // Trim kind
                    kind_str.erase(0, kind_str.find_first_not_of(" \t"));
                    kind_str.erase(kind_str.find_last_not_of(" \t") + 1);

                    // Map kind to enum
                    if (kind_str == "static") {
                        kind = OMPC_DIST_SCHEDULE_KIND_static;
                    } else {
                        // User-defined or other
                        kind = OMPC_DIST_SCHEDULE_KIND_user;
                    }
                }

                // Create dist_schedule clause
                OpenMPClause* dist_schedule_clause = OpenMPDistScheduleClause::addDistScheduleClause(dir, kind);

                // Set chunk size if present
                if (dist_schedule_clause != nullptr && !chunk_size.empty()) {
                    OpenMPDistScheduleClause* typed_dist_schedule = static_cast<OpenMPDistScheduleClause*>(dist_schedule_clause);
                    typed_dist_schedule->setChunkSize(chunk_size.c_str());
                }

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (dist_schedule_clause != nullptr && dist_schedule_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(dist_schedule_clause);
                    dist_schedule_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_if) {
                // If clause needs special handling for directive-name modifiers
                // Format: "modifier: condition" or just "condition"
                OpenMPIfClauseModifier modifier = OMPC_IF_MODIFIER_unspecified;
                char* condition = nullptr;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    size_t colon_pos = args_str.find(':');

                    if (colon_pos != std::string::npos) {
                        // Has modifier: "modifier: condition"
                        std::string modifier_str = args_str.substr(0, colon_pos);
                        // Trim spaces
                        modifier_str.erase(0, modifier_str.find_first_not_of(" \t"));
                        modifier_str.erase(modifier_str.find_last_not_of(" \t") + 1);

                        std::string condition_str = args_str.substr(colon_pos + 1);
                        condition_str.erase(0, condition_str.find_first_not_of(" \t"));
                        condition_str.erase(condition_str.find_last_not_of(" \t") + 1);

                        // Map modifier string to enum
                        if (modifier_str == "parallel") {
                            modifier = OMPC_IF_MODIFIER_parallel;
                        } else if (modifier_str == "task") {
                            modifier = OMPC_IF_MODIFIER_task;
                        } else if (modifier_str == "taskloop") {
                            modifier = OMPC_IF_MODIFIER_taskloop;
                        } else if (modifier_str == "target") {
                            modifier = OMPC_IF_MODIFIER_target;
                        } else if (modifier_str == "target data") {
                            modifier = OMPC_IF_MODIFIER_target_data;
                        } else if (modifier_str == "target enter data") {
                            modifier = OMPC_IF_MODIFIER_target_enter_data;
                        } else if (modifier_str == "target exit data") {
                            modifier = OMPC_IF_MODIFIER_target_exit_data;
                        } else if (modifier_str == "target update") {
                            modifier = OMPC_IF_MODIFIER_target_update;
                        } else if (modifier_str == "simd") {
                            modifier = OMPC_IF_MODIFIER_simd;
                        } else if (modifier_str == "cancel") {
                            modifier = OMPC_IF_MODIFIER_cancel;
                        } else {
                            modifier = OMPC_IF_MODIFIER_user;
                        }

                        condition = strdup(condition_str.c_str());
                    } else {
                        // No modifier, just condition
                        condition = strdup(args);
                    }
                }

                OpenMPClause* if_clause = dir->addOpenMPClause(OMPC_if, modifier);
                if (if_clause != nullptr && condition != nullptr) {
                    if_clause->addLangExpr(condition);
                }
            } else if (clause_kind == OMPC_default) {
                // Default clause needs enum-based parameter (shared, none, private, firstprivate)
                OpenMPDefaultClauseKind default_kind = OMPC_DEFAULT_unknown;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Trim spaces
                    args_str.erase(0, args_str.find_first_not_of(" \t"));
                    args_str.erase(args_str.find_last_not_of(" \t") + 1);

                    // Map string to enum
                    if (args_str == "shared") {
                        default_kind = OMPC_DEFAULT_shared;
                    } else if (args_str == "none") {
                        default_kind = OMPC_DEFAULT_none;
                    } else if (args_str == "private") {
                        default_kind = OMPC_DEFAULT_private;
                    } else if (args_str == "firstprivate") {
                        default_kind = OMPC_DEFAULT_firstprivate;
                    }
                }

                // Create clause with proper enum
                OpenMPClause* default_clause = OpenMPDefaultClause::addDefaultClause(dir, default_kind);

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (default_clause != nullptr && default_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(default_clause);
                    default_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_atomic_default_mem_order) {
                // atomic_default_mem_order clause needs enum-based parameter (seq_cst, acq_rel, relaxed)
                OpenMPAtomicDefaultMemOrderClauseKind atomic_kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Trim spaces
                    args_str.erase(0, args_str.find_first_not_of(" \t"));
                    args_str.erase(args_str.find_last_not_of(" \t") + 1);

                    // Map string to enum
                    if (args_str == "seq_cst") {
                        atomic_kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_seq_cst;
                    } else if (args_str == "acq_rel") {
                        atomic_kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_acq_rel;
                    } else if (args_str == "relaxed") {
                        atomic_kind = OMPC_ATOMIC_DEFAULT_MEM_ORDER_relaxed;
                    }
                }

                // Create clause with proper enum
                OpenMPClause* atomic_clause = OpenMPAtomicDefaultMemOrderClause::addAtomicDefaultMemOrderClause(dir, atomic_kind);

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (atomic_clause != nullptr && atomic_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(atomic_clause);
                    atomic_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_proc_bind) {
                // Proc_bind clause needs enum-based parameter (master, primary, close, spread)
                OpenMPProcBindClauseKind proc_bind_kind = OMPC_PROC_BIND_unknown;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Trim spaces
                    args_str.erase(0, args_str.find_first_not_of(" \t"));
                    args_str.erase(args_str.find_last_not_of(" \t") + 1);

                    // Map string to enum
                    if (args_str == "master") {
                        proc_bind_kind = OMPC_PROC_BIND_master;
                    } else if (args_str == "primary") {
                        proc_bind_kind = OMPC_PROC_BIND_primary;
                    } else if (args_str == "close") {
                        proc_bind_kind = OMPC_PROC_BIND_close;
                    } else if (args_str == "spread") {
                        proc_bind_kind = OMPC_PROC_BIND_spread;
                    }
                }

                // Create clause with proper enum
                OpenMPClause* proc_bind_clause = OpenMPProcBindClause::addProcBindClause(dir, proc_bind_kind);

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (proc_bind_clause != nullptr && proc_bind_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(proc_bind_clause);
                    proc_bind_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_device_type) {
                // Device_type clause needs enum-based parameter (host, nohost, any)
                OpenMPDeviceTypeClauseKind device_type_kind = OMPC_DEVICE_TYPE_unknown;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Trim spaces
                    args_str.erase(0, args_str.find_first_not_of(" \t"));
                    args_str.erase(args_str.find_last_not_of(" \t") + 1);

                    // Map string to enum
                    if (args_str == "host") {
                        device_type_kind = OMPC_DEVICE_TYPE_host;
                    } else if (args_str == "nohost") {
                        device_type_kind = OMPC_DEVICE_TYPE_nohost;
                    } else if (args_str == "any") {
                        device_type_kind = OMPC_DEVICE_TYPE_any;
                    }
                }

                // Create clause with proper enum
                OpenMPClause* device_type_clause = OpenMPDeviceTypeClause::addDeviceTypeClause(dir, device_type_kind);

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (device_type_clause != nullptr && device_type_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(device_type_clause);
                    device_type_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_bind) {
                // Bind clause needs enum-based parameter (teams, parallel, thread, user)
                OpenMPBindClauseBinding bind_binding = OMPC_BIND_unknown;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Trim spaces
                    args_str.erase(0, args_str.find_first_not_of(" \t"));
                    args_str.erase(args_str.find_last_not_of(" \t") + 1);

                    // Map string to enum
                    if (args_str == "teams") {
                        bind_binding = OMPC_BIND_teams;
                    } else if (args_str == "parallel") {
                        bind_binding = OMPC_BIND_parallel;
                    } else if (args_str == "thread") {
                        bind_binding = OMPC_BIND_thread;
                    } else if (args_str == "user") {
                        bind_binding = OMPC_BIND_user;
                    }
                }

                // Create clause with proper enum
                OpenMPClause* bind_clause = OpenMPBindClause::addBindClause(dir, bind_binding);

                // Add to clauses_in_original_order (static methods don't do this automatically)
                if (bind_clause != nullptr && bind_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(bind_clause);
                    bind_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_device) {
                // Device clause needs modifier (ancestor, device_num) and expression
                // Format: "modifier:expression" or just "expression"
                OpenMPDeviceClauseModifier modifier = OMPC_DEVICE_MODIFIER_unspecified;
                char* device_expr = nullptr;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    size_t colon_pos = args_str.find(':');

                    if (colon_pos != std::string::npos) {
                        // Has modifier
                        std::string modifier_str = args_str.substr(0, colon_pos);
                        modifier_str.erase(0, modifier_str.find_first_not_of(" \t"));
                        modifier_str.erase(modifier_str.find_last_not_of(" \t") + 1);

                        std::string expr_str = args_str.substr(colon_pos + 1);
                        expr_str.erase(0, expr_str.find_first_not_of(" \t"));
                        expr_str.erase(expr_str.find_last_not_of(" \t") + 1);

                        if (modifier_str == "ancestor") {
                            modifier = OMPC_DEVICE_MODIFIER_ancestor;
                        } else if (modifier_str == "device_num") {
                            modifier = OMPC_DEVICE_MODIFIER_device_num;
                        }

                        device_expr = strdup(expr_str.c_str());
                    } else {
                        // No modifier, just expression
                        device_expr = strdup(args);
                    }
                }

                // Create clause with proper modifier
                OpenMPClause* device_clause = OpenMPDeviceClause::addDeviceClause(dir, modifier);

                // Add expression
                if (device_clause != nullptr && device_expr != nullptr) {
                    device_clause->addLangExpr(device_expr);
                }

                // Add to clauses_in_original_order
                if (device_clause != nullptr && device_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(device_clause);
                    device_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_defaultmap) {
                // Defaultmap clause: defaultmap(behavior[:category])
                // Pull strongly-typed values from ROUP instead of re-parsing strings.
                OpenMPDefaultmapClauseBehavior behavior = OMPC_DEFAULTMAP_BEHAVIOR_unspecified;
                OpenMPDefaultmapClauseCategory category = OMPC_DEFAULTMAP_CATEGORY_unspecified;

                if (const OmpClause* c = roup_clause_iterator_current(roup_clause)) {
                    int32_t b = roup_clause_defaultmap_behavior(c);
                    int32_t cat = roup_clause_defaultmap_category(c);
                    if (b >= 0) behavior = static_cast<OpenMPDefaultmapClauseBehavior>(b);
                    if (cat >= 0) category = static_cast<OpenMPDefaultmapClauseCategory>(cat);
                }

                // Create clause with proper enums
                OpenMPClause* defaultmap_clause = OpenMPDefaultmapClause::addDefaultmapClause(dir, behavior, category);

                // Add to clauses_in_original_order
                if (defaultmap_clause != nullptr && defaultmap_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(defaultmap_clause);
                    defaultmap_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_depobj_update) {
                // Depobj_update clause: update(in|out|inout|inoutset|mutexinoutset|depobj|sink|source)
                // Map the argument to the appropriate enum value
                OpenMPDepobjUpdateClauseDependeceType depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_unknown;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Trim spaces
                    args_str.erase(0, args_str.find_first_not_of(" \t"));
                    args_str.erase(args_str.find_last_not_of(" \t") + 1);

                    // Map string to enum
                    if (args_str == "in") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_in;
                    } else if (args_str == "out") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_out;
                    } else if (args_str == "inout") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_inout;
                    } else if (args_str == "inoutset") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_inoutset;
                    } else if (args_str == "mutexinoutset") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_mutexinoutset;
                    } else if (args_str == "depobj") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_depobj;
                    } else if (args_str == "sink") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_sink;
                    } else if (args_str == "source") {
                        depobj_type = OMPC_DEPOBJ_UPDATE_DEPENDENCE_TYPE_source;
                    }
                }

                // Create clause with proper enum - use the varargs version
                dir->addOpenMPClause(OMPC_depobj_update, depobj_type);
            } else if (clause_kind == OMPC_uses_allocators) {
                // Uses_allocators clause: uses_allocators(allocator[(traits)], allocator[(traits)], ...)
                // Example: uses_allocators(omp_default_mem_alloc(1234567),omp_const_mem_alloc(234))
                OpenMPClause* uses_alloc_clause = OpenMPUsesAllocatorsClause::addUsesAllocatorsClause(dir);

                if (uses_alloc_clause != nullptr && roup_clause_uses_allocators_count(roup_clause) > 0) {
                    OpenMPUsesAllocatorsClause* typed_clause = static_cast<OpenMPUsesAllocatorsClause*>(uses_alloc_clause);

                    int32_t count = roup_clause_uses_allocators_count(roup_clause);
                    for (int32_t i = 0; i < count; ++i) {
                        int32_t kind_code = roup_clause_uses_allocator_kind(roup_clause, i);
                        const char* user_name = roup_clause_uses_allocator_user(roup_clause, i);
                        const char* traits = roup_clause_uses_allocator_traits(roup_clause, i);

                        OpenMPUsesAllocatorsClauseAllocator allocator = OMPC_USESALLOCATORS_ALLOCATOR_unspecified;
                        switch (kind_code) {
                            case ROUPO_USES_ALLOC_DEFAULT: allocator = OMPC_USESALLOCATORS_ALLOCATOR_default; break;
                            case ROUPO_USES_ALLOC_LARGE_CAP: allocator = OMPC_USESALLOCATORS_ALLOCATOR_large_cap; break;
                            case ROUPO_USES_ALLOC_CONST: allocator = OMPC_USESALLOCATORS_ALLOCATOR_cons_mem; break;
                            case ROUPO_USES_ALLOC_HIGH_BW: allocator = OMPC_USESALLOCATORS_ALLOCATOR_high_bw; break;
                            case ROUPO_USES_ALLOC_LOW_LAT: allocator = OMPC_USESALLOCATORS_ALLOCATOR_low_lat; break;
                            case ROUPO_USES_ALLOC_CGROUP: allocator = OMPC_USESALLOCATORS_ALLOCATOR_cgroup; break;
                            case ROUPO_USES_ALLOC_PTEAM: allocator = OMPC_USESALLOCATORS_ALLOCATOR_pteam; break;
                            case ROUPO_USES_ALLOC_THREAD: allocator = OMPC_USESALLOCATORS_ALLOCATOR_thread; break;
                            case ROUPO_USES_ALLOC_USER: allocator = OMPC_USESALLOCATORS_ALLOCATOR_user; break;
                            default: allocator = OMPC_USESALLOCATORS_ALLOCATOR_unspecified; break;
                        }

                        std::string traits_str = (traits != nullptr) ? std::string(traits) : std::string();
                        std::string user_str = (user_name != nullptr) ? std::string(user_name) : std::string();
                        typed_clause->addUsesAllocatorsAllocatorSequence(allocator, traits_str, user_str);
                    }
                }

                // Add to clauses_in_original_order
                if (uses_alloc_clause != nullptr && uses_alloc_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(uses_alloc_clause);
                    uses_alloc_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_requires) {
                // Requires clause: collect modifiers from ROUP (enum-based, no string parsing)
                int32_t count = roup_clause_requires_count(roup_clause);
                std::string args;
                for (int32_t i = 0; i < count; ++i) {
                    int32_t mod = roup_clause_requires_modifier(roup_clause, i);
                    const char* name = roup_requires_modifier_name(mod);
                    if (name == nullptr) continue;
                    if (!args.empty()) args.append(", ");
                    args.append(name);
                }

                OpenMPClause* req_clause = dir->addOpenMPClause(OMPC_requires);
                if (req_clause != nullptr && !args.empty()) {
                    req_clause->addLangExpr(strdup(args.c_str()));
                }
                if (req_clause != nullptr && req_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(req_clause);
                    req_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_ext_implementation_defined_requirement) {
                // Extension/user-defined clauses: The clause name is passed as the argument
                // Create the clause and set the requirement name
                OpenMPClause* ext_clause = OpenMPExtImplementationDefinedRequirementClause::addExtImplementationDefinedRequirementClause(dir);

                if (ext_clause != nullptr && args != nullptr && args[0] != '\0') {
                    OpenMPExtImplementationDefinedRequirementClause* typed_clause =
                        static_cast<OpenMPExtImplementationDefinedRequirementClause*>(ext_clause);

                    // The args contains the full clause name (possibly with parentheses for extensions with arguments)
                    // For bare extensions like "ext_user_test", args is just the name
                    // For extensions with args like "ext_foo(bar)", args is "ext_foo(bar)"
                    typed_clause->setImplementationDefinedRequirement(args);
                }

                // Add to clauses_in_original_order
                if (ext_clause != nullptr && ext_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(ext_clause);
                    ext_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_grainsize) {
                // Grainsize clause with optional "strict:" modifier
                // Format: "strict: expr" or just "expr"
                OpenMPGrainsizeClauseModifier modifier = OMPC_GRAINSIZE_MODIFIER_unspecified;
                std::string expr_str;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Check for "strict:" prefix
                    if (args_str.find("strict:") == 0 || args_str.find("strict :") == 0) {
                        modifier = OMPC_GRAINSIZE_MODIFIER_strict;
                        // Extract expression after "strict:"
                        size_t colon_pos = args_str.find(':');
                        if (colon_pos != std::string::npos) {
                            expr_str = args_str.substr(colon_pos + 1);
                            // Trim leading spaces
                            size_t start = expr_str.find_first_not_of(" \t");
                            if (start != std::string::npos) {
                                expr_str = expr_str.substr(start);
                            }
                        }
                    } else {
                        expr_str = args_str;
                    }
                }

                // Create grainsize clause with modifier using varargs API
                OpenMPClause* grainsize_clause = dir->addOpenMPClause(OMPC_grainsize, modifier);

                // Add expression
                if (grainsize_clause != nullptr && !expr_str.empty()) {
                    grainsize_clause->addLangExpr(strdup(expr_str.c_str()));
                }

                // Add to clauses_in_original_order
                if (grainsize_clause != nullptr && grainsize_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(grainsize_clause);
                    grainsize_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_num_tasks) {
                // Num_tasks clause with optional "strict:" modifier
                // Format: "strict: expr" or just "expr"
                OpenMPNumTasksClauseModifier modifier = OMPC_NUM_TASKS_MODIFIER_unspecified;
                std::string expr_str;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);
                    // Check for "strict:" prefix
                    if (args_str.find("strict:") == 0 || args_str.find("strict :") == 0) {
                        modifier = OMPC_NUM_TASKS_MODIFIER_strict;
                        // Extract expression after "strict:"
                        size_t colon_pos = args_str.find(':');
                        if (colon_pos != std::string::npos) {
                            expr_str = args_str.substr(colon_pos + 1);
                            // Trim leading spaces
                            size_t start = expr_str.find_first_not_of(" \t");
                            if (start != std::string::npos) {
                                expr_str = expr_str.substr(start);
                            }
                        }
                    } else {
                        expr_str = args_str;
                    }
                }

                // Create num_tasks clause with modifier using varargs API
                OpenMPClause* num_tasks_clause = dir->addOpenMPClause(OMPC_num_tasks, modifier);

                // Add expression
                if (num_tasks_clause != nullptr && !expr_str.empty()) {
                    num_tasks_clause->addLangExpr(strdup(expr_str.c_str()));
                }

                // Add to clauses_in_original_order
                if (num_tasks_clause != nullptr && num_tasks_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(num_tasks_clause);
                    num_tasks_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else if (clause_kind == OMPC_affinity) {
                // Affinity clause needs special handling for iterator
                // Format: "iterator(type var=begin:end:step, ...):variables"
                OpenMPAffinityClauseModifier modifier = OMPC_AFFINITY_MODIFIER_unspecified;
                std::vector<std::vector<const char*>*> iterators;
                std::string variables_str;

                if (args != nullptr && args[0] != '\0') {
                    std::string args_str(args);

                    // Check for iterator(...):
                    if (args_str.find("iterator") != std::string::npos) {
                        // Set modifier to iterator so toString() will print it
                        modifier = OMPC_AFFINITY_MODIFIER_iterator;
                        size_t iter_start = args_str.find("iterator");
                        if (iter_start != std::string::npos) {
                            // Find the matching closing paren
                            size_t paren_start = args_str.find('(', iter_start);
                            if (paren_start != std::string::npos) {
                                int paren_depth = 1;
                                size_t i = paren_start + 1;
                                while (i < args_str.length() && paren_depth > 0) {
                                    if (args_str[i] == '(') paren_depth++;
                                    else if (args_str[i] == ')') paren_depth--;
                                    i++;
                                }

                                if (paren_depth == 0) {
                                    // Extract iterator content
                                    size_t iter_content_start = paren_start + 1;
                                    size_t iter_content_end = i - 1;
                                    std::string iter_content = args_str.substr(iter_content_start, iter_content_end - iter_content_start);

                                    // Parse iterator definitions: "int bba=4:120:2, char huj=2:677"
                                    size_t pos = 0;
                                    while (pos < iter_content.length()) {
                                        // Skip whitespace
                                        while (pos < iter_content.length() && std::isspace(iter_content[pos])) pos++;
                                        if (pos >= iter_content.length()) break;

                                        // Find the next comma (or end)
                                        size_t comma_pos = iter_content.find(',', pos);
                                        if (comma_pos == std::string::npos) comma_pos = iter_content.length();

                                        std::string one_iterator = iter_content.substr(pos, comma_pos - pos);
                                        // Trim the whole iterator string first
                                        one_iterator.erase(0, one_iterator.find_first_not_of(" \t"));
                                        one_iterator.erase(one_iterator.find_last_not_of(" \t") + 1);

                                        // Parse: "type name=begin:end:step" or "type name=begin:end"
                                        std::vector<const char*>* iter_def = new std::vector<const char*>();

                                        // Find type (everything before the last space before '=')
                                        size_t eq_pos = one_iterator.find('=');
                                        if (eq_pos != std::string::npos) {
                                            std::string before_eq = one_iterator.substr(0, eq_pos);
                                            before_eq.erase(before_eq.find_last_not_of(" \t") + 1);

                                            size_t last_space = before_eq.find_last_of(" \t");

                                            std::string type_str, name_str;
                                            if (last_space != std::string::npos) {
                                                type_str = before_eq.substr(0, last_space);
                                                name_str = before_eq.substr(last_space + 1);
                                                type_str.erase(0, type_str.find_first_not_of(" \t"));
                                                type_str.erase(type_str.find_last_not_of(" \t") + 1);
                                            } else {
                                                type_str = "";
                                                name_str = before_eq;
                                            }

                                            // Parse range: begin:end:step
                                            std::string range_str = one_iterator.substr(eq_pos + 1);
                                            range_str.erase(0, range_str.find_first_not_of(" \t"));
                                            range_str.erase(range_str.find_last_not_of(" \t") + 1);

                                            size_t colon1 = range_str.find(':');
                                            size_t colon2 = range_str.find(':', colon1 + 1);

                                            std::string begin_str, end_str, step_str;
                                            if (colon1 != std::string::npos) {
                                                begin_str = range_str.substr(0, colon1);
                                                begin_str.erase(0, begin_str.find_first_not_of(" \t"));
                                                begin_str.erase(begin_str.find_last_not_of(" \t") + 1);

                                                if (colon2 != std::string::npos) {
                                                    end_str = range_str.substr(colon1 + 1, colon2 - colon1 - 1);
                                                    end_str.erase(0, end_str.find_first_not_of(" \t"));
                                                    end_str.erase(end_str.find_last_not_of(" \t") + 1);

                                                    step_str = range_str.substr(colon2 + 1);
                                                    step_str.erase(0, step_str.find_first_not_of(" \t"));
                                                    step_str.erase(step_str.find_last_not_of(" \t") + 1);
                                                } else {
                                                    end_str = range_str.substr(colon1 + 1);
                                                    end_str.erase(0, end_str.find_first_not_of(" \t"));
                                                    end_str.erase(end_str.find_last_not_of(" \t") + 1);
                                                    step_str = "";
                                                }
                                            }

                                            // Add to iterator definition (5 elements: type, name, begin, end, step)
                                            iter_def->push_back(strdup(type_str.c_str()));
                                            iter_def->push_back(strdup(name_str.c_str()));
                                            iter_def->push_back(strdup(begin_str.c_str()));
                                            iter_def->push_back(strdup(end_str.c_str()));
                                            iter_def->push_back(strdup(step_str.c_str()));

                                            iterators.push_back(iter_def);
                                        }

                                        pos = comma_pos + 1;
                                    }

                                    // Extract variables after iterator(...):
                                    size_t colon_pos = args_str.find(':', i);
                                    if (colon_pos != std::string::npos) {
                                        variables_str = args_str.substr(colon_pos + 1);
                                        variables_str.erase(0, variables_str.find_first_not_of(" \t"));
                                        variables_str.erase(variables_str.find_last_not_of(" \t") + 1);
                                    }
                                }
                            }
                        }
                    } else {
                        // No iterator, just variables
                        variables_str = args_str;
                    }
                }

                // Create affinity clause
                OpenMPClause* affinity_clause = OpenMPAffinityClause::addAffinityClause(dir, modifier);

                // Add iterator definitions if present
                if (affinity_clause != nullptr && !iterators.empty()) {
                    OpenMPAffinityClause* typed_clause = static_cast<OpenMPAffinityClause*>(affinity_clause);
                    for (auto* iter_def : iterators) {
                        typed_clause->addIteratorsDefinitionClass(iter_def);
                    }
                }

                // Add variables with proper formatting
                if (affinity_clause != nullptr && !variables_str.empty()) {
                    std::string formatted = format_clause_args(variables_str.c_str(), false);
                    add_list_expressions(affinity_clause, formatted.c_str());
                }

                // Add to clauses_in_original_order
                if (affinity_clause != nullptr && affinity_clause->getClausePosition() == -1) {
                    dir->getClausesInOriginalOrder()->push_back(affinity_clause);
                    affinity_clause->setClausePosition(dir->getClausesInOriginalOrder()->size() - 1);
                }
            } else {
                // For most clauses, use simple expression-based approach
                // The varargs version of addOpenMPClause expects different parameters
                // depending on the clause kind. For simple clauses with no special handling,
                // it creates the clause without reading varargs.
                //
                // NOTE: For clauses in the big case statement (OMPC_num_threads, OMPC_private, etc.),
                // the varargs are NOT read. The clause is created and then we must call
                // addLangExpr to add expressions to it.

                OpenMPClause* clause = nullptr;

                // Create clause with empty string (varargs not used for simple clauses)
                clause = dir->addOpenMPClause(static_cast<int>(clause_kind), "");

                // Add arguments if present
                if (clause != nullptr && args != nullptr && args[0] != '\0') {
                    // Check if this is a list clause that needs comma splitting
                    if (is_list_clause(clause_kind)) {
                        // Format arguments with proper spacing and split comma-separated list
                        std::string formatted = format_clause_args(args, false);
                        add_list_expressions(clause, formatted.c_str());
                    } else {
                        // For non-list clauses, add the argument as a single expression
                        // Special handling for sizes clause: needs spaces after commas
                        if (clause_kind == OMPC_sizes) {
                            std::string formatted = format_clause_args(args, false);
                            clause->addLangExpr(strdup(formatted.c_str()));
                        } else {
                            char* persistent_args = strdup(args);
                            clause->addLangExpr(persistent_args);
                        }
                    }
                }
            }
        }
        roup_clause_iterator_free(iter);
    }

    // Free ROUP directive (we've extracted what we need)
    roup_directive_free(roup_dir);

    return dir;
}

} // extern "C"
