/*
 * OpenMPIR.cpp - Minimal ompparser compatibility implementation using ROUP
 *
 * This provides ONLY the implementation (.cpp), using ompparser's headers
 * from the git submodule at compat/ompparser/ompparser/src/
 *
 * Copyright (c) 2025 ROUP Project
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <OpenMPIR.h>
#include <cstring>
#include <sstream>
#include <string>

// Include ROUP constants (auto-generated by build.rs from src/c_api.rs)
#include <roup_constants.h>

// ============================================================================
// ROUP C API Forward Declarations
// ============================================================================

extern "C" {
    // Opaque types from ROUP
    struct OmpDirective;
    struct OmpClause;
    struct OmpClauseIterator;

    // Core parsing
    OmpDirective* roup_parse(const char* input);
    OmpDirective* roup_parse_with_language(const char* input, int32_t language);
    void roup_directive_free(OmpDirective* directive);

    // Directive queries
    int32_t roup_directive_kind(const OmpDirective* directive);
    int32_t roup_directive_clause_count(const OmpDirective* directive);
    OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);

    // Iterator operations (updated API with out parameter)
    int32_t roup_clause_iterator_next(OmpClauseIterator* iter, const OmpClause** out);
    void roup_clause_iterator_free(OmpClauseIterator* iter);

    // Clause queries
    int32_t roup_clause_kind(const OmpClause* clause);
}

// ============================================================================
// Global State
// ============================================================================

static OpenMPBaseLang current_lang = Lang_C;

// Language prefix constants - defined once to avoid manual synchronization
static constexpr const char FORTRAN_PREFIX[] = "!$omp";       // Fortran prefix (lowercase)
static constexpr const char FORTRAN_PREFIX_UPPER[] = "!$OMP"; // Fortran prefix (uppercase)
static constexpr const char C_PRAGMA_PREFIX[] = "#pragma";    // C/C++ pragma prefix
// Compile-time string lengths: sizeof() includes null terminator, subtract 1 for actual length
static constexpr size_t FORTRAN_PREFIX_LEN = sizeof(FORTRAN_PREFIX) - 1;
static constexpr size_t C_PRAGMA_PREFIX_LEN = sizeof(C_PRAGMA_PREFIX) - 1;

extern "C" void setLang(OpenMPBaseLang lang) {
    current_lang = lang;
}

// ============================================================================
// Helper Functions
// ============================================================================

static OpenMPDirectiveKind mapRoupToOmpparserDirective(int32_t roup_kind) {
    // ROUP directive kind mapping using named constants
    // See roup_constants.h and src/c_api.rs:directive_name_to_kind()
    switch (roup_kind) {
        case ROUP_DIRECTIVE_PARALLEL:       return OMPD_parallel;
        case ROUP_DIRECTIVE_FOR:            return OMPD_for;
        case ROUP_DIRECTIVE_SECTIONS:       return OMPD_sections;
        case ROUP_DIRECTIVE_SINGLE:         return OMPD_single;
        case ROUP_DIRECTIVE_TASK:           return OMPD_task;
        case ROUP_DIRECTIVE_MASTER:         return OMPD_master;
        case ROUP_DIRECTIVE_CRITICAL:       return OMPD_critical;
        case ROUP_DIRECTIVE_BARRIER:        return OMPD_barrier;
        case ROUP_DIRECTIVE_TASKWAIT:       return OMPD_taskwait;
        case ROUP_DIRECTIVE_TASKGROUP:      return OMPD_taskgroup;
        case ROUP_DIRECTIVE_ATOMIC:         return OMPD_atomic;
        case ROUP_DIRECTIVE_FLUSH:          return OMPD_flush;
        case ROUP_DIRECTIVE_ORDERED:        return OMPD_ordered;
        case ROUP_DIRECTIVE_TARGET:         return OMPD_target;
        case ROUP_DIRECTIVE_TEAMS:          return OMPD_teams;
        case ROUP_DIRECTIVE_DISTRIBUTE:     return OMPD_distribute;
        case ROUP_DIRECTIVE_METADIRECTIVE:  return OMPD_metadirective;
        default:                            return OMPD_unknown;
    }
}

static OpenMPClauseKind mapRoupToOmpparserClause(int32_t roup_kind) {
    // ROUP clause kind mapping using named constants from roup_constants.h
    // Single source of truth: src/c_api.rs:convert_clause()
    switch (roup_kind) {
        case ROUP_CLAUSE_NUM_THREADS:   return OMPC_num_threads;
        case ROUP_CLAUSE_IF:            return OMPC_if;
        case ROUP_CLAUSE_PRIVATE:       return OMPC_private;
        case ROUP_CLAUSE_SHARED:        return OMPC_shared;
        case ROUP_CLAUSE_FIRSTPRIVATE:  return OMPC_firstprivate;
        case ROUP_CLAUSE_LASTPRIVATE:   return OMPC_lastprivate;
        case ROUP_CLAUSE_REDUCTION:     return OMPC_reduction;
        case ROUP_CLAUSE_SCHEDULE:      return OMPC_schedule;
        case ROUP_CLAUSE_COLLAPSE:      return OMPC_collapse;
        case ROUP_CLAUSE_ORDERED:       return OMPC_ordered;
        case ROUP_CLAUSE_NOWAIT:        return OMPC_nowait;
        case ROUP_CLAUSE_DEFAULT:       return OMPC_default;
        default:                        return OMPC_unknown;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

extern "C" {

OpenMPDirective* parseOpenMP(const char* input, void* exprParse(const char* expr)) {
    if (!input || input[0] == '\0') {
        return nullptr;
    }

    // Validate input length using constant from ROUP C API
    // Use strnlen to safely handle potentially untrusted/non-null-terminated input
    const size_t input_len = strnlen(input, ROUP_MAX_PRAGMA_LENGTH);
    if (input_len == ROUP_MAX_PRAGMA_LENGTH) {
        return nullptr;  // Input too long or not null-terminated within limit
    }

    // Determine input format based on current language mode
    std::string input_str(input, input_len);

    // Handle different language pragmas
    if (current_lang == Lang_Fortran) {
        // Fortran uses !$omp prefix - add if missing (case-insensitive check)
        const bool has_prefix =
            input_str.length() >= FORTRAN_PREFIX_LEN &&
            (input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX) == 0 ||
             input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX_UPPER) == 0);
        if (!has_prefix) {
            input_str = std::string(FORTRAN_PREFIX) + " " + input_str;
        }
    } else {
        // C/C++ use #pragma omp prefix - add if missing
        // compare() returns 0 if strings match, non-zero otherwise
        if (input_str.compare(0, C_PRAGMA_PREFIX_LEN, C_PRAGMA_PREFIX) != 0) {
            input_str = std::string(C_PRAGMA_PREFIX) + " " + input_str;
        }
    }

    // Call ROUP parser with language-aware mode for Fortran
    OmpDirective* roup_dir = nullptr;
    if (current_lang == Lang_Fortran) {
        roup_dir = roup_parse_with_language(input_str.c_str(), ROUP_LANG_FORTRAN_FREE);
        if (!roup_dir) {
            // Fallback to language-neutral parse for mixed inputs (e.g., #pragma strings)
            roup_dir = roup_parse(input_str.c_str());
        }
    } else {
        roup_dir = roup_parse(input_str.c_str());
    }
    if (!roup_dir) {
        return nullptr;
    }

    // Get directive kind from ROUP
    int32_t roup_kind = roup_directive_kind(roup_dir);
    OpenMPDirectiveKind kind = mapRoupToOmpparserDirective(roup_kind);

    // Create ompparser-compatible directive
    // Use ompparser's actual constructor: OpenMPDirective(kind, lang, line, col)
    OpenMPDirective* dir = new OpenMPDirective(kind, current_lang, 0, 0);

    // Convert clauses using ompparser's addOpenMPClause method
    OmpClauseIterator* iter = roup_directive_clauses_iter(roup_dir);
    if (iter) {
        const OmpClause* roup_clause;
        while (roup_clause_iterator_next(iter, &roup_clause) == 1) {
            int32_t roup_kind_clause = roup_clause_kind(roup_clause);
            OpenMPClauseKind clause_kind = mapRoupToOmpparserClause(roup_kind_clause);

            // Use public variadic version: addOpenMPClause(int kind, ...)
            // Cast to int and pass just the kind for basic clause support
            dir->addOpenMPClause(static_cast<int>(clause_kind));
        }
        roup_clause_iterator_free(iter);
    }

    // Free ROUP directive (we've extracted what we need)
    roup_directive_free(roup_dir);

    return dir;
}

} // extern "C"
