/*
 * OpenACCIR.cpp - Minimal accparser compatibility implementation using ROUP
 *
 * This provides ONLY the implementation (.cpp), using accparser's headers
 * from the git submodule at compat/accparser/accparser/src/
 *
 * Copyright (c) 2025 ROUP Project
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <OpenACCIR.h>
#include <cstring>
#include <sstream>
#include <string>

// Include ROUP constants (auto-generated by build.rs from src/c_api.rs)
#include <roup_constants.h>

// ============================================================================
// ROUP C API Forward Declarations
// ============================================================================

extern "C" {
    // Opaque types from ROUP
    struct AccDirective;
    struct AccClause;
    struct AccClauseIterator;

    // Core parsing
    AccDirective* acc_parse(const char* input);
    AccDirective* acc_parse_with_language(const char* input, int32_t language);
    void acc_directive_free(AccDirective* directive);

    // Directive queries
    int32_t acc_directive_kind(const AccDirective* directive);
    int32_t acc_directive_clause_count(const AccDirective* directive);
    AccClauseIterator* acc_directive_clauses_iter(const AccDirective* directive);

    // Iterator operations
    int32_t acc_clause_iterator_next(AccClauseIterator* iter, const AccClause** out);
    void acc_clause_iterator_free(AccClauseIterator* iter);

    // Clause queries
    int32_t acc_clause_kind(const AccClause* clause);
    const char* acc_clause_name(const AccClause* clause);
    int32_t acc_clause_expressions_count(const AccClause* clause);
    const char* acc_clause_expression_at(const AccClause* clause, int32_t index);
    int32_t acc_clause_modifier(const AccClause* clause);
    int32_t acc_clause_operator(const AccClause* clause);

    // Cache directive queries
    int32_t acc_cache_directive_modifier(const AccDirective* directive);
    int32_t acc_cache_directive_var_count(const AccDirective* directive);
    const char* acc_cache_directive_var_at(const AccDirective* directive, int32_t index);
}

// ============================================================================
// Global State
// ============================================================================

static OpenACCBaseLang current_lang = ACC_Lang_C;

// Language prefix constants
static constexpr const char FORTRAN_PREFIX[] = "!$acc";       // Fortran prefix (lowercase)
static constexpr const char FORTRAN_PREFIX_UPPER[] = "!$ACC"; // Fortran prefix (uppercase)
static constexpr const char C_PRAGMA_PREFIX[] = "#pragma";    // C/C++ pragma prefix
static constexpr size_t FORTRAN_PREFIX_LEN = sizeof(FORTRAN_PREFIX) - 1;
static constexpr size_t C_PRAGMA_PREFIX_LEN = sizeof(C_PRAGMA_PREFIX) - 1;

extern "C" void setLang(OpenACCBaseLang lang) {
    current_lang = lang;
}

// ============================================================================
// Helper Functions
// ============================================================================

static OpenACCDirectiveKind mapRoupToAccparserDirective(int32_t roup_kind) {
    // ROUP directive kind mapping using named constants from roup_constants.h
    // Mapping from ROUP IDs (src/c_api.rs:acc_directive_name_to_kind lines 1636-1664)
    // to accparser enum values (compat/accparser/accparser/src/OpenACCKinds.h)
    //
    // Note: ROUP supports both space and underscore variants for some directives:
    //   - "enter data" (4) and "enter_data" (24) both map to ACCD_enter_data
    //   - "exit data" (5) and "exit_data" (25) both map to ACCD_exit_data
    //   - "host data" (11) and "host_data" (6) both map to ACCD_host_data
    //   - "wait" (9) and "wait(...)" (26) both map to ACCD_wait
    switch (roup_kind) {
        case ACC_DIRECTIVE_PARALLEL:    return ACCD_parallel;     // 0 = "parallel"
        case ACC_DIRECTIVE_LOOP:        return ACCD_loop;         // 1 = "loop"
        case ACC_DIRECTIVE_KERNELS:     return ACCD_kernels;      // 2 = "kernels"
        case ACC_DIRECTIVE_DATA:        return ACCD_data;         // 3 = "data"
        case 4:                         return ACCD_enter_data;   // 4 = "enter data" (space)
        case 5:                         return ACCD_exit_data;    // 5 = "exit data" (space)
        case ACC_DIRECTIVE_HOST_DATA:   return ACCD_host_data;    // 6 = "host_data" (underscore)
        case ACC_DIRECTIVE_ATOMIC:      return ACCD_atomic;       // 7 = "atomic"
        case ACC_DIRECTIVE_DECLARE:     return ACCD_declare;      // 8 = "declare"
        case ACC_DIRECTIVE_WAIT:        return ACCD_wait;         // 9 = "wait"
        case ACC_DIRECTIVE_END:         return ACCD_end;          // 10 = "end"
        case 11:                        return ACCD_host_data;    // 11 = "host data" (space) - same as 6
        case ACC_DIRECTIVE_UPDATE:      return ACCD_update;       // 12 = "update"
        case 14:                        return ACCD_kernels_loop; // 14 = "kernels loop"
        case 15:                        return ACCD_parallel_loop;// 15 = "parallel loop"
        case 16:                        return ACCD_serial_loop;  // 16 = "serial loop"
        case ACC_DIRECTIVE_SERIAL:      return ACCD_serial;       // 17 = "serial"
        case ACC_DIRECTIVE_ROUTINE:     return ACCD_routine;      // 18 = "routine"
        case ACC_DIRECTIVE_SET:         return ACCD_set;          // 19 = "set"
        case ACC_DIRECTIVE_INIT:        return ACCD_init;         // 20 = "init"
        case ACC_DIRECTIVE_SHUTDOWN:    return ACCD_shutdown;     // 21 = "shutdown"
        case ACC_DIRECTIVE_CACHE:       return ACCD_cache;        // 23 = "cache(...)" with content
        case ACC_DIRECTIVE_ENTER_DATA:  return ACCD_enter_data;   // 24 = "enter_data" (underscore)
        case ACC_DIRECTIVE_EXIT_DATA:   return ACCD_exit_data;    // 25 = "exit_data" (underscore)
        case 26:                        return ACCD_wait;         // 26 = "wait(...)" with arguments
        default:                        return ACCD_unknown;
    }
}

static OpenACCClauseKind mapRoupToAccparserClause(int32_t roup_kind) {
    // ROUP clause kind mapping using named constants from roup_constants.h
    // Single source of truth: src/c_api.rs:convert_acc_clause()
    switch (roup_kind) {
        case ACC_CLAUSE_ASYNC:           return ACCC_async;
        case ACC_CLAUSE_WAIT:            return ACCC_wait;
        case ACC_CLAUSE_NUM_GANGS:       return ACCC_num_gangs;
        case ACC_CLAUSE_NUM_WORKERS:     return ACCC_num_workers;
        case ACC_CLAUSE_VECTOR_LENGTH:   return ACCC_vector_length;
        case ACC_CLAUSE_GANG:            return ACCC_gang;
        case ACC_CLAUSE_WORKER:          return ACCC_worker;
        case ACC_CLAUSE_VECTOR:          return ACCC_vector;
        case ACC_CLAUSE_SEQ:             return ACCC_seq;
        case ACC_CLAUSE_INDEPENDENT:     return ACCC_independent;
        case ACC_CLAUSE_AUTO:            return ACCC_auto;
        case ACC_CLAUSE_COLLAPSE:        return ACCC_collapse;
        case ACC_CLAUSE_DEVICE_TYPE:     return ACCC_device_type;
        case ACC_CLAUSE_BIND:            return ACCC_bind;
        case ACC_CLAUSE_IF:              return ACCC_if;
        case ACC_CLAUSE_DEFAULT:         return ACCC_default;
        case ACC_CLAUSE_FIRSTPRIVATE:    return ACCC_firstprivate;
        case ACC_CLAUSE_DEFAULT_ASYNC:   return ACCC_default_async;
        case ACC_CLAUSE_LINK:            return ACCC_link;
        case ACC_CLAUSE_NO_CREATE:       return ACCC_no_create;
        case ACC_CLAUSE_NOHOST:          return ACCC_nohost;
        case ACC_CLAUSE_PRESENT:         return ACCC_present;
        case ACC_CLAUSE_PRIVATE:         return ACCC_private;
        case ACC_CLAUSE_REDUCTION:       return ACCC_reduction;
        case ACC_CLAUSE_READ:            return ACCC_read;
        case ACC_CLAUSE_SELF:            return ACCC_self;
        case ACC_CLAUSE_TILE:            return ACCC_tile;
        case ACC_CLAUSE_USE_DEVICE:      return ACCC_use_device;
        case ACC_CLAUSE_ATTACH:          return ACCC_attach;
        case ACC_CLAUSE_DETACH:          return ACCC_detach;
        case ACC_CLAUSE_FINALIZE:        return ACCC_finalize;
        case ACC_CLAUSE_IF_PRESENT:      return ACCC_if_present;
        case ACC_CLAUSE_CAPTURE:         return ACCC_capture;
        case ACC_CLAUSE_WRITE:           return ACCC_write;
        case ACC_CLAUSE_UPDATE:          return ACCC_update;
        case ACC_CLAUSE_COPY:            return ACCC_copy;
        case ACC_CLAUSE_COPYIN:          return ACCC_copyin;
        case ACC_CLAUSE_COPYOUT:         return ACCC_copyout;
        case ACC_CLAUSE_CREATE:          return ACCC_create;
        case ACC_CLAUSE_DELETE:          return ACCC_delete;
        case ACC_CLAUSE_DEVICE:          return ACCC_device;
        case ACC_CLAUSE_DEVICEPTR:       return ACCC_deviceptr;
        case ACC_CLAUSE_DEVICE_NUM:      return ACCC_device_num;
        case ACC_CLAUSE_DEVICE_RESIDENT: return ACCC_device_resident;
        case ACC_CLAUSE_HOST:            return ACCC_host;
        default:                         return ACCC_unknown;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

extern "C" {

OpenACCDirective* parseOpenACC(const char* input, void* exprParse(const char* expr)) {
    if (!input || input[0] == '\0') {
        return nullptr;
    }

    // Validate input length using constant from ROUP C API
    // Manual safe strlen to avoid non-portable strnlen (POSIX.1-2008)
    size_t input_len = 0;
    while (input_len < ROUP_MAX_PRAGMA_LENGTH && input[input_len] != '\0') {
        ++input_len;
    }
    // If loop exited because we hit the limit (not because we found '\0'),
    // the input is too long or not null-terminated within bounds
    // Check if we exited due to reaching the limit AND the last checked char wasn't NUL
    if (input_len == ROUP_MAX_PRAGMA_LENGTH && (input_len == 0 || input[input_len - 1] != '\0')) {
        return nullptr;  // Input too long or not null-terminated within limit
    }

    // Determine input format based on current language mode
    std::string input_str(input, input_len);

    // Handle different language pragmas
    if (current_lang == ACC_Lang_Fortran) {
        // Fortran uses !$acc prefix - add if missing (case-insensitive check)
        const bool has_prefix =
            input_str.length() >= FORTRAN_PREFIX_LEN &&
            (input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX) == 0 ||
             input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX_UPPER) == 0);
        if (!has_prefix) {
            input_str = std::string(FORTRAN_PREFIX) + " " + input_str;
        }
    } else {
        // C/C++ use #pragma acc prefix - add if missing
        if (input_str.compare(0, C_PRAGMA_PREFIX_LEN, C_PRAGMA_PREFIX) != 0) {
            input_str = std::string(C_PRAGMA_PREFIX) + " " + input_str;
        }
    }

    // Call ROUP parser with language setting to honor setLang()
    // Map accparser language to ROUP language constants (roup_constants.h)
    // ROUP_LANG_C = 0, ROUP_LANG_FORTRAN_FREE = 1, ROUP_LANG_FORTRAN_FIXED = 2
    int32_t roup_lang = (current_lang == ACC_Lang_Fortran) ? 1 : 0; // 0=C, 1=Fortran free-form
    AccDirective* roup_dir = acc_parse_with_language(input_str.c_str(), roup_lang);
    if (!roup_dir) {
        return nullptr;
    }

    // Get directive kind from ROUP
    int32_t roup_kind = acc_directive_kind(roup_dir);
    OpenACCDirectiveKind kind = mapRoupToAccparserDirective(roup_kind);

    // Debug: print directive kind if unknown
    if (kind == ACCD_unknown) {
        fprintf(stderr, "WARNING: Unknown directive kind from ROUP: %d\n", roup_kind);
    }

    // Create accparser-compatible directive
    // Cache and Wait directives need special handling
    OpenACCDirective* dir = nullptr;

    if (kind == ACCD_cache) {
        // Create OpenACCCacheDirective
        OpenACCCacheDirective* cache_dir = new OpenACCCacheDirective();
        cache_dir->setBaseLang(current_lang);

        // Get cache modifier (0=none, 1=readonly)
        int32_t cache_modifier = acc_cache_directive_modifier(roup_dir);
        if (cache_modifier == 1) {
            cache_dir->setModifier(ACCC_CACHE_readonly);
        }

        // Get cache variables
        int32_t var_count = acc_cache_directive_var_count(roup_dir);
        for (int32_t i = 0; i < var_count; i++) {
            const char* var = acc_cache_directive_var_at(roup_dir, i);
            if (var) {
                cache_dir->addVar(std::string(var));
            }
        }

        dir = cache_dir;
    } else if (kind == ACCD_wait) {
        // Create OpenACCWaitDirective
        OpenACCWaitDirective* wait_dir = new OpenACCWaitDirective();
        wait_dir->setBaseLang(current_lang);

        // TODO: Handle wait directive arguments if needed

        dir = wait_dir;
    } else {
        // Regular directive
        dir = new OpenACCDirective(kind, current_lang, 0, 0);
    }

    // Convert clauses - get ALL data from ROUP's C API
    AccClauseIterator* iter = acc_directive_clauses_iter(roup_dir);
    if (iter) {
        const AccClause* roup_clause;
        while (acc_clause_iterator_next(iter, &roup_clause) == 1) {
            int32_t roup_kind_clause = acc_clause_kind(roup_clause);
            OpenACCClauseKind clause_kind = mapRoupToAccparserClause(roup_kind_clause);

            // Create clause using accparser's API
            OpenACCClause* clause = dir->addOpenACCClause(static_cast<int>(clause_kind));

            if (clause) {
                // Get expressions from ROUP and add to accparser clause
                int32_t expr_count = acc_clause_expressions_count(roup_clause);
                for (int32_t i = 0; i < expr_count; i++) {
                    const char* expr = acc_clause_expression_at(roup_clause, i);
                    if (expr) {
                        clause->addLangExpr(std::string(expr));
                    }
                }

                // Handle modifiers for clauses that have them (copyin, copyout, create, vector, worker)
                int32_t modifier = acc_clause_modifier(roup_clause);
                if (modifier != 0) {
                    if (clause_kind == ACCC_copyin && modifier == 1) {
                        ((OpenACCCopyinClause*)clause)->setModifier(ACCC_COPYIN_readonly);
                    } else if (clause_kind == ACCC_copyout && modifier == 2) {
                        ((OpenACCCopyoutClause*)clause)->setModifier(ACCC_COPYOUT_zero);
                    } else if (clause_kind == ACCC_create && modifier == 2) {
                        ((OpenACCCreateClause*)clause)->setModifier(ACCC_CREATE_zero);
                    } else if (clause_kind == ACCC_vector && modifier == 1) {
                        ((OpenACCVectorClause*)clause)->setModifier(ACCC_VECTOR_length);
                    } else if (clause_kind == ACCC_worker && modifier == 1) {
                        ((OpenACCWorkerClause*)clause)->setModifier(ACCC_WORKER_num);
                    }
                }

                // Handle operators for reduction clause
                int32_t op = acc_clause_operator(roup_clause);
                if (op != 0 && clause_kind == ACCC_reduction) {
                    OpenACCReductionClauseOperator acc_op = ACCC_REDUCTION_unspecified;
                    switch (op) {
                        case 1: acc_op = ACCC_REDUCTION_add; break;
                        case 2: acc_op = ACCC_REDUCTION_sub; break;
                        case 3: acc_op = ACCC_REDUCTION_mul; break;
                        case 4: acc_op = ACCC_REDUCTION_max; break;
                        case 5: acc_op = ACCC_REDUCTION_min; break;
                        case 6: acc_op = ACCC_REDUCTION_bitand; break;
                        case 7: acc_op = ACCC_REDUCTION_bitor; break;
                        case 8: acc_op = ACCC_REDUCTION_bitxor; break;
                        case 9: acc_op = ACCC_REDUCTION_logand; break;
                        case 10: acc_op = ACCC_REDUCTION_logor; break;
                        case 11: acc_op = ACCC_REDUCTION_fort_and; break;
                        case 12: acc_op = ACCC_REDUCTION_fort_or; break;
                        case 13: acc_op = ACCC_REDUCTION_fort_eqv; break;
                        case 14: acc_op = ACCC_REDUCTION_fort_neqv; break;
                        case 15: acc_op = ACCC_REDUCTION_fort_iand; break;
                        case 16: acc_op = ACCC_REDUCTION_fort_ior; break;
                        case 17: acc_op = ACCC_REDUCTION_fort_ieor; break;
                    }
                    ((OpenACCReductionClause*)clause)->setOperator(acc_op);
                }
            }
        }
        acc_clause_iterator_free(iter);
    }

    // Free ROUP directive (we've extracted what we need)
    acc_directive_free(roup_dir);

    return dir;
}

} // extern "C"
