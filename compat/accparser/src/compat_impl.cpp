/*
 * OpenACCIR.cpp - Minimal accparser compatibility implementation using ROUP
 *
 * This provides ONLY the implementation (.cpp), using accparser's headers
 * from the git submodule at compat/accparser/accparser/src/
 *
 * Copyright (c) 2025 ROUP Project
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <OpenACCIR.h>
#include <cstring>
#include <sstream>
#include <string>

// Include ROUP constants (auto-generated by build.rs from src/c_api.rs)
#include <roup_constants.h>

// ============================================================================
// ROUP C API Forward Declarations
// ============================================================================

extern "C" {
    // Opaque types from ROUP
    struct AccDirective;
    struct AccClause;
    struct AccClauseIterator;

    // Core parsing
    AccDirective* acc_parse(const char* input);
    void acc_directive_free(AccDirective* directive);

    // Directive queries
    int32_t acc_directive_kind(const AccDirective* directive);
    int32_t acc_directive_clause_count(const AccDirective* directive);
    AccClauseIterator* acc_directive_clauses_iter(const AccDirective* directive);

    // Iterator operations
    int32_t acc_clause_iterator_next(AccClauseIterator* iter, const AccClause** out);
    void acc_clause_iterator_free(AccClauseIterator* iter);

    // Clause queries
    int32_t acc_clause_kind(const AccClause* clause);
}

// ============================================================================
// Global State
// ============================================================================

static OpenACCBaseLang current_lang = ACC_Lang_C;

// Language prefix constants
static constexpr const char FORTRAN_PREFIX[] = "!$acc";       // Fortran prefix (lowercase)
static constexpr const char FORTRAN_PREFIX_UPPER[] = "!$ACC"; // Fortran prefix (uppercase)
static constexpr const char C_PRAGMA_PREFIX[] = "#pragma";    // C/C++ pragma prefix
static constexpr size_t FORTRAN_PREFIX_LEN = sizeof(FORTRAN_PREFIX) - 1;
static constexpr size_t C_PRAGMA_PREFIX_LEN = sizeof(C_PRAGMA_PREFIX) - 1;

extern "C" void setLang(OpenACCBaseLang lang) {
    current_lang = lang;
}

// ============================================================================
// Helper Functions
// ============================================================================

static OpenACCDirectiveKind mapRoupToAccparserDirective(int32_t roup_kind) {
    // ROUP directive kind mapping using named constants
    // See roup_constants.h and src/c_api.rs:acc_directive_name_to_kind()
    // Note: ROUP supports both "enter data" (4) and "enter_data" (24) variants
    switch (roup_kind) {
        case ACC_DIRECTIVE_PARALLEL:    return ACCD_parallel;
        case ACC_DIRECTIVE_LOOP:        return ACCD_loop;
        case ACC_DIRECTIVE_KERNELS:     return ACCD_kernels;
        case ACC_DIRECTIVE_DATA:        return ACCD_data;
        case 4:                         return ACCD_enter_data;  // "enter data" (space)
        case 5:                         return ACCD_exit_data;   // "exit data" (space)
        case ACC_DIRECTIVE_HOST_DATA:   return ACCD_host_data;
        case ACC_DIRECTIVE_ATOMIC:      return ACCD_atomic;
        case ACC_DIRECTIVE_DECLARE:     return ACCD_declare;
        case ACC_DIRECTIVE_WAIT:        return ACCD_wait;
        case ACC_DIRECTIVE_END:         return ACCD_end;
        case ACC_DIRECTIVE_UPDATE:      return ACCD_update;
        case ACC_DIRECTIVE_SERIAL:      return ACCD_serial;
        case ACC_DIRECTIVE_ROUTINE:     return ACCD_routine;
        case ACC_DIRECTIVE_SET:         return ACCD_set;
        case ACC_DIRECTIVE_INIT:        return ACCD_init;
        case ACC_DIRECTIVE_SHUTDOWN:    return ACCD_shutdown;
        case ACC_DIRECTIVE_ENTER_DATA:  return ACCD_enter_data;  // "enter_data" (underscore)
        case ACC_DIRECTIVE_EXIT_DATA:   return ACCD_exit_data;   // "exit_data" (underscore)
        default:                        return ACCD_unknown;
    }
}

static OpenACCClauseKind mapRoupToAccparserClause(int32_t roup_kind) {
    // ROUP clause kind mapping using named constants from roup_constants.h
    // Single source of truth: src/c_api.rs:convert_acc_clause()
    switch (roup_kind) {
        case ACC_CLAUSE_ASYNC:           return ACCC_async;
        case ACC_CLAUSE_WAIT:            return ACCC_wait;
        case ACC_CLAUSE_NUM_GANGS:       return ACCC_num_gangs;
        case ACC_CLAUSE_NUM_WORKERS:     return ACCC_num_workers;
        case ACC_CLAUSE_VECTOR_LENGTH:   return ACCC_vector_length;
        case ACC_CLAUSE_GANG:            return ACCC_gang;
        case ACC_CLAUSE_WORKER:          return ACCC_worker;
        case ACC_CLAUSE_VECTOR:          return ACCC_vector;
        case ACC_CLAUSE_SEQ:             return ACCC_seq;
        case ACC_CLAUSE_INDEPENDENT:     return ACCC_independent;
        case ACC_CLAUSE_AUTO:            return ACCC_auto;
        case ACC_CLAUSE_COLLAPSE:        return ACCC_collapse;
        case ACC_CLAUSE_DEVICE_TYPE:     return ACCC_device_type;
        case ACC_CLAUSE_BIND:            return ACCC_bind;
        case ACC_CLAUSE_IF:              return ACCC_if;
        case ACC_CLAUSE_DEFAULT:         return ACCC_default;
        case ACC_CLAUSE_FIRSTPRIVATE:    return ACCC_firstprivate;
        case ACC_CLAUSE_DEFAULT_ASYNC:   return ACCC_default_async;
        case ACC_CLAUSE_LINK:            return ACCC_link;
        case ACC_CLAUSE_NO_CREATE:       return ACCC_no_create;
        case ACC_CLAUSE_NOHOST:          return ACCC_nohost;
        case ACC_CLAUSE_PRESENT:         return ACCC_present;
        case ACC_CLAUSE_PRIVATE:         return ACCC_private;
        case ACC_CLAUSE_REDUCTION:       return ACCC_reduction;
        case ACC_CLAUSE_READ:            return ACCC_read;
        case ACC_CLAUSE_SELF:            return ACCC_self;
        case ACC_CLAUSE_TILE:            return ACCC_tile;
        case ACC_CLAUSE_USE_DEVICE:      return ACCC_use_device;
        case ACC_CLAUSE_ATTACH:          return ACCC_attach;
        case ACC_CLAUSE_DETACH:          return ACCC_detach;
        case ACC_CLAUSE_FINALIZE:        return ACCC_finalize;
        case ACC_CLAUSE_IF_PRESENT:      return ACCC_if_present;
        case ACC_CLAUSE_CAPTURE:         return ACCC_capture;
        case ACC_CLAUSE_WRITE:           return ACCC_write;
        case ACC_CLAUSE_UPDATE:          return ACCC_update;
        case ACC_CLAUSE_COPY:            return ACCC_copy;
        case ACC_CLAUSE_COPYIN:          return ACCC_copyin;
        case ACC_CLAUSE_COPYOUT:         return ACCC_copyout;
        case ACC_CLAUSE_CREATE:          return ACCC_create;
        case ACC_CLAUSE_DELETE:          return ACCC_delete;
        case ACC_CLAUSE_DEVICE:          return ACCC_device;
        case ACC_CLAUSE_DEVICEPTR:       return ACCC_deviceptr;
        case ACC_CLAUSE_DEVICE_NUM:      return ACCC_device_num;
        case ACC_CLAUSE_DEVICE_RESIDENT: return ACCC_device_resident;
        case ACC_CLAUSE_HOST:            return ACCC_host;
        default:                         return ACCC_unknown;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

extern "C" {

OpenACCDirective* parseOpenACC(const char* input, void* exprParse(const char* expr)) {
    if (!input || input[0] == '\0') {
        return nullptr;
    }

    // Validate input length using constant from ROUP C API
    // Use strnlen to safely handle potentially untrusted/non-null-terminated input
    const size_t input_len = strnlen(input, ROUP_MAX_PRAGMA_LENGTH);
    if (input_len == ROUP_MAX_PRAGMA_LENGTH) {
        return nullptr;  // Input too long or not null-terminated within limit
    }

    // Determine input format based on current language mode
    std::string input_str(input, input_len);

    // Handle different language pragmas
    if (current_lang == ACC_Lang_Fortran) {
        // Fortran uses !$acc prefix - add if missing (case-insensitive check)
        const bool has_prefix =
            input_str.length() >= FORTRAN_PREFIX_LEN &&
            (input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX) == 0 ||
             input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX_UPPER) == 0);
        if (!has_prefix) {
            input_str = std::string(FORTRAN_PREFIX) + " " + input_str;
        }
    } else {
        // C/C++ use #pragma acc prefix - add if missing
        if (input_str.compare(0, C_PRAGMA_PREFIX_LEN, C_PRAGMA_PREFIX) != 0) {
            input_str = std::string(C_PRAGMA_PREFIX) + " " + input_str;
        }
    }

    // Call ROUP parser
    AccDirective* roup_dir = acc_parse(input_str.c_str());
    if (!roup_dir) {
        return nullptr;
    }

    // Get directive kind from ROUP
    int32_t roup_kind = acc_directive_kind(roup_dir);
    OpenACCDirectiveKind kind = mapRoupToAccparserDirective(roup_kind);

    // Create accparser-compatible directive
    // Use accparser's actual constructor: OpenACCDirective(kind, lang, line, col)
    OpenACCDirective* dir = new OpenACCDirective(kind, current_lang, 0, 0);

    // Convert clauses using accparser's addOpenACCClause method
    AccClauseIterator* iter = acc_directive_clauses_iter(roup_dir);
    if (iter) {
        const AccClause* roup_clause;
        while (acc_clause_iterator_next(iter, &roup_clause) == 1) {
            int32_t roup_kind_clause = acc_clause_kind(roup_clause);
            OpenACCClauseKind clause_kind = mapRoupToAccparserClause(roup_kind_clause);

            // Use public variadic version: addOpenACCClause(int kind, ...)
            // Cast to int and pass just the kind for basic clause support
            dir->addOpenACCClause(static_cast<int>(clause_kind));
        }
        acc_clause_iterator_free(iter);
    }

    // Free ROUP directive (we've extracted what we need)
    acc_directive_free(roup_dir);

    return dir;
}

} // extern "C"
