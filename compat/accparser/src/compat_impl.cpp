/*
 * compat_impl.cpp - accparser compatibility implementation using ROUP
 *
 * Provides parseOpenACC() implementation using ROUP parser + accparser AST.
 * Uses OpenACCParser.h from submodule (no ANTLR dependency).
 *
 * Copyright (c) 2025 ROUP Project
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <OpenACCParser.h>
#include <cstring>
#include <sstream>
#include <string>

// Include ROUP constants (auto-generated by build.rs from src/c_api.rs)
#include <roup_constants.h>

// ============================================================================
// ROUP C API Forward Declarations
// ============================================================================

extern "C" {
    // Opaque types from ROUP
    struct AccDirective;
    struct AccClause;
    struct AccClauseIterator;

    // Core parsing
    AccDirective* acc_parse(const char* input);
    AccDirective* acc_parse_with_language(const char* input, int32_t language);
    void acc_directive_free(AccDirective* directive);

    // Directive queries
    int32_t acc_directive_kind(const AccDirective* directive);
    int32_t acc_directive_clause_count(const AccDirective* directive);
    AccClauseIterator* acc_directive_clauses_iter(const AccDirective* directive);

    // Iterator operations
    int32_t acc_clause_iterator_next(AccClauseIterator* iter, const AccClause** out);
    void acc_clause_iterator_free(AccClauseIterator* iter);

    // Clause queries
    int32_t acc_clause_kind(const AccClause* clause);
    const char* acc_clause_original_keyword(const AccClause* clause);
    int32_t acc_clause_expressions_count(const AccClause* clause);
    const char* acc_clause_expression_at(const AccClause* clause, int32_t index);
    int32_t acc_clause_modifier(const AccClause* clause);
    int32_t acc_clause_operator(const AccClause* clause);
    const char* acc_clause_wait_devnum(const AccClause* clause);
    int32_t acc_clause_wait_has_queues(const AccClause* clause);

    // Cache directive queries
    int32_t acc_cache_directive_modifier(const AccDirective* directive);
    int32_t acc_cache_directive_var_count(const AccDirective* directive);
    const char* acc_cache_directive_var_at(const AccDirective* directive, int32_t index);

    // Wait directive queries
    int32_t acc_directive_wait_expression_count(const AccDirective* directive);
    const char* acc_directive_wait_expression_at(const AccDirective* directive, int32_t index);
    const char* acc_directive_wait_devnum(const AccDirective* directive);
    int32_t acc_directive_wait_has_queues(const AccDirective* directive);

    // Routine directive queries
    const char* acc_directive_routine_name(const AccDirective* directive);

    // End directive queries
    int32_t acc_directive_end_paired_kind(const AccDirective* directive);
}

// ============================================================================
// Global State
// ============================================================================

static OpenACCBaseLang current_lang = ACC_Lang_C;

// Language prefix constants
static constexpr const char FORTRAN_PREFIX[] = "!$acc";       // Fortran prefix (lowercase)
static constexpr const char FORTRAN_PREFIX_UPPER[] = "!$ACC"; // Fortran prefix (uppercase)
static constexpr const char C_PRAGMA_PREFIX[] = "#pragma";    // C/C++ pragma prefix
static constexpr size_t FORTRAN_PREFIX_LEN = sizeof(FORTRAN_PREFIX) - 1;
static constexpr size_t C_PRAGMA_PREFIX_LEN = sizeof(C_PRAGMA_PREFIX) - 1;

extern "C" void setLang(OpenACCBaseLang lang) {
    current_lang = lang;
}

static void maybeMergeClause(OpenACCDirective* directive, OpenACCClauseKind kind, OpenACCClause* clause) {
    switch (kind) {
        case ACCC_async:
            static_cast<OpenACCAsyncClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_bind:
            static_cast<OpenACCBindClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_collapse:
            static_cast<OpenACCCollapseClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_copyin:
            static_cast<OpenACCCopyinClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_copyout:
            static_cast<OpenACCCopyoutClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_create:
            static_cast<OpenACCCreateClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_default_async:
            static_cast<OpenACCDefaultAsyncClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_device_num:
            static_cast<OpenACCDeviceNumClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_gang:
            static_cast<OpenACCGangClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_num_gangs:
            static_cast<OpenACCNumGangsClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_num_workers:
            static_cast<OpenACCNumWorkersClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_reduction:
            static_cast<OpenACCReductionClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_self:
            static_cast<OpenACCSelfClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_vector:
            static_cast<OpenACCVectorClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_vector_length:
            static_cast<OpenACCVectorLengthClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_wait:
            static_cast<OpenACCWaitClause*>(clause)->mergeClause(directive, clause);
            break;
        case ACCC_worker:
            static_cast<OpenACCWorkerClause*>(clause)->mergeClause(directive, clause);
            break;
        default:
            break;
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

static OpenACCDirectiveKind mapRoupToAccparserDirective(int32_t roup_kind) {
    // ROUP directive kind mapping using named constants from roup_constants.h
    // Mapping from ROUP IDs (src/c_api.rs:acc_directive_name_to_kind lines 1636-1664)
    // to accparser enum values (compat/accparser/accparser/src/OpenACCKinds.h)
    //
    // Note: ROUP supports both space and underscore variants for some directives:
    //   - "enter data" (4) and "enter_data" (24) both map to ACCD_enter_data
    //   - "exit data" (5) and "exit_data" (25) both map to ACCD_exit_data
    //   - "host data" (11) and "host_data" (6) both map to ACCD_host_data
    //   - "wait" (9) and "wait(...)" (26) both map to ACCD_wait
    switch (roup_kind) {
        case ACC_DIRECTIVE_PARALLEL:    return ACCD_parallel;     // 0 = "parallel"
        case ACC_DIRECTIVE_LOOP:        return ACCD_loop;         // 1 = "loop"
        case ACC_DIRECTIVE_KERNELS:     return ACCD_kernels;      // 2 = "kernels"
        case ACC_DIRECTIVE_DATA:        return ACCD_data;         // 3 = "data"
        case 4:                         return ACCD_enter_data;   // 4 = "enter data" (space)
        case 5:                         return ACCD_exit_data;    // 5 = "exit data" (space)
        case ACC_DIRECTIVE_HOST_DATA:   return ACCD_host_data;    // 6 = "host_data" (underscore)
        case ACC_DIRECTIVE_ATOMIC:      return ACCD_atomic;       // 7 = "atomic"
        case ACC_DIRECTIVE_DECLARE:     return ACCD_declare;      // 8 = "declare"
        case ACC_DIRECTIVE_WAIT:        return ACCD_wait;         // 9 = "wait"
        case ACC_DIRECTIVE_END:         return ACCD_end;          // 10 = "end"
        case 11:                        return ACCD_host_data;    // 11 = "host data" (space) - same as 6
        case ACC_DIRECTIVE_UPDATE:      return ACCD_update;       // 12 = "update"
        case 14:                        return ACCD_kernels_loop; // 14 = "kernels loop"
        case 15:                        return ACCD_parallel_loop;// 15 = "parallel loop"
        case 16:                        return ACCD_serial_loop;  // 16 = "serial loop"
        case ACC_DIRECTIVE_SERIAL:      return ACCD_serial;       // 17 = "serial"
        case ACC_DIRECTIVE_ROUTINE:     return ACCD_routine;      // 18 = "routine"
        case ACC_DIRECTIVE_SET:         return ACCD_set;          // 19 = "set"
        case ACC_DIRECTIVE_INIT:        return ACCD_init;         // 20 = "init"
        case ACC_DIRECTIVE_SHUTDOWN:    return ACCD_shutdown;     // 21 = "shutdown"
        case ACC_DIRECTIVE_CACHE:       return ACCD_cache;        // 23 = "cache(...)" with content
        case ACC_DIRECTIVE_ENTER_DATA:  return ACCD_enter_data;   // 24 = "enter_data" (underscore)
        case ACC_DIRECTIVE_EXIT_DATA:   return ACCD_exit_data;    // 25 = "exit_data" (underscore)
        case 26:                        return ACCD_wait;         // 26 = "wait(...)" with arguments
        default:                        return ACCD_unknown;
    }
}

static OpenACCClauseKind mapRoupToAccparserClause(int32_t roup_kind) {
    // ROUP clause kind mapping using named constants from roup_constants.h
    // Single source of truth: src/c_api.rs:convert_acc_clause()
    switch (roup_kind) {
        case ACC_CLAUSE_ASYNC:           return ACCC_async;
        case ACC_CLAUSE_WAIT:            return ACCC_wait;
        case ACC_CLAUSE_NUM_GANGS:       return ACCC_num_gangs;
        case ACC_CLAUSE_NUM_WORKERS:     return ACCC_num_workers;
        case ACC_CLAUSE_VECTOR_LENGTH:   return ACCC_vector_length;
        case ACC_CLAUSE_GANG:            return ACCC_gang;
        case ACC_CLAUSE_WORKER:          return ACCC_worker;
        case ACC_CLAUSE_VECTOR:          return ACCC_vector;
        case ACC_CLAUSE_SEQ:             return ACCC_seq;
        case ACC_CLAUSE_INDEPENDENT:     return ACCC_independent;
        case ACC_CLAUSE_AUTO:            return ACCC_auto;
        case ACC_CLAUSE_COLLAPSE:        return ACCC_collapse;
        case ACC_CLAUSE_DEVICE_TYPE:     return ACCC_device_type;
        case ACC_CLAUSE_BIND:            return ACCC_bind;
        case ACC_CLAUSE_IF:              return ACCC_if;
        case ACC_CLAUSE_DEFAULT:         return ACCC_default;
        case ACC_CLAUSE_FIRSTPRIVATE:    return ACCC_firstprivate;
        case ACC_CLAUSE_DEFAULT_ASYNC:   return ACCC_default_async;
        case ACC_CLAUSE_LINK:            return ACCC_link;
        case ACC_CLAUSE_NO_CREATE:       return ACCC_no_create;
        case ACC_CLAUSE_NOHOST:          return ACCC_nohost;
        case ACC_CLAUSE_PRESENT:         return ACCC_present;
        case ACC_CLAUSE_PRIVATE:         return ACCC_private;
        case ACC_CLAUSE_REDUCTION:       return ACCC_reduction;
        case ACC_CLAUSE_READ:            return ACCC_read;
        case ACC_CLAUSE_SELF:            return ACCC_self;
        case ACC_CLAUSE_TILE:            return ACCC_tile;
        case ACC_CLAUSE_USE_DEVICE:      return ACCC_use_device;
        case ACC_CLAUSE_ATTACH:          return ACCC_attach;
        case ACC_CLAUSE_DETACH:          return ACCC_detach;
        case ACC_CLAUSE_FINALIZE:        return ACCC_finalize;
        case ACC_CLAUSE_IF_PRESENT:      return ACCC_if_present;
        case ACC_CLAUSE_CAPTURE:         return ACCC_capture;
        case ACC_CLAUSE_WRITE:           return ACCC_write;
        case ACC_CLAUSE_UPDATE:          return ACCC_update;
        case ACC_CLAUSE_COPY:            return ACCC_copy;
        case ACC_CLAUSE_COPYIN:          return ACCC_copyin;
        case ACC_CLAUSE_COPYOUT:         return ACCC_copyout;
        case ACC_CLAUSE_CREATE:          return ACCC_create;
        case ACC_CLAUSE_DELETE:          return ACCC_delete;
        case ACC_CLAUSE_DEVICE:          return ACCC_device;
        case ACC_CLAUSE_DEVICEPTR:       return ACCC_deviceptr;
        case ACC_CLAUSE_DEVICE_NUM:      return ACCC_device_num;
        case ACC_CLAUSE_DEVICE_RESIDENT: return ACCC_device_resident;
        case ACC_CLAUSE_HOST:            return ACCC_host;
        default:                         return ACCC_unknown;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

extern "C" {

OpenACCDirective* parseOpenACC(const char* input, void* exprParse(const char* expr)) {
    if (!input || input[0] == '\0') {
        return nullptr;
    }

    // Validate input length using constant from ROUP C API
    // Manual safe strlen to avoid non-portable strnlen (POSIX.1-2008)
    size_t input_len = 0;
    while (input_len < ROUP_MAX_PRAGMA_LENGTH && input[input_len] != '\0') {
        ++input_len;
    }
    // If loop exited because we hit the limit (not because we found '\0'),
    // the input is too long or not null-terminated within bounds
    // Check if we exited due to reaching the limit AND the last checked char wasn't NUL
    if (input_len == ROUP_MAX_PRAGMA_LENGTH && (input_len == 0 || input[input_len - 1] != '\0')) {
        return nullptr;  // Input too long or not null-terminated within limit
    }

    // Determine input format based on current language mode (auto-detect Fortran)
    std::string input_str(input, input_len);
    auto has_prefix_icase = [](const std::string& value, const char* prefix) {
        const size_t len = std::strlen(prefix);
        return value.size() >= len &&
               strncasecmp(value.c_str(), prefix, len) == 0;
    };

    OpenACCBaseLang effective_lang = current_lang;
    // Auto-detect Fortran sentinels when lang is not explicitly set
    if (effective_lang == ACC_Lang_C) {
        const std::string trimmed = input_str;
        if (has_prefix_icase(trimmed, "!$acc") || has_prefix_icase(trimmed, "c$acc") ||
            has_prefix_icase(trimmed, "*$acc")) {
            effective_lang = ACC_Lang_Fortran;
        }
    }

    // Handle different language pragmas
    if (effective_lang == ACC_Lang_Fortran) {
        // Fortran uses !$acc prefix - add if missing (case-insensitive check)
        const bool has_prefix =
            input_str.length() >= FORTRAN_PREFIX_LEN &&
            (input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX) == 0 ||
             input_str.compare(0, FORTRAN_PREFIX_LEN, FORTRAN_PREFIX_UPPER) == 0);
        if (!has_prefix) {
            input_str = std::string(FORTRAN_PREFIX) + " " + input_str;
        }
    } else {
        // C/C++ use #pragma acc prefix - add if missing
        if (input_str.compare(0, C_PRAGMA_PREFIX_LEN, C_PRAGMA_PREFIX) != 0) {
            input_str = std::string(C_PRAGMA_PREFIX) + " " + input_str;
        }
    }

    // Call ROUP parser with language setting to honor setLang()
    // Map accparser language to ROUP language constants (roup_constants.h)
    // ROUP_LANG_C = 0, ROUP_LANG_FORTRAN_FREE = 1, ROUP_LANG_FORTRAN_FIXED = 2
    int32_t roup_lang = (effective_lang == ACC_Lang_Fortran) ? 1 : 0; // 0=C, 1=Fortran free-form
    AccDirective* roup_dir = acc_parse_with_language(input_str.c_str(), roup_lang);
    if (!roup_dir) {
        return nullptr;
    }

    // Get directive kind from ROUP
    int32_t roup_kind = acc_directive_kind(roup_dir);
    OpenACCDirectiveKind kind = mapRoupToAccparserDirective(roup_kind);

    // Debug: print directive kind if unknown
    if (kind == ACCD_unknown) {
        fprintf(stderr, "WARNING: Unknown directive kind from ROUP: %d\n", roup_kind);
    }

    // Create accparser-compatible directive
    // Cache and Wait directives need special handling
    OpenACCDirective* dir = nullptr;

    if (kind == ACCD_cache) {
        // Create OpenACCCacheDirective
        OpenACCCacheDirective* cache_dir = new OpenACCCacheDirective();
        cache_dir->setBaseLang(effective_lang);

        // Get cache modifier (0=none, 1=readonly)
        int32_t cache_modifier = acc_cache_directive_modifier(roup_dir);
        if (cache_modifier == 1) {
            cache_dir->setModifier(ACCC_CACHE_readonly);
        }

        // Get cache variables
        int32_t var_count = acc_cache_directive_var_count(roup_dir);
        for (int32_t i = 0; i < var_count; i++) {
            const char* var = acc_cache_directive_var_at(roup_dir, i);
            if (var) {
                cache_dir->addVar(std::string(var));
            }
        }

        dir = cache_dir;
    } else if (kind == ACCD_wait) {
        // Create OpenACCWaitDirective
        OpenACCWaitDirective* wait_dir = new OpenACCWaitDirective();
        wait_dir->setBaseLang(effective_lang);

        int32_t expr_count = acc_directive_wait_expression_count(roup_dir);
        for (int32_t i = 0; i < expr_count; ++i) {
            const char* expr = acc_directive_wait_expression_at(roup_dir, i);
            if (expr) {
                wait_dir->addVar(std::string(expr));
            }
        }

        if (const char* devnum = acc_directive_wait_devnum(roup_dir)) {
            if (devnum[0] != '\0') {
                wait_dir->setDevnum(std::string(devnum));
            }
        }

        if (acc_directive_wait_has_queues(roup_dir)) {
            wait_dir->setQueues(true);
        }

        dir = wait_dir;
    } else if (kind == ACCD_routine) {
        // Create OpenACCRoutineDirective
        OpenACCRoutineDirective* routine_dir = new OpenACCRoutineDirective();
        routine_dir->setBaseLang(effective_lang);

        // Get routine name if present
        const char* routine_name = acc_directive_routine_name(roup_dir);
        if (routine_name && routine_name[0] != '\0') {
            routine_dir->setName(std::string(routine_name));
        }

        dir = routine_dir;
    } else if (kind == ACCD_end) {
        // Create OpenACCEndDirective
        OpenACCEndDirective* end_dir = new OpenACCEndDirective();
        end_dir->setBaseLang(effective_lang);

        // Get paired directive kind from ROUP
        int32_t paired_kind = acc_directive_end_paired_kind(roup_dir);
        if (paired_kind >= 0) {
            OpenACCDirectiveKind paired_acc_kind = mapRoupToAccparserDirective(paired_kind);
            // Create a minimal paired directive (just for toString generation)
            OpenACCDirective* paired = new OpenACCDirective(paired_acc_kind, effective_lang, 0, 0);
            end_dir->setPairedDirective(paired);
        } else {
            end_dir->setPairedDirective(nullptr);
        }

        dir = end_dir;
    } else {
        // Regular directive
        dir = new OpenACCDirective(kind, effective_lang, 0, 0);
    }

    // Convert clauses - get ALL data from ROUP's C API
    AccClauseIterator* iter = acc_directive_clauses_iter(roup_dir);
    if (iter) {
        const AccClause* roup_clause;
        while (acc_clause_iterator_next(iter, &roup_clause) == 1) {
            int32_t roup_kind_clause = acc_clause_kind(roup_clause);
            OpenACCClauseKind clause_kind = mapRoupToAccparserClause(roup_kind_clause);

            // Create clause using accparser's API
            OpenACCClause* clause = dir->addOpenACCClause(static_cast<int>(clause_kind));

            if (!clause) {
                fprintf(stderr,
                        "WARNING: addOpenACCClause returned null (directive=%d, clause=%d)\n",
                        static_cast<int>(kind),
                        static_cast<int>(clause_kind));
                continue;
            }

            if (const char* original_keyword = acc_clause_original_keyword(roup_clause)) {
                clause->setOriginalKeyword(std::string(original_keyword));
            }

            {
                // Get expressions from ROUP and add to accparser clause
                int32_t expr_count = acc_clause_expressions_count(roup_clause);
                for (int32_t i = 0; i < expr_count; i++) {
                    const char* expr = acc_clause_expression_at(roup_clause, i);
                    if (expr) {
                        clause->addLangExpr(std::string(expr));
                    }
                }

                // Handle modifiers for clauses that have them
                int32_t modifier = acc_clause_modifier(roup_clause);
                if (modifier != 0) {
                    switch (clause_kind) {
                        case ACCC_copyin:
                            if (modifier == 1) {
                                static_cast<OpenACCCopyinClause*>(clause)->setModifier(ACCC_COPYIN_readonly);
                            }
                            break;
                        case ACCC_copyout:
                            if (modifier == 1) {
                                static_cast<OpenACCCopyoutClause*>(clause)->setModifier(ACCC_COPYOUT_zero);
                            }
                            break;
                        case ACCC_create:
                            if (modifier == 1) {
                                static_cast<OpenACCCreateClause*>(clause)->setModifier(ACCC_CREATE_zero);
                            }
                            break;
                        case ACCC_vector:
                            if (modifier == 1) {
                                static_cast<OpenACCVectorClause*>(clause)->setModifier(ACCC_VECTOR_length);
                            }
                            break;
                        case ACCC_worker:
                            if (modifier == 1) {
                                static_cast<OpenACCWorkerClause*>(clause)->setModifier(ACCC_WORKER_num);
                            }
                            break;
                        case ACCC_reduction: {
                            OpenACCReductionClauseOperator acc_op = static_cast<OpenACCReductionClauseOperator>(modifier);
                            static_cast<OpenACCReductionClause*>(clause)->setOperator(acc_op);
                            break;
                        }
                        case ACCC_default:
                            static_cast<OpenACCDefaultClause*>(clause)->setKind(static_cast<OpenACCDefaultClauseKind>(modifier));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (clause_kind == ACCC_wait) {
                if (const char* devnum_value = acc_clause_wait_devnum(roup_clause)) {
                    static_cast<OpenACCWaitClause*>(clause)->setDevnum(std::string(devnum_value));
                }
                if (acc_clause_wait_has_queues(roup_clause)) {
                    static_cast<OpenACCWaitClause*>(clause)->setQueues(true);
                }
            }

            maybeMergeClause(dir, clause_kind, clause);
        }
        acc_clause_iterator_free(iter);
    }

    // Free ROUP directive (we've extracted what we need)
    acc_directive_free(roup_dir);

    return dir;
}

} // extern "C"

OpenACCDirective* parseOpenACC(std::string input) {
    return parseOpenACC(input.c_str(), nullptr);
}
