searchState.loadedDescShard("roup", 0, "Rust-based OpenMP/OpenACC Unified Parser (ROUP)\nMinimal Unsafe C API for OpenMP Parser\nOpenMP Intermediate Representation (IR)\nOpaque clause type (C-compatible)\nIterator over clauses\nOpaque directive type (C-compatible)\nList of strings (for variable names in clauses)\nC language (default) - uses #pragma omp\nFortran fixed-form - uses !$OMP or C$OMP in columns 1-6\nFortran free-form - uses !$OMP sentinel\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet default data sharing from default clause.\nFree a clause.\nFree clause iterator.\nGet next clause from iterator.\nGet clause kind.\nGet reduction operator from reduction clause.\nGet schedule kind from schedule clause.\nGet variable list from clause (private, shared, reduction, …\nGet number of clauses in a directive.\nCreate an iterator over directive clauses.\nFree a directive allocated by <code>roup_parse()</code>.\nGet directive kind.\nParse an OpenMP directive from a C string.\nParse an OpenMP directive with explicit language …\nFree string list.\nGet string at index from list.\nGet length of string list.\nAcquire-release ordering\nAcquire ordering\n<code>affinity([modifier:] list)</code> - Task affinity\n<code>aligned(list[:alignment])</code> - Aligned variables\nAllocate device memory without transfer\n<code>allocate([allocator:] list)</code> - Memory allocator\n<code>#pragma omp allocate</code>\n<code>allocator(allocator-handle)</code> - Specify allocator\nAny device\nArray subscript: <code>arr[i]</code>, <code>matrix[i][j]</code>\nArray section specification: <code>[lower:length:stride]</code>\n<code>#pragma omp atomic</code>\n<code>atomic_default_mem_order(seq_cst|acq_rel|...)</code> - Default …\nAtomic operation type\nAtomic operation modifier\nImplementation-defined scheduling\nClause with no parameters (e.g., <code>nowait</code>, <code>nogroup</code>)\n<code>#pragma omp barrier</code>\nBinary operation: <code>a + b</code>, <code>N * 2</code>, <code>i &lt; 10</code>\nBinary operators\nC language\nFunction call: <code>foo(a, b)</code>, <code>omp_get_num_threads()</code>\nAtomic capture\nComplete semantic data for an OpenMP clause\nItem that can appear in a clause list\nThreads execute close to the master thread (OpenMP 5.1 …\n<code>collapse(n)</code> - Collapse nested loops\nToo complex to parse, kept as string\nIterations may execute concurrently\nUpdate only if condition is true\nTernary conditional: <code>cond ? a : b</code>\n<code>copyin(list)</code> - Copy master thread value to team threads\n<code>copyprivate(list)</code> - Broadcast value from one thread\nC++ language\n<code>#pragma omp critical</code>\n<code>#pragma omp declare mapper</code>\n<code>#pragma omp declare reduction</code>\n<code>#pragma omp declare simd</code>\n<code>#pragma omp declare target</code>\n<code>#pragma omp declare variant</code>\n<code>default(shared|none|...)</code> - Default data-sharing attribute\nDefault data-sharing attribute\nDelete device memory\n<code>depend([modifier,] type: list)</code> - Task dependencies\nDependence type for task dependencies\nDependency on task completion\n<code>#pragma omp depobj</code>\n<code>device(expression)</code> - Target device\nDevice type for device-specific constructs\n<code>device_type(host|nohost|any)</code> - Device type specifier\nBuilder for constructing DirectiveIR with a fluent API\nComplete IR representation of an OpenMP directive\nOpenMP directive type\n<code>dist_schedule(kind[, chunk_size])</code> - Distribute schedule\n<code>#pragma omp distribute</code>\n<code>#pragma omp distribute parallel for</code>\n<code>#pragma omp distribute parallel for simd</code>\n<code>#pragma omp distribute simd</code>\nIterations divided into chunks, assigned dynamically at …\n<code>#pragma omp error</code>\nAn expression that may be parsed or unparsed\nExpression (e.g., <code>n &gt; 100</code> in <code>if(n &gt; 100)</code>)\nSingle expression parameter (e.g., <code>num_threads(4)</code>)\nParsed expression abstract syntax tree\nCommon expression patterns in OpenMP directives\n<code>filter(thread-num)</code> - Thread filter for masked construct\nVariables are firstprivate by default\n<code>firstprivate(list)</code> - Variables initialized from master …\n<code>#pragma omp flush</code>\n<code>#pragma omp for</code>\n<code>#pragma omp for simd</code>\nFortran language\nMap data from device (device → host)\nGeneric clause with unparsed data (fallback for unknown …\n<code>grainsize(expression)</code> - Taskloop grainsize\nSimilar to dynamic but chunk size decreases exponentially\n<code>has_device_addr(list)</code> - Variables have device addresses\nHost device\nA simple identifier (not an expression, not a variable …\nSimple identifier (e.g., <code>x</code> in <code>private(x)</code>)\nIdentifier: <code>N</code>, <code>num_threads</code>, <code>my_var</code>\n<code>if([directive-name-modifier:] expression)</code> - Conditional …\nRead dependency\nRead-write dependency\nInteger literal: <code>42</code>, <code>0x10</code>, <code>0b1010</code>\n<code>is_device_ptr(list)</code> - Variables are device pointers\nList of items (e.g., <code>private(x, y, z)</code>)\nSource programming language\n<code>lastprivate([modifier:] list)</code> - Variables updated from …\nLastprivate clause modifier\n<code>linear(list[:step])</code> - Linear variables in SIMD\nLinear clause modifier\n<code>#pragma omp loop</code>\n<code>map([[mapper(id),] map-type:] list)</code> - Map variables to …\nMap type for map clauses in target directives\n<code>#pragma omp masked</code>\nThreads execute close to the master thread\n<code>#pragma omp master</code>\nDefault memory order for atomic operations\n<code>#pragma omp metadirective</code>\nIterations assigned in monotonically increasing order\nMutual exclusion with inout\nNon-host device (accelerator)\nNo default (must specify for each variable)\nNo ordering guarantee (allows optimizations)\n<code>#pragma omp nothing</code>\n<code>num_tasks(expression)</code> - Number of tasks\n<code>num_teams(expression)</code> - Number of teams\n<code>num_threads(expression)</code> - Number of threads\n<code>order(concurrent)</code> - Iteration execution order\nOrder clause value\n<code>ordered[(n)]</code> - Ordered iterations\n<code>#pragma omp ordered</code>\nWrite dependency\n<code>#pragma omp parallel</code>\n<code>#pragma omp parallel for</code>\n<code>#pragma omp parallel for simd</code>\n<code>#pragma omp parallel loop</code>\n<code>#pragma omp parallel masked</code>\n<code>#pragma omp parallel master</code> (deprecated in 5.1)\n<code>#pragma omp parallel sections</code>\n<code>#pragma omp parallel workshare</code> (Fortran)\nParenthesized: <code>(expr)</code>\nExpression was successfully parsed into structured form\nConfiguration for IR generation and expression parsing\nImplementation-defined binding\n<code>priority(expression)</code> - Task priority\nVariables are private by default (Fortran only)\n<code>private(list)</code> - Variables are private to each thread\nThread affinity policy\n<code>proc_bind(master|close|spread|primary)</code> - Thread affinity …\nAtomic read\n<code>reduction([modifier,]operator: list)</code> - Reduction operation\nReduction operator for reduction clauses\nReference to linear variable\nRelaxed ordering (weakest)\nRelease device memory\nRelease ordering\n<code>#pragma omp requires</code>\nRuntime determines schedule via environment variable\n<code>safelen(length)</code> - Safe SIMD vector length\n<code>#pragma omp scan</code>\n<code>schedule([modifier [, modifier]:]kind[, chunk_size])</code> - …\nSchedule kind for loop scheduling\nSchedule modifier for schedule clause\n<code>#pragma omp section</code>\n<code>#pragma omp sections</code>\nSequential consistency (strongest)\nVariables are shared by default\n<code>shared(list)</code> - Variables shared among all threads\nSIMD execution of iterations\n<code>#pragma omp simd</code>\n<code>simdlen(length)</code> - Preferred SIMD vector length\n<code>#pragma omp single</code>\nSink dependency (OpenMP 5.0)\nSource dependency (OpenMP 5.0)\nSource code location information\nThreads spread out across available processors\nIterations divided into chunks of specified size, assigned …\n<code>#pragma omp target</code>\n<code>#pragma omp target data</code>\n<code>#pragma omp target enter data</code>\n<code>#pragma omp target exit data</code>\n<code>#pragma omp target parallel</code>\n<code>#pragma omp target parallel for</code>\n<code>#pragma omp target parallel for simd</code>\n<code>#pragma omp target parallel loop</code>\n<code>#pragma omp target simd</code>\n<code>#pragma omp target teams</code>\n<code>#pragma omp target teams distribute</code>\n<code>#pragma omp target teams distribute parallel for</code>\n<code>#pragma omp target teams distribute parallel for simd</code>\n<code>#pragma omp target teams distribute simd</code>\n<code>#pragma omp target teams loop</code>\n<code>#pragma omp target update</code>\n<code>#pragma omp task</code>\n<code>#pragma omp taskgroup</code>\n<code>#pragma omp taskloop</code>\n<code>#pragma omp taskloop simd</code>\n<code>#pragma omp taskwait</code>\n<code>#pragma omp taskyield</code>\n<code>#pragma omp teams</code>\n<code>#pragma omp teams distribute</code>\n<code>#pragma omp teams distribute parallel for</code>\n<code>#pragma omp teams distribute parallel for simd</code>\n<code>#pragma omp teams distribute simd</code>\n<code>#pragma omp teams loop</code>\n<code>thread_limit(expression)</code> - Thread limit per team\n<code>#pragma omp threadprivate</code>\nMap data to device (host → device)\nMap data to and from device (bidirectional)\nUnary operation: <code>-x</code>, <code>!flag</code>, <code>*ptr</code>\nUnary operators\nUnknown or custom directive\nUnknown or unspecified language\nExpression kept as raw string\nAtomic update\n<code>use_device_addr(list)</code> - Use device addresses\n<code>use_device_ptr(list)</code> - Use device pointers\nUniform across SIMD lanes\nLinear variable value\nA variable reference, possibly with array sections\nVariable with optional array sections (e.g., <code>arr[0:N]</code> in …\n<code>#pragma omp workshare</code> (Fortran)\nAtomic write\nCreate an array section for all elements: <code>arr[:]</code>\nArray sections (empty for scalar variables)\nGet the parsed AST if available\nGet the raw string representation\nGet the identifier as a string slice\nCreate a barrier directive (always simple)\nBuild the DirectiveIR\nGet the clauses\nAdd a collapse clause with expression\nColumn number (1-indexed, as in editors)\nConversion from parser types to IR types\nCount clauses matching predicate\nAdd a default clause with specified kind\nDefault: parse expressions, unknown language\nDefault location is at the start of a file (1, 1)\nDefault to unknown language\nAdd a default(none) clause\nAdd a default(shared) clause\nAdd a depend clause\nGet the number of dimensions\nGet all clauses matching predicate\nFind first clause matching predicate\nAdd a firstprivate clause\nFormat as “line:column” for error messages\nFormat language name for display\nFormat as OpenMP array section syntax\nFormat as OpenMP variable syntax\nCreate a new builder for a for directive\nCreate a for loop directive with schedule\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if this directive has a specific clause type\nCheck if this directive has a structured block (requires …\nAdd an if clause\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this represents all elements\nCheck if this is an array (has sections)\nCheck if this language uses C-style syntax\nCheck if this is a collapse clause\nCheck if this is a declare construct\nCheck if this is a default clause\nCheck if this is a depend clause\nCheck if this is a device clause\nCheck if this is a firstprivate clause\nCheck if this language is Fortran\nCheck if this is an if clause\nCheck if this is a lastprivate clause\nCheck if this is a linear clause\nCheck if this is a loop construct\nCheck if this is a map clause\nCheck if this is a num_threads clause\nCheck if this is an ordered clause\nCheck if this is a parallel construct\nCheck if expression was successfully parsed\nCheck if this is a private clause\nCheck if this is a proc_bind clause\nCheck if this is a reduction clause\nCheck if this is a scalar (no array sections)\nCheck if this is a schedule clause\nCheck if this is a shared clause\nCheck if this is a SIMD construct\nCheck if this represents a single index access\nCheck if this is a synchronization construct\nCheck if this is a target construct\nCheck if this is a task construct\nCheck if this is a teams construct\nCheck if this is a work-sharing construct\nGet the directive kind\nParsed structure (best-effort)\nGet the language\nSource language (affects expression parsing rules)\nLength (number of elements)\nLine number (1-indexed, as in editors)\nGet the source location\nLower bound (starting index)\nAdd a map clause\nGet the identifier name\nGet the variable name\nCreate a new builder for any directive kind\nCreate a new directive IR\nCreate a new configuration\nCreate a new expression, attempting to parse if enabled\nCreate a new source location\nCreate a new identifier\nCreate a new array section with all fields\nCreate a new variable without array sections (scalar)\nAdd a nowait clause\nAdd a num_threads clause\nAdd a num_threads clause with expression\nAdd an ordered clause\nAdd an ordered clause with parameter\nOriginal source text (always preserved)\nCreate a new builder for a parallel directive\nCreate a parallel directive with common clauses\nCreate a new builder for a parallel for directive\nWhether to attempt parsing expressions into structured form\nGet the pragma prefix for this language\nAdd a private clause\nAdd a proc_bind clause\nAdd a reduction clause\nAdd a schedule clause with chunk size expression\nAdd a schedule clause\nAdd a schedule clause with modifiers\nAdd a shared clause\nCreate a simple directive with no clauses\nCreate an array section for a single index: <code>arr[i]</code>\nCreate a location at the start of a file\nStride (spacing between elements)\nCreate config that keeps all expressions as strings\nCreate a new builder for a target directive\nCreate a new builder for a task directive\nCreate a taskwait directive (always simple)\nCreate a taskyield directive (always simple)\nCreate a new builder for a teams directive\nCreate an unparsed expression directly\nIR validation utilities\nValidate this directive and its clauses\nCreate config that parses expressions\nCreate a variable with array sections\nError type for conversion failures\nInvalid clause syntax\nUnknown clause name\nUnknown directive name\nUnsupported feature\nConvert a parser Directive to IR DirectiveIR\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvert a parser Clause to IR ClauseData\nParse a dependence type from a string\nConvert a directive name string to DirectiveKind\nParse a simple identifier list from a string\nParse a linear clause\nParse a map clause\nParse a reduction operator from a string\nParse a schedule clause\nClause not allowed on this directive\nConflicting clauses\nInvalid clause combination\nMissing required clause\nValidation context for checking clause compatibility\nValidation error types\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a clause is allowed on this directive\nCreate a new validation context for a directive\nValidate all clauses in a directive\nC/C++ language with #pragma omp\nFortran fixed-form with !$OMP or C$OMP in columns 1-6\nFortran free-form with !$OMP sentinel\nLanguage format for parsing\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if a character is valid in an identifier\nParse a clause name (e.g., “private”, “nowait”)\nParse a directive name (e.g., “parallel”, “for”)\nParse Fortran fixed-form sentinel “!$OMP” or “C$OMP…\nParse Fortran free-form sentinel “!$OMP” …\nParse an identifier token (exposed publicly)\nParse “omp” keyword\nParse “#pragma” keyword\nNormalize Fortran identifier to lowercase for …\nSkip whitespace/comments - requires at least one\nSkip whitespace and C-style comments\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")