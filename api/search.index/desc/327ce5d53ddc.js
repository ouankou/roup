rd_("jC languageAoC/C++ language with #pragma ompCn<code>!$omp do</code> (Fortran equivalent of <code>for</code>)Dh<code>if([directive-name-modifier:] expression)</code> - Conditional \xe2\x80\xa6oRead dependencyAjContains the success valueBdMap data to device (host \xe2\x86\x92 device)BgOpenMP Intermediate Representation (IR)jAny devicelC++ languageAhContains the error valueAl<code>#pragma omp for</code>Dg<code>map([[mapper(id),] map-type:] list)</code> - Map variables to \xe2\x80\xa6A`Write dependencyAlReference to linear variableAeLinear variable valueCmCreate an array section for all elements: <code>arr[:]</code>BnFormat as \xe2\x80\x9cline:column\xe2\x80\x9d for error messagesB`Format language name for displayBeFormat as OpenMP array section syntaxB`Format as OpenMP variable syntaxClHeader verification binary - ensures roup_constants.h is \xe2\x80\xa6CnReturn the length (number of bytes) of this directive name \xe2\x80\xa6A`Add a map clauseCkCreate a new debug session and parse the input step-by-stepBkCreate a new builder for any directive kindAiCreate a new directive IRAjCreate a new configurationCgCreate a new expression, attempting to parse if enabledAlCreate a new source locationAgCreate a new identifierBjCreate a new array section with all fieldsCeCreate a new variable without array sections (scalar)BoCreate a new validation context for a directiveBaImplementation-defined schedulingDkClause with no parameters (e.g., <code>nowait</code>, <code>nogroup</code>)DiFunction call: <code>foo(a, b)</code>, <code>omp_get_num_threads()</code>BfMap data from device (device \xe2\x86\x92 host)Am<code>#pragma omp fuse</code>iShow helpkHost deviceoGo to last stepAm<code>#pragma omp loop</code>AaMove to next stepBkNo default (must specify for each variable)dQuitkAtomic readAm<code>#pragma omp scan</code>AlSIMD execution of iterationsAm<code>#pragma omp simd</code>AlSink dependency (OpenMP 5.0)Am<code>#pragma omp task</code>Am<code>#pragma omp tile</code>AiUniform across SIMD lanesAoReturns the argument unchanged.0000000000000000000000000000000000000000000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.0000000000000000000000000000000000000000000000000000000000000000000000000000AjType/category of this stepAfGet the directive kindAnParsed structure (best-effort)BfLine number (1-indexed, as in editors)BaGet the normalized directive nameAgGet the identifier nameAeGet the variable nameBoRust-based OpenMP/OpenACC Unified Parser (ROUP)BiCreate a new builder for a task directiveBgAllocate device memory without transferCjThreads execute close to the master thread (OpenMP 5.1 \xe2\x80\xa6nError occurredAn<code>#pragma omp error</code>A`Go to first stepAn<code>#pragma omp flush</code>AeRead-write dependencyCj<code>order(concurrent)</code> - Iteration execution orderBaUnknown or unregistered directiveBk<code>#pragma omp scope</code> (OpenMP 5.1)An<code>#pragma omp split</code>An<code>#pragma omp teams</code>lAtomic writeAeBuild the DirectiveIRBfMinimal Unsafe C API for OpenMP ParserAgParse error (if failed)AmCheck if this is an if clauseBhCreate a location at the start of a fileBbAll steps collected during parsingBjCreate a new builder for a teams directiveAhAcquire-release orderingBl<code>#pragma omp assume</code> (OpenMP 6.0)Ao<code>#pragma omp atomic</code>Bl<code>#pragma omp cancel</code> (OpenMP 4.0)Dd<code>copyin(list)</code> - Copy master thread value to team threadsAdDelete device memoryCo<code>depend([modifier,] type: list)</code> - Task dependenciesAmDependency on task completionAo<code>#pragma omp depobj</code>Bo<code>device(expression)</code> - Target deviceDh<code>!$omp do simd</code> (Fortran equivalent of <code>for simd</code>)Dd<code>filter(thread-num)</code> - Thread filter for masked constructCiSimilar to dynamic but chunk size decreases exponentiallyCk<code>linear(list[:step])</code> - Linear variables in SIMDAo<code>#pragma omp masked</code>BjThreads execute close to the master threadAo<code>#pragma omp master</code>AmNon-host device (accelerator)CgExpression was successfully parsed into structured formBbSequential consistency (strongest)AoVariables are shared by defaultCn<code>shared(list)</code> - Variables shared among all threadsAo<code>#pragma omp single</code>AnSource dependency (OpenMP 5.0)BnThreads spread out across available processorsCnIterations divided into chunks of specified size, assigned \xe2\x80\xa6Ao<code>#pragma omp stripe</code>Ao<code>#pragma omp target</code>BkMap data to and from device (bidirectional)Ao<code>#pragma omp unroll</code>mAtomic updateAoGet the parsed AST if availableBlGet the canonical directive name as a stringBaGet the raw string representationBdGet the identifier as a string sliceBnReturn a string slice for this directive name.BhColumn number (1-indexed, as in editors)AnConfiguration for this sessionAcAdd a depend clauseBeCheck if this represents all elementsAmCheck if this is a map clauseAkLength (number of elements)AcAdd a nowait clauseAcAdd a shared clauseBiCreate a simple directive with no clausesBaStride (spacing between elements)BkCreate a new builder for a target directiveA`Acquire orderingCj<code>aligned(list[:alignment])</code> - Aligned variablesBm<code>#pragma omp assumes</code> (OpenMP 6.0)B`<code>#pragma omp barrier</code>nAtomic captureBdToo complex to parse, kept as stringDf<code>default(shared|none|...)</code> - Default data-sharing attributeCkIterations divided into chunks, assigned dynamically at \xe2\x80\xa6Ba<code>#pragma omp for simd</code>A`Fortran languageCkGeneric clause with unparsed data (fallback for unknown \xe2\x80\xa6Bm<code>#pragma omp interop</code> (OpenMP 5.1)oInvalid commandAbInput/output errorBmMap type for map clauses in target directivesB`<code>#pragma omp nothing</code>Bn<code>ordered[(n)]</code> - Ordered iterationsB`<code>#pragma omp ordered</code>AnImplementation-defined bindingBoVariables are private by default (Fortran only)Da<code>private(list)</code> - Variables are private to each threadAjRelaxed ordering (weakest)AeRelease device memoryA`Release orderingB`<code>#pragma omp reverse</code>CdRuntime determines schedule via environment variableCf<code>safelen(length)</code> - Safe SIMD vector lengthB`<code>#pragma omp section</code>AaShow complete ASTCk<code>simdlen(length)</code> - Preferred SIMD vector lengthDgUnary operation: <code>-x</code>, <code>!flag</code>, <code>*ptr</code>AkUnknown or custom directiveAoUnknown or unspecified languageBjCreate a barrier directive (always simple)oGet the clausesBhConversion from parser types to IR typesBhAdd a default clause with specified kindBlDefault: parse expressions, unknown languageCaDefault location is at the start of a file (1, 1)AkDefault to unknown languageBaCheck if this is a loop constructBaCheck if this is a SIMD constructBaCheck if this is a task constructBcParse \xe2\x80\x9cacc\xe2\x80\x9d keyword for OpenACCBhParse \xe2\x80\x9comp\xe2\x80\x9d keyword (OpenMP default)AeAdd an ordered clauseAdAdd a private clauseCg<code>affinity([modifier:] list)</code> - Task affinityCk<code>allocate([allocator:] list)</code> - Memory allocatorBa<code>#pragma omp allocate</code>AeAtomic operation typeE`Binary operation: <code>a + b</code>, <code>N * 2</code>, <code>i &lt; 10</code>C`<code>collapse(n)</code> - Collapse nested loopsBbCompleted parsing entire directiveBa<code>#pragma omp critical</code>Bn<code>#pragma omp dispatch</code> (OpenMP 6.0)AjGo to specific step numberCcList of items (e.g., <code>private(x, y, z)</code>)AkSource programming languageAkLanguage format for parsingCd<code>num_tasks(expression)</code> - Number of tasksCd<code>num_teams(expression)</code> - Number of teamsBa<code>#pragma omp parallel</code>AeMove to previous stepCa<code>priority(expression)</code> - Task priorityDi<code>proc_bind(master|close|spread|primary)</code> - Thread affinity \xe2\x80\xa6AfThread affinity policyBa<code>#pragma omp requires</code>Dg<code>schedule([modifier [, modifier]:]kind[, chunk_size])</code> - \xe2\x80\xa6Ba<code>#pragma omp sections</code>AiShow current step detailsAkCategories of parsing stepsBa<code>#pragma omp taskloop</code>Ba<code>#pragma omp taskwait</code>AmExpression kept as raw stringDiVariable with optional array sections (e.g., <code>arr[0:N]</code> in \xe2\x80\xa6CbA variable reference, possibly with array sectionsBeAdd a collapse clause with expressionBjThe portion of input consumed in this stepCnStep-by-step parser debugger for educational and debugging \xe2\x80\xa6BhCreate a new builder for a for directiveBiCreate a for loop directive with scheduleBhCheck if this is an array (has sections)BlReturn true if this directive name is empty.BbCheck if this is a teams constructA`Get the languageAlGet the configured language.AgGet the source locationBmCreate a new builder for a parallel directiveBoCreate a parallel directive with common clausesBfCurrent position in the original inputC`Add a schedule clause with chunk size expressionBkCreate a taskwait directive (always simple)BfCreate an unparsed expression directlyBgValidate this directive and its clausesAgIR validation utilitiesCl<code>allocator(allocator-handle)</code> - Specify allocatorBoRepresents a single step in the parsing processBc<code>#pragma omp end target</code>Cg<code>grainsize(expression)</code> - Taskloop grainsizeCeIterations assigned in monotonically increasing orderBaOpaque clause type (C-compatible)AbOrder clause valueDg<code>reduction([modifier,]operator: list)</code> - Reduction operationjShow inputBo<code>#pragma omp taskgraph</code> (OpenMP 6.0)Bb<code>#pragma omp taskgroup</code>Bb<code>#pragma omp taskyield</code>Bc<code>#pragma omp teams loop</code>Bl<code>#pragma omp workshare</code> (Fortran)A`Add an if clauseB`Check if this is a depend clauseB`Check if this is a device clauseB`Check if this is a linear clauseBkCheck if expression was successfully parsedBmCheck if this is a scalar (no array sections)B`Check if this is a shared clauseBcCheck if this is a target constructClReturn the typed directive name (lookup in the canonical \xe2\x80\xa6AeMove to the next stepBdAdd an ordered clause with parameterAiMove to the previous stepAfAdd a proc_bind clauseAfAdd a reduction clauseBkThe remaining unparsed text after this stepBlCreate a taskyield directive (always simple)BfC/C++ to Fortran directive translationC`<code>#pragma omp allocators</code> (OpenMP 6.0)Bd<code>#pragma omp atomic read</code>BkComplete semantic data for an OpenMP clauseBeItem that can appear in a clause listBmParsing a clause name (shared, private, etc.)BkTyped representation of known clause names.BcIterations may execute concurrentlyBfErrors that can occur during debuggingBeDependence type for task dependenciesDa<code>device_type(host|nohost|any)</code> - Device type specifierBjDevice type for device-specific constructsBc<code>#pragma omp distribute</code>CcInput string was empty or contained only whitespaceDiExpression (e.g., <code>n &gt; 100</code> in <code>if(n &gt; 100)</code>)CoSingle expression parameter (e.g., <code>num_threads(4)</code>)BlAn expression that may be parsed or unparsedCkStructured gang clause with optional modifier and variablesDcSimple identifier (e.g., <code>x</code> in <code>private(x)</code>)DiIdentifier: <code>N</code>, <code>num_threads</code>, <code>my_var</code>CjA simple identifier (not an expression, not a variable \xe2\x80\xa6DhInteger literal: <code>42</code>, <code>0x10</code>, <code>0b1010</code>Ch<code>num_threads(expression)</code> - Number of threadsE`<code>!$omp parallel do</code> (Fortran equivalent of <code>parallel for</code>)B`Parser failed to parse the inputBhParser failed to recognize the directiveBd<code>#pragma omp target data</code>Bd<code>#pragma omp target loop</code>Bd<code>#pragma omp target simd</code>AlGet the number of dimensionsAoParse a command from user inputCbCheck if this directive has a specific clause typeBdCheck if this is a declare constructBaCheck if this is a default clauseBaCheck if this language is FortranBbCheck if this is an ordered clauseBaCheck if this is a private clauseCgParse a clause name (e.g., \xe2\x80\x9cprivate\xe2\x80\x9d, \xe2\x80\x9cnowait\xe2\x80\x9d)AkParse \xe2\x80\x9c#pragma\xe2\x80\x9d keywordBhInteractive step-by-step parser debuggerBjParse an OpenMP directive from a C string.C`Token or structure created in this step (if any)CoArray subscript: <code>arr[i]</code>, <code>matrix[i][j]</code>Be<code>#pragma omp atomic write</code>B`Update only if condition is trueBnTernary conditional: <code>cond ? a : b</code>D`<code>copyprivate(list)</code> - Broadcast value from one threadBcConfiguration for the debug sessionBcResult type for debugger operationsBe<code>#pragma omp declare simd</code>AnDefault data-sharing attributeCaComplete IR representation of an OpenMP directiveBeFortran free-form with !$OMP sentinelBd<code>#pragma omp interchange</code>D`<code>is_device_ptr(list)</code> - Variables are device pointersDg<code>lastprivate([modifier:] list)</code> - Variables updated from \xe2\x80\xa6BjDefault memory order for atomic operationsBe<code>#pragma omp parallel for</code>BgC language (default) - uses #pragma ompAfShow all steps historyBe<code>#pragma omp target teams</code>Cm<code>thread_limit(expression)</code> - Thread limit per teamCmFeature recognised by the parser but not yet supported in \xe2\x80\xa6BnUser commands for navigating the debug sessionBnDescription of what\xe2\x80\x99s happening in this stepBdFind first clause matching predicateBjCheck if this language uses C-style syntaxBbCheck if this is a collapse clauseBeCheck if this is a parallel constructBbCheck if this is a schedule clauseAlLower bound (starting index)AhAdd a num_threads clauseBbSequential step number (0-indexed)CcCreate config that keeps all expressions as stringsAiGet total number of stepsCoArray section specification: <code>[lower:length:stride]</code>Bf<code>#pragma omp atomic update</code>Bf<code>#pragma omp begin assumes</code>BoStructured copyin clause with optional modifierBoStructured create clause with optional modifierCbA complete debugging session that tracks all stepsDd<code>dist_schedule(kind[, chunk_size])</code> - Distribute scheduleBeVariables are firstprivate by defaultDg<code>firstprivate(list)</code> - Variables initialized from master \xe2\x80\xa6CeFortran fixed-form with !$OMP or C$OMP in columns 1-6Cb<code>#pragma omp groupprivate</code> (OpenMP 6.0)mInvalid inputBlNo ordering guarantee (allows optimizations)BdOpaque directive type (C-compatible)Bf<code>#pragma omp parallel loop</code>CfConfiguration for IR generation and expression parsingCdParsing the pragma prefix (#pragma omp, !$omp, etc.)BaSchedule kind for loop schedulingBf<code>#pragma omp target update</code>Bf<code>#pragma omp taskloop simd</code>C`Special value for unknown directive/clause kindsCg<code>use_device_ptr(list)</code> - Use device pointersCmSimple variable list clause (e.g., wait(x, y), private(i, \xe2\x80\xa6CgStructured vector clause with optional modifier and \xe2\x80\xa6CgStructured worker clause with optional modifier and \xe2\x80\xa6AdGet the current stepAjAdd a default(none) clauseAiAdd a firstprivate clauseChReturn a copy of this configuration using a specific \xe2\x80\xa6BcCheck if this is a proc_bind clauseBcCheck if this is a reduction clauseCaCreate a new builder for a parallel for directiveBkSet the language context for this directiveCoCreate an array section for a single index: <code>arr[i]</code>CbGet all steps up to and including the current stepAkReturn the lowercase stringBcValidate all clauses in a directiveBeCreate config that parses expressionsBg<code>#pragma omp atomic capture</code>C`Structured copyout clause with optional modifierBg<code>#pragma omp declare mapper</code>Bg<code>#pragma omp declare target</code>AeOpenMP directive typeBnParsing a directive name (parallel, for, etc.)BnTyped representation of known directive names.BfParsed expression abstract syntax treeDd<code>has_device_addr(list)</code> - Variables have device addressesBf<code>#pragma omp metadirective</code>AkMutual exclusion with inoutBoList of strings (for variable names in clauses)BbParenthesized: <code>(expr)</code>Cd<code>#pragma omp task iteration</code> (OpenMP 6.0)Bh<code>#pragma omp teams loop simd</code>Bf<code>#pragma omp threadprivate</code>oUnary operatorsCbUnknown clause name encountered during conversion.Ci<code>use_device_addr(list)</code> - Use device addressesCjShared code for generating and validating roup_constants.hCnParser context stack (e.g., [\xe2\x80\x9cDirectiveRegistry::parse\xe2\x80\x9d\xe2\x80\xa6B`Count clauses matching predicateCcCreate a new directive IR with a different languageChParse a directive name (e.g., \xe2\x80\x9cparallel\xe2\x80\x9d, \xe2\x80\x9cfor\xe2\x80\x9d)CeMerge duplicate clauses and deduplicate variables \xe2\x80\xa6BgGet the pragma prefix for this languageBmOverride the language for this configuration.BeCreate a variable with array sectionsA`Binary operatorsAnOpenACC copyin clause modifierAnOpenACC create clause modifierBh<code>#pragma omp declare variant</code>Bh<code>#pragma omp distribute simd</code>BoCommon expression patterns in OpenMP directivesAfLinear clause modifierBh<code>#pragma omp masked taskloop</code>Cn<code>!$omp parallel do simd</code> (Fortran equivalent of \xe2\x80\xa6Bh<code>#pragma omp parallel masked</code>Cl<code>#pragma omp parallel master</code> (deprecated in 5.1)AoSkipping whitespace or commentsB`Source code location informationBi<code>#pragma omp target exit data</code>Bi<code>#pragma omp target loop simd</code>Bh<code>#pragma omp target parallel</code>Cm<code>#pragma omp workdistribute</code> (Fortran, OpenMP 6.0)BkArray sections (empty for scalar variables)AlAdd a default(shared) clauseBbGet all clauses matching predicateBeCheck if this is a lastprivate clauseBeCheck if this is a num_threads clauseBiCheck if this is a work-sharing constructAeOriginal input stringAiAtomic operation modifierCiParsing clause arguments (the content inside parentheses)CeSemantic conversion failed (unknown directive/clause)ChError type for conversion failures when building the IR.AoOpenACC copyout clause modifierBj<code>#pragma omp parallel for simd</code>BiStructured reduction clause with operatorBj<code>#pragma omp target enter data</code>Bj<code>#pragma omp target teams loop</code>Bi<code>#pragma omp teams distribute</code>AfValidation error typesBfFinal parsed directive (if successful)BfCheck if this is a firstprivate clauseBnCheck if this represents a single index accessBgOriginal source text (always preserved)AeAdd a schedule clauseBdClause not allowed on this directiveCg<code>#pragma omp declare induction</code> (OpenMP 6.0)Bj<code>#pragma omp declare reduction</code>CfBuilder for constructing DirectiveIR with a fluent APIBk<code>#pragma omp end declare target</code>AoFNV-1a hash algorithm constantsBk<code>#pragma omp parallel loop simd</code>Bj<code>#pragma omp parallel sections</code>BeSchedule modifier for schedule clauseBo<code>!$omp target parallel do</code> (Fortran)CbErrors that can occur during directive translationCeUnknown directive name encountered during conversion.CaDisplay a directive as a formatted tree structureBhAdd a num_threads clause with expressionAbParse a map clausenFree a clause.A`Get clause kind.D`Free a string allocated by <code>roup_convert_language()</code>.Ch<code>#pragma omp cancellation point</code> (OpenMP 4.0)Bl<code>#pragma omp end declare variant</code>AeIterator over clausesCe<code>#pragma omp parallel workshare</code> (Fortran)BaOpenACC reduction clause operatorBhReduction operator for reduction clausesBl<code>#pragma omp target parallel for</code>CdValidation context for checking clause compatibilityClAssign unique numeric placeholders for entries that were \xe2\x80\xa6BlConvert a parser Directive to IR DirectiveIRBnCheck if a clause is allowed on this directiveBhGet the language-specific directive nameBhConvert a parser Clause to IR ClauseDataBeParse a dependence type from a stringCkWhether to attempt parsing expressions into structured formBm<code>#pragma omp begin declare target</code>Bl<code>#pragma omp begin metadirective</code>AcConflicting clausesCnParsing directive parameter (e.g., \xe2\x80\x9cparallel(n)\xe2\x80\x9d -&gt; \xe2\x80\xa6CfTyped representation for directive parameters when \xe2\x80\xa6AjInvalid clause combinationBm<code>#pragma omp masked taskloop simd</code>Bm<code>#pragma omp target parallel loop</code>CjCalculate FNV-1a hash checksum of directive and clause \xe2\x80\xa6BmCurrent step index for interactive navigationBnCheck if a character is valid in an identifierBlCheck if this is a synchronization constructCmLookup a ClauseName from a normalized name string. If not \xe2\x80\xa6Bn<code>#pragma omp begin declare variant</code>CkClause text could not be interpreted according to the spec.AkLastprivate clause modifierBo<code>#pragma omp target teams loop simd</code>Bn<code>#pragma omp teams distribute simd</code>CfParse a dialect keyword following <code>#pragma</code>AeParse a linear clauseChFree a directive allocated by <code>roup_parse()</code>.AcGet directive kind.BaGet directive name as a C string.CkRun the debugger in non-interactive mode (just show all \xe2\x80\xa6CkConvert CamelCase variant name to UPPER_SNAKE constant nameBo<code>#pragma omp atomic compare capture</code>Cc<code>!$omp distribute parallel do</code> (Fortran)Cd<code>!$omp target parallel do simd</code> (Fortran)AhCase-insensitive compareCiRecursively search for match expressions in an expressionClCheck if this directive has a structured block (requires \xe2\x80\xa6BlParse an identifier token (exposed publicly)AnGet string at index from list.AjGet length of string list.Dh<code>atomic_default_mem_order(seq_cst|acq_rel|...)</code> - Default \xe2\x80\xa6C`<code>#pragma omp distribute parallel for</code>AgMissing required clauseCa<code>#pragma omp target parallel for simd</code>C`<code>#pragma omp target teams distribute</code>CfRecursively search for match expressions in statementsClLookup a DirectiveName from a normalized name string. If \xe2\x80\xa6CnParse clause mappings from c_api.rs convert_clause() using \xe2\x80\xa6CjParse an arm that maps a ClauseName enum variant to an \xe2\x80\xa6CjParse a clause item list using the configured language \xe2\x80\xa6AgParse a schedule clauseCnGet variable list from clause (private, shared, reduction, \xe2\x80\xa6CiConvert an OpenMP directive from one language to another.AaFree string list.Ca<code>#pragma omp distribute parallel loop</code>Ca<code>#pragma omp parallel masked taskloop</code>Ca<code>#pragma omp parallel master taskloop</code>BgFortran free-form - uses !$OMP sentinelCb<code>#pragma omp target parallel loop simd</code>BlRender this directive in a specific languageBmTranslate a C/C++ OpenMP directive to FortranBmTranslate a Fortran OpenMP directive to C/C++CgFortran fixed-form - uses !$OMP or C$OMP in columns 1-6BdRun an interactive debugging sessionBdAdd a schedule clause with modifiersBdSkip whitespace and C-style commentsChEnable or disable language semantics for clause parsing.Ch<code>!$omp distribute parallel do simd</code> (Fortran)CnParse an arm that maps an enum variant to an integer, e.g. \xe2\x80\xa6BjParse directive mappings from c_api.rs \xe2\x80\xa6CgParse an arm that maps an enum variant (or multiple \xe2\x80\xa6BhParse a reduction operator from a stringCdParse an OpenMP directive with explicit language \xe2\x80\xa6C`Skip whitespace/comments - requires at least oneCe<code>#pragma omp distribute parallel for simd</code>Ce<code>#pragma omp target teams distribute simd</code>Ci<code>!$omp teams distribute parallel do</code> (Fortran)C`Parse Fortran free-form sentinel \xe2\x80\x9c!$OMP\xe2\x80\x9d \xe2\x80\xa6BoParse OpenACC clause mappings from c_api.rs \xe2\x80\xa6AeFree clause iterator.AnGet next clause from iterator.BgGet schedule kind from schedule clause.ClTranslate a C/C++ OpenMP directive to Fortran, returning \xe2\x80\xa6ClTranslate a Fortran OpenMP directive to C/C++, returning \xe2\x80\xa6Cf<code>#pragma omp distribute parallel loop simd</code>Cf<code>#pragma omp parallel masked taskloop simd</code>Cf<code>#pragma omp parallel master taskloop simd</code>Cf<code>#pragma omp teams distribute parallel for</code>BgWhether language semantics are enabled.CmParse Fortran fixed-form sentinel \xe2\x80\x9c!$OMP\xe2\x80\x9d, \xe2\x80\x9cC$OMP\xe2\x80\x9d\xe2\x80\xa6Cg<code>#pragma omp teams distribute parallel loop</code>CiCalculate combined FNV-1a hash checksum of OpenMP and \xe2\x80\xa6BeGet number of clauses in a directive.BjCreate an iterator over directive clauses.BmExtract checksum from a generated header fileCaNormalize Fortran identifier to lowercase for \xe2\x80\xa6CbParse OpenACC directive mappings from c_api.rs \xe2\x80\xa6CeConvert directive to pragma string with custom prefixCn<code>!$omp teams distribute parallel do simd</code> (Fortran)C`Convert a directive name string to DirectiveKindCk<code>#pragma omp teams distribute parallel for simd</code>CfLoad the OpenACCKinds.h file and extract canonical \xe2\x80\xa6BmGet reduction operator from reduction clause.D`<code>!$omp target teams distribute parallel do</code> (Fortran)Cl<code>#pragma omp teams distribute parallel loop simd</code>Cm<code>#pragma omp target teams distribute parallel for</code>BmGet default data sharing from default clause.Cn<code>#pragma omp target teams distribute parallel loop</code>CfRaw extractor for directive enum arms: returns all \xe2\x80\xa6CkReturn the canonical OpenACCKinds.h token (UPPER_SNAKE) \xe2\x80\xa6De<code>!$omp target teams distribute parallel do simd</code> (Fortran)Db<code>#pragma omp target teams distribute parallel for simd</code>Dc<code>#pragma omp target teams distribute parallel loop simd</code>ClParse Fortran free-form sentinel with a specific prefix (\xe2\x80\xa6CmParse Fortran fixed-form sentinel with a specific prefix (\xe2\x80\xa6CmConvert directive to pragma string with custom prefix and \xe2\x80\xa6")