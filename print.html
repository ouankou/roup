<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ROUP Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Rust-based OpenMP/OpenACC Unified Parser - Safe, fast, and extensible">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ROUP Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ouankou/roup" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="roup"><a class="header" href="#roup">ROUP</a></h1>
<div align="center">
<p><strong>Rust-based OpenMP Parser</strong></p>
<p><em>Safe, fast, and comprehensive OpenMP directive parsing</em></p>
<p><a href="./getting-started.html">Get Started</a> · <a href="./rust-tutorial.html">Tutorials</a> · <a href="./api-reference.html">API Reference</a> · <a href="https://github.com/ouankou/roup">GitHub</a></p>
</div>
<hr />
<h2 id="what-is-roup"><a class="header" href="#what-is-roup">What is ROUP?</a></h2>
<p>ROUP is an <strong>experimental</strong> parser for OpenMP directives, written in safe Rust with C and C++ APIs. Parse OpenMP pragmas like <code>#pragma omp parallel for</code> into structured data that your tools can analyze, transform, and process.</p>
<blockquote>
<p><strong>⚠️ Experimental Status</strong>: ROUP is under active development and not yet production-ready. APIs may change, and some OpenMP features are still being implemented. Use in research and experimental projects.</p>
</blockquote>
<p><strong>Perfect for:</strong></p>
<ul>
<li>🔧 <strong>Compiler research</strong> - Experiment with OpenMP parsing in compilers</li>
<li>🔍 <strong>Analysis prototypes</strong> - Build experimental linters and analyzers</li>
<li>🎓 <strong>Researchers</strong> - Study parallelization patterns and test new ideas</li>
<li>📚 <strong>Educators</strong> - Teaching tool for parallel programming concepts</li>
</ul>
<hr />
<h2 id="why-roup"><a class="header" href="#why-roup">Why ROUP?</a></h2>
<h3 id="-fast--lightweight"><a class="header" href="#-fast--lightweight">🚀 Fast &amp; Lightweight</a></h3>
<ul>
<li><strong>Microsecond parsing</strong> - Parse directives in ~500ns</li>
<li><strong>Zero-copy lexer</strong> - Minimal memory allocations</li>
<li><strong>No LLVM dependency</strong> - Standalone library, small binary size</li>
<li><strong>16 FFI functions</strong> - Simple, focused C API</li>
</ul>
<h3 id="-safe--reliable"><a class="header" href="#-safe--reliable">🛡️ Safe &amp; Reliable</a></h3>
<ul>
<li><strong>99.1% safe Rust</strong> - Memory safety guaranteed</li>
<li><strong>620 passing tests</strong> - Comprehensive test coverage</li>
<li><strong>Fuzzing tested</strong> - Handles malformed input gracefully</li>
<li><strong>NULL-safe C API</strong> - Defensive checks at FFI boundary</li>
</ul>
<h3 id="-comprehensive-openmp-support"><a class="header" href="#-comprehensive-openmp-support">📚 Comprehensive OpenMP Support</a></h3>
<ul>
<li><strong>128 directive keywords</strong> - From <code>parallel</code> to every combined OpenMP 6.0 form</li>
<li><strong>132 clause keywords</strong> - Extensive OpenMP 3.0 through 6.0 coverage</li>
<li><strong>Version tracking</strong> - Know which OpenMP version introduced each feature</li>
<li><strong>Spec compliant</strong> - Follows official OpenMP specifications</li>
</ul>
<h3 id="-multi-language-apis"><a class="header" href="#-multi-language-apis">🔌 Multi-Language APIs</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th>API Style</th><th>Memory Management</th><th>Status</th></tr></thead><tbody>
<tr><td><strong>Rust</strong></td><td>Native</td><td>Automatic (ownership)</td><td>✅ Stable</td></tr>
<tr><td><strong>C</strong></td><td>Pointer-based</td><td>Manual (malloc/free pattern)</td><td>✅ Stable</td></tr>
<tr><td><strong>C++</strong></td><td>RAII wrappers</td><td>Automatic (destructors)</td><td>✅ Stable</td></tr>
<tr><td><strong>Fortran</strong></td><td>C interop</td><td>Manual (via iso_c_binding)</td><td>⚠️ Experimental</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<h3 id="parse-in-3-lines-rust"><a class="header" href="#parse-in-3-lines-rust">Parse in 3 Lines (Rust)</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp;

let parser = openmp::parser();
let (_, directive) = parser.parse("#pragma omp parallel for num_threads(4)").unwrap();
// Access directive information
println!("Directive: {}", directive.name);  // Output: Directive: parallel for
println!("Found {} clauses", directive.clauses.len());  // Output: Found 1 clauses
// Iterate through clauses
for clause in &amp;directive.clauses {
    println!("  Clause: {}", clause.name);  // Output:   Clause: num_threads
}</code></pre>
<h3 id="parse-in-c"><a class="header" href="#parse-in-c">Parse in C</a></h3>
<pre><code class="language-c">OmpDirective* dir = roup_parse("#pragma omp parallel for num_threads(4)");
printf("Clauses: %d\n", roup_directive_clause_count(dir));
roup_directive_free(dir);
</code></pre>
<h3 id="parse-in-c-with-raii"><a class="header" href="#parse-in-c-with-raii">Parse in C++ (with RAII)</a></h3>
<pre><code class="language-cpp">roup::Directive dir("#pragma omp parallel for num_threads(4)");
std::cout &lt;&lt; "Clauses: " &lt;&lt; dir.clause_count() &lt;&lt; "\n";
// Automatic cleanup!
</code></pre>
<h3 id="parse-fortran-experimental"><a class="header" href="#parse-fortran-experimental">Parse Fortran (Experimental)</a></h3>
<pre><code class="language-fortran">! Free-form Fortran
directive_ptr = roup_parse_with_language("!$OMP PARALLEL PRIVATE(A)", &amp;
                                          ROUP_LANG_FORTRAN_FREE)
</code></pre>
<p><a href="./getting-started.html">See full examples →</a></p>
<hr />
<h2 id="feature-highlights"><a class="header" href="#feature-highlights">Feature Highlights</a></h2>
<h3 id="-comprehensive-coverage"><a class="header" href="#-comprehensive-coverage">🎯 Comprehensive Coverage</a></h3>
<details>
<summary><b>Parallel Constructs</b> - 20+ directives</summary>
<ul>
<li><code>parallel</code> - Basic parallel regions</li>
<li><code>parallel for</code> - Combined parallel + worksharing</li>
<li><code>parallel sections</code> - Parallel sections</li>
<li><code>parallel master</code> - Parallel master thread</li>
<li><code>parallel loop</code> - OpenMP 5.0+ parallel loop</li>
<li>And more...</li>
</ul>
</details>
<details>
<summary><b>Work-Sharing</b> - 10+ directives</summary>
<ul>
<li><code>for</code> / <code>do</code> - Loop worksharing</li>
<li><code>sections</code> / <code>section</code> - Code sections</li>
<li><code>single</code> - Execute once</li>
<li><code>workshare</code> - Fortran worksharing</li>
<li><code>loop</code> - Generic loop construct</li>
</ul>
</details>
<details>
<summary><b>Tasking</b> - 15+ directives</summary>
<ul>
<li><code>task</code> - Explicit tasks</li>
<li><code>taskloop</code> - Loop-based tasks</li>
<li><code>taskgroup</code> - Task synchronization</li>
<li><code>taskwait</code> - Wait for tasks</li>
<li><code>taskyield</code> - Yield to other tasks</li>
<li>Dependency clauses: <code>depend</code>, <code>priority</code>, <code>detach</code></li>
</ul>
</details>
<details>
<summary><b>Device Offloading</b> - 25+ directives</summary>
<ul>
<li><code>target</code> - Offload to device</li>
<li><code>target data</code> - Device data management</li>
<li><code>target enter/exit data</code> - Data transfer</li>
<li><code>target update</code> - Synchronize data</li>
<li><code>teams</code> - Multiple thread teams</li>
<li><code>distribute</code> - Distribute iterations</li>
</ul>
</details>
<details>
<summary><b>SIMD</b> - 10+ directives</summary>
<ul>
<li><code>simd</code> - SIMD loops</li>
<li><code>declare simd</code> - Vectorizable functions</li>
<li><code>distribute simd</code> - Combined distribute + SIMD</li>
<li>Various alignment and vectorization clauses</li>
</ul>
</details>
<details>
<summary><b>Advanced (OpenMP 5.0+)</b></summary>
<ul>
<li><code>metadirective</code> - Context-sensitive directives</li>
<li><code>declare variant</code> - Function variants</li>
<li><code>loop</code> - Generic loop construct</li>
<li><code>scan</code> - Prefix scan operations</li>
<li><code>assume</code> - Compiler assumptions</li>
</ul>
</details>
<p><a href="./openmp-support.html">Full OpenMP Support Matrix →</a></p>
<h3 id="-rich-clause-support"><a class="header" href="#-rich-clause-support">🔍 Rich Clause Support</a></h3>
<p><strong>92+ clause types including:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Clauses</th></tr></thead><tbody>
<tr><td><strong>Data Sharing</strong></td><td><code>private</code>, <code>shared</code>, <code>firstprivate</code>, <code>lastprivate</code></td></tr>
<tr><td><strong>Reductions</strong></td><td><code>reduction(+:x)</code>, <code>reduction(min:y)</code>, custom operators</td></tr>
<tr><td><strong>Scheduling</strong></td><td><code>schedule(static)</code>, <code>schedule(dynamic,100)</code>, <code>collapse(3)</code></td></tr>
<tr><td><strong>Control</strong></td><td><code>if(condition)</code>, <code>num_threads(8)</code>, <code>proc_bind(close)</code></td></tr>
<tr><td><strong>Device</strong></td><td><code>map(to:x)</code>, <code>device(2)</code>, <code>defaultmap(tofrom:scalar)</code></td></tr>
<tr><td><strong>Dependencies</strong></td><td><code>depend(in:x)</code>, <code>depend(out:y)</code>, <code>depend(inout:z)</code></td></tr>
</tbody></table>
</div>
<p><a href="./api-reference.html">Complete clause reference →</a></p>
<hr />
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code class="language-text">┌──────────────────────────────────────┐
│  Your Application                    │
├──────────────────────────────────────┤
│  Language Bindings                   │
│  ├─ Rust API (native)                │
│  ├─ C API (16 functions)             │
│  └─ C++ API (RAII wrappers)          │
├──────────────────────────────────────┤
│  Parser Layer (99.1% safe Rust)      │
│  ├─ Directive Parser                 │
│  ├─ Clause Parser                    │
│  └─ Error Recovery                   │
├──────────────────────────────────────┤
│  Lexer (nom-based, zero-copy)        │
└──────────────────────────────────────┘
</code></pre>
<p><strong>Design Principles:</strong></p>
<ul>
<li><strong>Safety first</strong> - Rust ownership prevents memory bugs</li>
<li><strong>Zero-copy</strong> - Parse directly from input string</li>
<li><strong>Minimal FFI</strong> - Only ~60 lines of unsafe code (0.9%)</li>
<li><strong>Extensible</strong> - Easy to add new directives/clauses</li>
</ul>
<p><a href="./architecture.html">Learn more about the architecture →</a></p>
<hr />
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<h3 id="roup-vs-llvmclang"><a class="header" href="#roup-vs-llvmclang">ROUP vs LLVM/Clang</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>ROUP</th><th>LLVM/Clang</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>OpenMP parsing only</td><td>Full C/C++ compiler</td></tr>
<tr><td><strong>Binary size</strong></td><td>~500KB</td><td>~50MB+</td></tr>
<tr><td><strong>Parse time</strong></td><td>~500ns - 1µs</td><td>~10-100µs</td></tr>
<tr><td><strong>Dependencies</strong></td><td>None</td><td>LLVM, Clang, libc++</td></tr>
<tr><td><strong>API complexity</strong></td><td>16 C functions</td><td>1000s of functions</td></tr>
<tr><td><strong>Learning curve</strong></td><td>Minutes</td><td>Weeks</td></tr>
<tr><td><strong>Use case</strong></td><td>Analysis, tools, IDE plugins</td><td>Compilation</td></tr>
</tbody></table>
</div>
<p><strong>Use ROUP when:</strong></p>
<ul>
<li>✅ You only need to parse OpenMP, not compile</li>
<li>✅ You want minimal dependencies</li>
<li>✅ You need fast integration into tools</li>
<li>✅ You value simplicity and safety</li>
</ul>
<p><strong>Use LLVM when:</strong></p>
<ul>
<li>You need full C/C++ compilation</li>
<li>You're building a complete compiler</li>
<li>You need LLVM IR generation</li>
</ul>
<h3 id="roup-vs-custom-parser"><a class="header" href="#roup-vs-custom-parser">ROUP vs Custom Parser</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>ROUP</th><th>Custom Parser</th></tr></thead><tbody>
<tr><td><strong>Development time</strong></td><td>Minutes (add dependency)</td><td>Weeks/months</td></tr>
<tr><td><strong>OpenMP coverage</strong></td><td>128 directives</td><td>You must implement all</td></tr>
<tr><td><strong>Testing</strong></td><td>620 tests included</td><td>You must write tests</td></tr>
<tr><td><strong>Maintenance</strong></td><td>Active, updated for new OpenMP</td><td>You must maintain</td></tr>
<tr><td><strong>Edge cases</strong></td><td>Handled (fuzzing tested)</td><td>Likely has bugs</td></tr>
<tr><td><strong>Spec compliance</strong></td><td>Verified</td><td>Uncertain</td></tr>
</tbody></table>
</div>
<p><strong>Verdict:</strong> Unless you have very specific needs, use ROUP.</p>
<hr />
<h2 id="safety-guarantees"><a class="header" href="#safety-guarantees">Safety Guarantees</a></h2>
<p>ROUP prioritizes safety without compromising usability:</p>
<h3 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h3>
<ul>
<li>✅ <strong>No buffer overflows</strong> - Rust prevents at compile time</li>
<li>✅ <strong>No use-after-free</strong> - Ownership system enforces</li>
<li>✅ <strong>No double-free</strong> - Checked at FFI boundary</li>
<li>✅ <strong>No memory leaks</strong> - RAII and destructors</li>
<li>✅ <strong>No data races</strong> - Thread-safe parsing</li>
</ul>
<h3 id="api-safety"><a class="header" href="#api-safety">API Safety</a></h3>
<p><strong>Rust API:</strong></p>
<ul>
<li>100% memory-safe by construction</li>
<li>Impossible to trigger undefined behavior</li>
</ul>
<p><strong>C API:</strong></p>
<ul>
<li>NULL checks before all pointer operations</li>
<li>Returns safe defaults on error (-1, NULL)</li>
<li>Validates UTF-8 encoding</li>
<li>Documents all safety contracts</li>
</ul>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<ul>
<li><strong>620 tests</strong> covering all features</li>
<li><strong>Fuzzing</strong> with random inputs</li>
<li><strong>Valgrind</strong> verified (no leaks)</li>
<li><strong>Thread sanitizer</strong> verified (no races)</li>
<li><strong>Address sanitizer</strong> verified (no memory errors)</li>
</ul>
<p><a href="./architecture.html#safety-boundaries">Read the safety analysis →</a></p>
<hr />
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Typical performance characteristics:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th><th>Notes</th></tr></thead><tbody>
<tr><td>Parse <code>#pragma omp parallel</code></td><td>~500ns</td><td>Simple directive</td></tr>
<tr><td>Parse with clauses</td><td>~800ns</td><td><code>num_threads(4)</code></td></tr>
<tr><td>Complex directive</td><td>~1.2µs</td><td>Multiple clauses</td></tr>
<tr><td>Iterator creation</td><td>~10ns</td><td>FFI overhead</td></tr>
</tbody></table>
</div>
<p><strong>Scalability:</strong></p>
<ul>
<li>✅ Thread-safe - Parse from multiple threads</li>
<li>✅ Zero-copy - No string allocations during lexing</li>
<li>✅ Minimal allocations - ~3 allocations per directive</li>
<li>✅ Fast enough - Parsing is rarely the bottleneck</li>
</ul>
<p><a href="./architecture.html#performance-characteristics">Performance details →</a></p>
<hr />
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Choose your language:</p>
<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
<div style="padding: 1rem; border: 1px solid #ddd; border-radius: 4px;">
<h3 id="-rust"><a class="header" href="#-rust">🦀 Rust</a></h3>
<p><strong>Install:</strong></p>
<pre><code class="language-toml">[dependencies]
roup = "0.5"
</code></pre>
<p><strong>Learn:</strong></p>
<ul>
<li><a href="./rust-tutorial.html">Rust Tutorial</a></li>
<li><a href="./api-reference.html">API Docs</a></li>
</ul>
</div>
<div style="padding: 1rem; border: 1px solid #ddd; border-radius: 4px;">
<h3 id="-c"><a class="header" href="#-c">🔧 C</a></h3>
<p><strong>Build:</strong></p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p><strong>Learn:</strong></p>
<ul>
<li><a href="./c-tutorial.html">C Tutorial</a></li>
<li><a href="./building.html">Building Guide</a></li>
</ul>
</div>
<div style="padding: 1rem; border: 1px solid #ddd; border-radius: 4px;">
<h3 id="-c-1"><a class="header" href="#-c-1">⚙️ C++</a></h3>
<p><strong>Build:</strong></p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p><strong>Learn:</strong></p>
<ul>
<li><a href="./cpp-tutorial.html">C++ Tutorial</a></li>
<li><a href="./cpp-tutorial.html#step-2-create-raii-wrappers-modern-c">RAII Wrappers</a></li>
</ul>
</div>
</div>
<p><a href="./getting-started.html">Quick Start Guide →</a></p>
<hr />
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/ouankou/roup">ouankou/roup</a></li>
<li><strong>Issues</strong>: <a href="https://github.com/ouankou/roup/issues">Bug reports</a></li>
<li><strong>Discussions</strong>: <a href="https://github.com/ouankou/roup/discussions">Questions &amp; ideas</a></li>
<li><strong>Contributing</strong>: <a href="./contributing.html">How to contribute</a></li>
</ul>
<hr />
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>ROUP is open source under the <strong>MIT License</strong>.</p>
<p>Copyright © 2024-2025 Anjia Wang</p>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>📖 <a href="./getting-started.html">Read the Getting Started guide</a></li>
<li>🦀 <a href="./rust-tutorial.html">Try the Rust tutorial</a></li>
<li>🔧 <a href="./c-tutorial.html">Try the C tutorial</a></li>
<li>📚 <a href="./api-reference.html">Browse the API reference</a></li>
<li>🏗️ <a href="./architecture.html">Learn the architecture</a></li>
<li>❓ <a href="./faq.html">Check the FAQ</a></li>
</ul>
<hr />
<h2 id="why-roup-1"><a class="header" href="#why-roup-1">Why ROUP?</a></h2>
<h3 id="for-compiler-developers"><a class="header" href="#for-compiler-developers">For Compiler Developers</a></h3>
<ul>
<li>Drop-in OpenMP/OpenACC parser component</li>
<li>Well-tested, battle-hardened parsing logic</li>
<li>Easy FFI integration from any language</li>
</ul>
<h3 id="for-tool-builders"><a class="header" href="#for-tool-builders">For Tool Builders</a></h3>
<ul>
<li>Analyze OpenMP code without a full compiler</li>
<li>Build linters, formatters, and code analyzers</li>
<li>Extract parallelization patterns from codebases</li>
</ul>
<h3 id="for-researchers"><a class="header" href="#for-researchers">For Researchers</a></h3>
<ul>
<li>Study directive usage patterns</li>
<li>Prototype new directive extensions</li>
<li>Educational tool for learning parallel programming</li>
</ul>
<hr />
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick Example</a></h2>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp;

let parser = openmp::parser();
let input = "#pragma omp parallel for num_threads(4) private(i)";
match parser.parse(input) {
    Ok((_, directive)) =&gt; {
        println!("Directive: {:?}", directive.kind);
        println!("Clauses: {}", directive.clauses.len());
    }
    Err(e) =&gt; eprintln!("Parse error: {:?}", e),
}</code></pre>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// Forward declarations
typedef struct OmpDirective OmpDirective;
extern OmpDirective* roup_parse(const char* input);
extern int32_t roup_directive_clause_count(const OmpDirective* dir);
extern void roup_directive_free(OmpDirective* dir);

int main() {
    OmpDirective* dir = roup_parse("#pragma omp parallel for num_threads(4)");
    if (dir) {
        printf("Clauses: %d\n", roup_directive_clause_count(dir));
        roup_directive_free(dir);
    }
    return 0;
}
</code></pre>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

struct OmpDirective;
extern "C" {
    OmpDirective* roup_parse(const char* input);
    int32_t roup_directive_clause_count(const OmpDirective* dir);
    void roup_directive_free(OmpDirective* dir);
}

// RAII wrapper
class Directive {
    OmpDirective* ptr_;
public:
    explicit Directive(const char* input) : ptr_(roup_parse(input)) {}
    ~Directive() { if (ptr_) roup_directive_free(ptr_); }
    bool valid() const { return ptr_ != nullptr; }
    int clause_count() const { 
        return ptr_ ? roup_directive_clause_count(ptr_) : 0; 
    }
};

int main() {
    Directive dir("#pragma omp parallel for num_threads(4)");
    if (dir.valid()) {
        std::cout &lt;&lt; "Clauses: " &lt;&lt; dir.clause_count() &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>
<hr />
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>ROUP uses a clean, modular architecture:</p>
<pre><code class="language-text">┌─────────────────────────────────────────┐
│         Application Layer               │
│  (Your compiler/tool/analyzer)          │
└─────────────────┬───────────────────────┘
                  │
      ┌───────────┼───────────┐
      │           │           │
      ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│ Rust API│ │  C API  │ │ C++ API │
│         │ │         │ │ (RAII)  │
└─────────┘ └─────────┘ └─────────┘
      │           │           │
      └───────────┼───────────┘
                  │
                  ▼
         ┌────────────────┐
         │  Core Parser   │
         │  (nom-based)   │
         └────────────────┘
                  │
      ┌───────────┼───────────┐
      ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│  Lexer  │ │Directive│ │ Clause  │
│         │ │ Parser  │ │ Parser  │
└─────────┘ └─────────┘ └─────────┘
</code></pre>
<p><strong>Key Design Principles:</strong></p>
<ul>
<li><strong>Safe by default</strong> - Rust's ownership system prevents memory errors</li>
<li><strong>Zero-copy parsing</strong> - Uses string slices, not allocations</li>
<li><strong>Minimal unsafe</strong> - FFI boundary only, well-documented</li>
<li><strong>Extensible</strong> - Easy to add new directives and clauses</li>
</ul>
<hr />
<h2 id="openmp-support"><a class="header" href="#openmp-support">OpenMP Support</a></h2>
<p>ROUP currently supports <strong>OpenMP 5.0+</strong> with comprehensive coverage:</p>
<h3 id="supported-directives-15"><a class="header" href="#supported-directives-15">Supported Directives (15+)</a></h3>
<ul>
<li><code>parallel</code> - Parallel regions</li>
<li><code>for</code> - Worksharing loops</li>
<li><code>sections</code>, <code>single</code> - Worksharing constructs</li>
<li><code>task</code>, <code>taskwait</code>, <code>taskgroup</code> - Tasking</li>
<li><code>target</code>, <code>teams</code>, <code>distribute</code> - Device offloading</li>
<li><code>barrier</code>, <code>critical</code>, <code>atomic</code> - Synchronization</li>
<li><code>metadirective</code> - Dynamic selection</li>
<li>And more...</li>
</ul>
<h3 id="supported-clauses-50"><a class="header" href="#supported-clauses-50">Supported Clauses (50+)</a></h3>
<ul>
<li><strong>Data sharing:</strong> <code>private</code>, <code>shared</code>, <code>firstprivate</code>, <code>lastprivate</code></li>
<li><strong>Parallelism control:</strong> <code>num_threads</code>, <code>if</code>, <code>proc_bind</code></li>
<li><strong>Worksharing:</strong> <code>schedule</code>, <code>collapse</code>, <code>nowait</code></li>
<li><strong>Reductions:</strong> <code>reduction</code> with 10+ operators (+, *, min, max, etc.)</li>
<li><strong>Device:</strong> <code>map</code>, <code>device</code>, <code>defaultmap</code></li>
<li><strong>Dependencies:</strong> <code>depend</code>, <code>in</code>, <code>out</code>, <code>inout</code></li>
<li>And more...</li>
</ul>
<p>See the <a href="https://github.com/ouankou/roup/blob/main/docs/OPENMP_SUPPORT.md">OpenMP Support Matrix</a> for the complete list.</p>
<hr />
<h2 id="safety-guarantees-1"><a class="header" href="#safety-guarantees-1">Safety Guarantees</a></h2>
<p>ROUP is built with safety as a core principle:</p>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Value</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>Safe Rust</strong></td><td>99.1%</td><td>All core logic is safe</td></tr>
<tr><td><strong>Unsafe blocks</strong></td><td>18</td><td>Only at FFI boundary</td></tr>
<tr><td><strong>Unsafe lines</strong></td><td>~60</td><td>Well-documented, NULL-checked</td></tr>
<tr><td><strong>Memory leaks</strong></td><td>0</td><td>Rust's RAII prevents leaks</td></tr>
<tr><td><strong>Segfaults</strong></td><td>0</td><td>Ownership system prevents use-after-free</td></tr>
</tbody></table>
</div>
<p>All <code>unsafe</code> code is:</p>
<ul>
<li><strong>Documented</strong> with safety requirements</li>
<li><strong>NULL-checked</strong> before dereferencing</li>
<li><strong>Isolated</strong> to <code>src/c_api.rs</code></li>
<li><strong>Tested</strong> with 620 tests</li>
</ul>
<hr />
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>ROUP has comprehensive test coverage:</p>
<ul>
<li><strong>285 unit tests</strong> - Core parsing logic</li>
<li><strong>234 integration tests</strong> - Real-world usage scenarios</li>
<li><strong>62 doc tests</strong> - Examples in documentation are auto-tested</li>
<li><strong>620 total tests</strong> - All passing, zero warnings</li>
<li><strong>Cross-platform</strong> - Tested on Linux, macOS, Windows</li>
</ul>
<p>Test categories:</p>
<ul>
<li>✅ Basic directives (parallel, for, task, teams, target)</li>
<li>✅ Complex features (reductions, metadirectives, nesting)</li>
<li>✅ Edge cases (comments, whitespace, error handling)</li>
<li>✅ Roundtrip parsing (parse → format → parse)</li>
<li>✅ FFI safety (C and C++ examples)</li>
</ul>
<hr />
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>Want to experiment with ROUP? Check out our tutorials:</p>
<ul>
<li><strong><a href="./cpp-tutorial.html">C++ Tutorial</a></strong> - Build an experimental application with C++17</li>
<li><strong><a href="./api-reference.html">Rust API Docs</a></strong> - Complete API reference</li>
</ul>
<p>Or jump straight to the code:</p>
<ul>
<li><a href="https://github.com/ouankou/roup">GitHub Repository</a></li>
<li><a href="./getting-started.html">Getting Started Guide</a></li>
</ul>
<hr />
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<p>ROUP is open source under the <strong>MIT License</strong>.</p>
<p><strong>Copyright © 2024-2025 Anjia Wang</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h1>
<p>This guide shows how to compile ROUP, add the crate to a Rust project, and link
the C/C++ bindings.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust 1.85 or newer (<code>rustup</code> is recommended).</li>
<li>A C/C++ toolchain (clang or GCC) when using the FFI bindings.</li>
<li>Optional: a Fortran compiler for the example programs in <code>examples/fortran/</code>.</li>
</ul>
<p>Clone and build the project:</p>
<pre><code class="language-bash">git clone https://github.com/ouankou/roup.git
cd roup
cargo build --release
</code></pre>
<p>The build produces <code>libroup.so</code> on Linux, <code>libroup.dylib</code> on macOS, and
<code>roup.dll</code> on Windows inside <code>target/release/</code>.</p>
<h2 id="rust-quick-start"><a class="header" href="#rust-quick-start">Rust quick start</a></h2>
<p>Add ROUP to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
roup = "0.5"
</code></pre>
<p>Example program:</p>
<pre><code class="language-rust ignore">use roup::parser::openmp;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel for num_threads(4)";
    let parser = openmp::parser();

    match parser.parse_with_language(input, Language::C) {
        Ok((_, directive)) =&gt; {
            println!("directive: {}", directive.name);
            println!("clauses: {}", directive.clauses.len());
        }
        Err(err) =&gt; eprintln!("parse error: {err:?}"),
    }
}</code></pre>
<p>Run it with <code>cargo run</code>.</p>
<h2 id="c-quick-start"><a class="header" href="#c-quick-start">C quick start</a></h2>
<p>Write a small program that calls the C API:</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

struct OmpDirective;

struct OmpDirective* roup_parse(const char* input);
int32_t roup_directive_clause_count(const struct OmpDirective* dir);
void roup_directive_free(struct OmpDirective* dir);

int main(void) {
    struct OmpDirective* directive = roup_parse("#pragma omp parallel num_threads(4)");
    if (!directive) {
        fputs("parse failed\n", stderr);
        return 1;
    }

    printf("clause count: %d\n", roup_directive_clause_count(directive));
    roup_directive_free(directive);
    return 0;
}
</code></pre>
<p>Compile against the release build of ROUP:</p>
<pre><code class="language-bash">cargo build --release
clang example.c \
  -L./target/release \
  -lroup -lpthread -ldl -lm \
  -Wl,-rpath,./target/release \
  -o example
./example
</code></pre>
<p>macOS users can replace the rpath with
<code>-Wl,-rpath,@executable_path/../target/release</code>.</p>
<h2 id="c-quick-start-1"><a class="header" href="#c-quick-start-1">C++ quick start</a></h2>
<p>The C API can be wrapped with RAII helpers:</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;iostream&gt;

extern "C" {
struct OmpDirective;
OmpDirective* roup_parse(const char* input);
int32_t roup_directive_clause_count(const OmpDirective* dir);
void roup_directive_free(OmpDirective* dir);
}

class Directive {
public:
    explicit Directive(const char* input) : ptr_(roup_parse(input)) {}
    ~Directive() { if (ptr_) roup_directive_free(ptr_); }
    Directive(const Directive&amp;) = delete;
    Directive&amp; operator=(const Directive&amp;) = delete;
    Directive(Directive&amp;&amp; other) noexcept : ptr_(other.ptr_) { other.ptr_ = nullptr; }

    bool valid() const { return ptr_ != nullptr; }
    int32_t clause_count() const { return ptr_ ? roup_directive_clause_count(ptr_) : 0; }

private:
    OmpDirective* ptr_;
};

int main() {
    Directive directive("#pragma omp parallel for num_threads(4)");
    if (!directive.valid()) {
        std::cerr &lt;&lt; "parse failed\n";
        return 1;
    }

    std::cout &lt;&lt; "clauses: " &lt;&lt; directive.clause_count() &lt;&lt; "\n";
}
</code></pre>
<p>Compile with clang++ or g++ in the same way as the C example.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<ul>
<li>Explore the complete examples in <code>examples/</code> (C, C++, Fortran).</li>
<li>Read the <a href="./rust-tutorial.html">Rust tutorial</a> for more detailed use cases.</li>
<li>Consult the <a href="../../TESTING.html">Testing guide</a> before contributing changes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-guide"><a class="header" href="#building-guide">Building Guide</a></h1>
<p>This guide covers building ROUP and integrating it into your projects across different languages and platforms.</p>
<hr />
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/ouankou/roup.git
cd roup

# Build the library (release mode, optimized)
cargo build --release

# Run tests to verify
cargo test

# Build is complete! Library at: target/release/libroup.{a,so,dylib,dll}
</code></pre>
<p><strong>Next steps:</strong></p>
<ul>
<li><strong>Rust users</strong>: Add ROUP as a dependency (see below)</li>
<li><strong>C users</strong>: Link against <code>libroup.a</code> (see <a href="./c-tutorial.html">C Tutorial</a>)</li>
<li><strong>C++ users</strong>: Use RAII wrappers (see <a href="./cpp-tutorial.html">C++ Tutorial</a>)</li>
</ul>
<hr />
<h2 id="rust-integration"><a class="header" href="#rust-integration">Rust Integration</a></h2>
<h3 id="option-1-using-cratesio-recommended"><a class="header" href="#option-1-using-cratesio-recommended">Option 1: Using crates.io (Recommended)</a></h3>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
roup = "0.5"
</code></pre>
<p>Then use in your code:</p>
<pre><code class="language-rust ignore">use roup::parser::parse;

fn main() {
    let result = parse("#pragma omp parallel for");
    match result {
        Ok(directive) =&gt; println!("Parsed: {:?}", directive),
        Err(e) =&gt; eprintln!("Error: {}", e),
    }
}</code></pre>
<h3 id="option-2-using-git-dependency"><a class="header" href="#option-2-using-git-dependency">Option 2: Using Git Dependency</a></h3>
<pre><code class="language-toml">[dependencies]
roup = { git = "https://github.com/ouankou/roup.git" }
</code></pre>
<h3 id="option-3-local-development"><a class="header" href="#option-3-local-development">Option 3: Local Development</a></h3>
<pre><code class="language-toml">[dependencies]
roup = { path = "../roup" }
</code></pre>
<h3 id="building-your-rust-project"><a class="header" href="#building-your-rust-project">Building Your Rust Project</a></h3>
<pre><code class="language-bash"># Standard cargo commands
cargo build           # Debug build
cargo build --release # Optimized build
cargo test            # Run tests
cargo doc --open      # Generate and view docs
</code></pre>
<p>See <a href="./rust-tutorial.html">Rust Tutorial</a> for complete usage examples.</p>
<hr />
<h2 id="c-integration"><a class="header" href="#c-integration">C Integration</a></h2>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li><strong>Rust toolchain</strong> (to build libroup)</li>
<li><strong>C compiler</strong>: GCC, Clang, or MSVC</li>
<li><strong>Build tools</strong>: Make or CMake (optional)</li>
</ul>
<h3 id="step-1-build-the-roup-library"><a class="header" href="#step-1-build-the-roup-library">Step 1: Build the ROUP Library</a></h3>
<pre><code class="language-bash">cd /path/to/roup
cargo build --release
</code></pre>
<p>This creates:</p>
<ul>
<li><strong>Linux</strong>: <code>target/release/libroup.{a,so}</code></li>
<li><strong>macOS</strong>: <code>target/release/libroup.{a,dylib}</code></li>
<li><strong>Windows</strong>: <code>target/release/roup.{lib,dll}</code></li>
</ul>
<h3 id="step-2-create-header-file"><a class="header" href="#step-2-create-header-file">Step 2: Create Header File</a></h3>
<p>Create <code>roup_ffi.h</code> with function declarations (see <a href="./c-tutorial.html#step-1-setup-and-compilation">C Tutorial</a> for complete header).</p>
<h3 id="step-3-compile-your-c-program"><a class="header" href="#step-3-compile-your-c-program">Step 3: Compile Your C Program</a></h3>
<h4 id="using-gccclang-linuxmacos"><a class="header" href="#using-gccclang-linuxmacos">Using GCC/Clang (Linux/macOS)</a></h4>
<pre><code class="language-bash"># Static linking
gcc -o myapp main.c \
    -I/path/to/roup_ffi.h \
    -L/path/to/roup/target/release \
    -lroup \
    -lpthread -ldl -lm

# Dynamic linking with rpath
gcc -o myapp main.c \
    -I/path/to/roup_ffi.h \
    -L/path/to/roup/target/release \
    -lroup \
    -Wl,-rpath,/path/to/roup/target/release \
    -lpthread -ldl -lm
</code></pre>
<h4 id="using-cmake"><a class="header" href="#using-cmake">Using CMake</a></h4>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.10)
project(MyApp C)

# Add ROUP library
add_library(roup STATIC IMPORTED)
set_target_properties(roup PROPERTIES
    IMPORTED_LOCATION "/path/to/roup/target/release/libroup.a"
)

# Create executable
add_executable(myapp main.c)
target_include_directories(myapp PRIVATE "/path/to/roup_ffi.h")
target_link_libraries(myapp roup pthread dl m)
</code></pre>
<h4 id="using-msvc-windows"><a class="header" href="#using-msvc-windows">Using MSVC (Windows)</a></h4>
<pre><code class="language-cmd">REM Build ROUP library first
cargo build --release

REM Compile C program
cl.exe main.c /I"C:\path\to\roup" ^
    /link "C:\path\to\roup\target\release\roup.lib" ^
    ws2_32.lib userenv.lib
</code></pre>
<h3 id="step-4-run-your-program"><a class="header" href="#step-4-run-your-program">Step 4: Run Your Program</a></h3>
<pre><code class="language-bash"># If using static linking
./myapp

# If using dynamic linking without rpath
LD_LIBRARY_PATH=/path/to/roup/target/release ./myapp

# Windows
set PATH=C:\path\to\roup\target\release;%PATH%
myapp.exe
</code></pre>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<p>See <code>examples/c/tutorial_basic.c</code> for a full working example with build instructions.</p>
<hr />
<h2 id="c-integration-1"><a class="header" href="#c-integration-1">C++ Integration</a></h2>
<p>C++ programs use the same C API with optional RAII wrappers for automatic memory management.</p>
<h3 id="step-1-build-roup-library"><a class="header" href="#step-1-build-roup-library">Step 1: Build ROUP Library</a></h3>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="step-2-create-raii-wrappers"><a class="header" href="#step-2-create-raii-wrappers">Step 2: Create RAII Wrappers</a></h3>
<p>See <a href="./cpp-tutorial.html#step-2-create-raii-wrappers-modern-c">C++ Tutorial - Step 2</a> for complete wrapper code.</p>
<h3 id="step-3-compile-with-c17"><a class="header" href="#step-3-compile-with-c17">Step 3: Compile with C++17</a></h3>
<pre><code class="language-bash"># Using g++
g++ -o myapp main.cpp \
    -I/path/to/roup_ffi.h \
    -I/path/to/roup_wrapper.hpp \
    -L/path/to/roup/target/release \
    -lroup \
    -std=c++17 \
    -lpthread -ldl -lm

# Using Clang++
clang++ -o myapp main.cpp \
    -I/path/to/roup_ffi.h \
    -I/path/to/roup_wrapper.hpp \
    -L/path/to/roup/target/release \
    -lroup \
    -std=c++17 \
    -lpthread -ldl -lm
</code></pre>
<h3 id="cmake-for-c"><a class="header" href="#cmake-for-c">CMake for C++</a></h3>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.10)
project(MyApp CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_library(roup STATIC IMPORTED)
set_target_properties(roup PROPERTIES
    IMPORTED_LOCATION "/path/to/roup/target/release/libroup.a"
)

add_executable(myapp main.cpp)
target_include_directories(myapp PRIVATE 
    "/path/to/roup_ffi.h"
    "/path/to/roup_wrapper.hpp"
)
target_link_libraries(myapp roup pthread dl m)
</code></pre>
<hr />
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<h4 id="ubuntudebian"><a class="header" href="#ubuntudebian">Ubuntu/Debian</a></h4>
<pre><code class="language-bash"># Install build tools
sudo apt-get update
sudo apt-get install build-essential curl git

# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build ROUP
cargo build --release
</code></pre>
<h4 id="fedorarhel"><a class="header" href="#fedorarhel">Fedora/RHEL</a></h4>
<pre><code class="language-bash"># Install build tools
sudo dnf install gcc git

# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build ROUP
cargo build --release
</code></pre>
<p><strong>Library location</strong>: <code>target/release/libroup.{a,so}</code></p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<pre><code class="language-bash"># Install Xcode Command Line Tools
xcode-select --install

# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build ROUP
cargo build --release
</code></pre>
<p><strong>Library location</strong>: <code>target/release/libroup.{a,dylib}</code></p>
<p><strong>Note</strong>: On macOS, the dynamic library extension is <code>.dylib</code>, not <code>.so</code>.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<h4 id="using-rust-with-msvc"><a class="header" href="#using-rust-with-msvc">Using Rust with MSVC</a></h4>
<pre><code class="language-powershell"># Install Rust (uses MSVC toolchain by default on Windows)
# Download from: https://rustup.rs/

# Install Visual Studio Build Tools
# Download from: https://visualstudio.microsoft.com/downloads/

# Build ROUP
cargo build --release
</code></pre>
<p><strong>Library location</strong>: <code>target\release\roup.{lib,dll}</code></p>
<h4 id="using-rust-with-gnu-mingw"><a class="header" href="#using-rust-with-gnu-mingw">Using Rust with GNU (MinGW)</a></h4>
<pre><code class="language-bash"># Install MSYS2 from https://www.msys2.org/
# Then in MSYS2 terminal:

# Install MinGW toolchain
pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-rust

# Build ROUP
cargo build --release
</code></pre>
<h4 id="wsl-recommended-for-cc"><a class="header" href="#wsl-recommended-for-cc">WSL (Recommended for C/C++)</a></h4>
<p>Windows Subsystem for Linux provides a full Linux environment:</p>
<pre><code class="language-bash"># In WSL (Ubuntu)
sudo apt-get install build-essential
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
cargo build --release
</code></pre>
<hr />
<h2 id="build-configurations"><a class="header" href="#build-configurations">Build Configurations</a></h2>
<h3 id="debug-build-development"><a class="header" href="#debug-build-development">Debug Build (Development)</a></h3>
<pre><code class="language-bash">cargo build

# Output: target/debug/libroup.{a,so}
# Features: Debug symbols, assertions, slower but better errors
</code></pre>
<h3 id="release-build-production"><a class="header" href="#release-build-production">Release Build (Production)</a></h3>
<pre><code class="language-bash">cargo build --release

# Output: target/release/libroup.{a,so}
# Features: Optimized, no debug symbols, faster execution
</code></pre>
<h3 id="release-with-debug-info"><a class="header" href="#release-with-debug-info">Release with Debug Info</a></h3>
<pre><code class="language-bash">cargo build --release --config profile.release.debug=true

# Output: target/release/libroup.{a,so}
# Features: Optimized but with debug symbols for profiling
</code></pre>
<h3 id="custom-features"><a class="header" href="#custom-features">Custom Features</a></h3>
<pre><code class="language-bash"># Build with all features
cargo build --all-features

# Build with specific feature
cargo build --features "serde"

# Build without default features
cargo build --no-default-features
</code></pre>
<hr />
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<h3 id="run-all-tests"><a class="header" href="#run-all-tests">Run All Tests</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_parallel_directive

# Run tests for specific module
cargo test parser::
</code></pre>
<h3 id="run-examples"><a class="header" href="#run-examples">Run Examples</a></h3>
<pre><code class="language-bash"># List available examples
cargo run --example

# Run specific example (if any exist)
cargo run --example parse_simple
</code></pre>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<pre><code class="language-bash"># If benchmarks are available
cargo bench
</code></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="linker-cc-not-found"><a class="header" href="#linker-cc-not-found">"linker <code>cc</code> not found"</a></h3>
<p><strong>Problem</strong>: No C compiler installed.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Linux
sudo apt-get install build-essential

# macOS
xcode-select --install

# Windows
# Install Visual Studio Build Tools
</code></pre>
<h3 id="cannot-find--lroup"><a class="header" href="#cannot-find--lroup">"cannot find -lroup"</a></h3>
<p><strong>Problem</strong>: Linker can't find the ROUP library.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Verify library exists
ls -lh target/release/libroup.*

# Rebuild if needed
cargo build --release

# Check linker path
gcc ... -L$(pwd)/target/release -lroup
</code></pre>
<h3 id="error-while-loading-shared-libraries-libroupso"><a class="header" href="#error-while-loading-shared-libraries-libroupso">"error while loading shared libraries: libroup.so"</a></h3>
<p><strong>Problem</strong>: Runtime can't find dynamic library.</p>
<p><strong>Solution 1 - rpath</strong>:</p>
<pre><code class="language-bash">gcc ... -Wl,-rpath,/path/to/roup/target/release
</code></pre>
<p><strong>Solution 2 - LD_LIBRARY_PATH</strong>:</p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=/path/to/roup/target/release:$LD_LIBRARY_PATH
./myapp
</code></pre>
<p><strong>Solution 3 - Install system-wide</strong>:</p>
<pre><code class="language-bash">sudo cp target/release/libroup.so /usr/local/lib/
sudo ldconfig
</code></pre>
<h3 id="rust-version-too-old"><a class="header" href="#rust-version-too-old">Rust Version Too Old</a></h3>
<p><strong>Problem</strong>: Compilation fails with version error.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Update Rust toolchain
rustup update stable

# Verify version
rustc --version
# Ensure your Rust version is at least 1.85.0
</code></pre>
<h3 id="windows-vcruntime140dll-missing"><a class="header" href="#windows-vcruntime140dll-missing">Windows: "VCRUNTIME140.dll missing"</a></h3>
<p><strong>Problem</strong>: Missing Visual C++ runtime.</p>
<p><strong>Solution</strong>: Download and install <a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist">Visual C++ Redistributable</a></p>
<hr />
<h2 id="build-performance-tips"><a class="header" href="#build-performance-tips">Build Performance Tips</a></h2>
<h3 id="faster-incremental-builds"><a class="header" href="#faster-incremental-builds">Faster Incremental Builds</a></h3>
<pre><code class="language-bash"># Use sccache for caching
cargo install sccache
export RUSTC_WRAPPER=sccache

# Use faster linker (Linux)
sudo apt-get install lld
export RUSTFLAGS="-C link-arg=-fuse-ld=lld"
</code></pre>
<h3 id="parallel-builds"><a class="header" href="#parallel-builds">Parallel Builds</a></h3>
<pre><code class="language-bash"># Use all CPU cores (default)
cargo build -j $(nproc)

# Limit parallel jobs
cargo build -j 4
</code></pre>
<h3 id="reduce-binary-size"><a class="header" href="#reduce-binary-size">Reduce Binary Size</a></h3>
<pre><code class="language-toml"># Add to Cargo.toml
[profile.release]
opt-level = "z"     # Optimize for size
lto = true          # Link-time optimization
codegen-units = 1   # Better optimization
strip = true        # Remove debug symbols
</code></pre>
<hr />
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h2>
<h3 id="linux-to-windows"><a class="header" href="#linux-to-windows">Linux to Windows</a></h3>
<pre><code class="language-bash"># Install target
rustup target add x86_64-pc-windows-gnu

# Install MinGW
sudo apt-get install mingw-w64

# Build
cargo build --release --target x86_64-pc-windows-gnu
</code></pre>
<h3 id="macos-to-linux"><a class="header" href="#macos-to-linux">macOS to Linux</a></h3>
<pre><code class="language-bash"># Install target
rustup target add x86_64-unknown-linux-gnu

# Build (requires cross-compilation setup)
cargo build --release --target x86_64-unknown-linux-gnu
</code></pre>
<p>For more complex cross-compilation, consider <a href="https://github.com/cross-rs/cross">cross</a>:</p>
<pre><code class="language-bash">cargo install cross
cross build --release --target x86_64-unknown-linux-gnu
</code></pre>
<hr />
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<h3 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h3>
<p>Recommended extensions:</p>
<ul>
<li><strong>rust-analyzer</strong> - Language server</li>
<li><strong>CodeLLDB</strong> - Debugger</li>
<li><strong>crates</strong> - Dependency management</li>
</ul>
<h3 id="clion--intellij-idea"><a class="header" href="#clion--intellij-idea">CLion / IntelliJ IDEA</a></h3>
<p>Install the Rust plugin from JetBrains marketplace.</p>
<h3 id="vimneovim"><a class="header" href="#vimneovim">Vim/Neovim</a></h3>
<p>Use rust-analyzer with your LSP client (coc.nvim, nvim-lspconfig, etc.)</p>
<hr />
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>After building successfully:</p>
<ul>
<li><strong>Rust developers</strong>: See <a href="./rust-tutorial.html">Rust Tutorial</a></li>
<li><strong>C developers</strong>: See <a href="./c-tutorial.html">C Tutorial</a></li>
<li><strong>C++ developers</strong>: See <a href="./cpp-tutorial.html">C++ Tutorial</a></li>
<li><strong>API Reference</strong>: See <a href="./api-reference.html">API Reference</a></li>
</ul>
<hr />
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>Build issues</strong>: Check <a href="https://github.com/ouankou/roup/issues">GitHub Issues</a></li>
<li><strong>Questions</strong>: See <a href="./faq.html">FAQ</a></li>
<li><strong>Examples</strong>: Browse <code>examples/</code> directory</li>
<li><strong>Documentation</strong>: Read <code>docs/</code> directory</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-tutorial"><a class="header" href="#rust-tutorial">Rust Tutorial</a></h1>
<p>Learn idiomatic Rust patterns for parsing and querying OpenMP directives with ROUP.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This tutorial covers:</p>
<ol>
<li><a href="rust-tutorial.html#basic-parsing">Basic Parsing</a> - Parse your first directive</li>
<li><a href="rust-tutorial.html#error-handling">Error Handling</a> - Robust error handling patterns</li>
<li><a href="rust-tutorial.html#querying-directives">Querying Directives</a> - Extract directive information</li>
<li><a href="rust-tutorial.html#working-with-clauses">Working with Clauses</a> - Iterate and pattern match clauses</li>
<li><a href="rust-tutorial.html#advanced-patterns">Advanced Patterns</a> - Real-world usage patterns</li>
<li><a href="rust-tutorial.html#testing">Testing</a> - Writing tests for your parser integration</li>
</ol>
<hr />
<h2 id="basic-parsing"><a class="header" href="#basic-parsing">Basic Parsing</a></h2>
<h3 id="your-first-parse"><a class="header" href="#your-first-parse">Your First Parse</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel";
    
    match parse_openmp_directive(input, Language::C) {
        Ok(directive) =&gt; {
            println!("Successfully parsed: {:?}", directive.kind);
        }
        Err(e) =&gt; {
            eprintln!("Parse error: {}", e);
        }
    }
}</code></pre>
<h3 id="parse-with-clauses"><a class="header" href="#parse-with-clauses">Parse with Clauses</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel for num_threads(4) private(x, y)";
    
    match parse_openmp_directive(input, Language::C) {
        Ok(directive) =&gt; {
            println!("Directive: {:?}", directive.kind);
            println!("Clauses: {}", directive.clauses.len());
            
            for (i, clause) in directive.clauses.iter().enumerate() {
                println!("  Clause {}: {:?}", i + 1, clause);
            }
        }
        Err(e) =&gt; {
            eprintln!("Failed to parse: {}", e);
        }
    }
}</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Directive: ParallelFor
Clauses: 2
  Clause 1: NumThreads(Expr { value: "4", .. })
  Clause 2: Private { items: ["x", "y"], .. }
</code></pre>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="basic-error-handling"><a class="header" href="#basic-error-handling">Basic Error Handling</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::lexer::Language;

fn parse_directive(input: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let directive = parse_openmp_directive(input, Language::C)?;
    
    println!("Parsed: {:?}", directive.kind);
    println!("Location: line {}, column {}", 
             directive.location.line, 
             directive.location.column);
    
    Ok(())
}

fn main() {
    let inputs = vec![
        "#pragma omp parallel",
        "#pragma omp for schedule(static)",
        "#pragma omp invalid",  // This will fail
    ];
    
    for input in inputs {
        match parse_directive(input) {
            Ok(()) =&gt; println!("✓ Success: {}", input),
            Err(e) =&gt; eprintln!("✗ Error: {} - {}", input, e),
        }
    }
}</code></pre>
<h3 id="custom-error-type"><a class="header" href="#custom-error-type">Custom Error Type</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::lexer::Language;
use std::fmt;

#[derive(Debug)]
enum OpenMPError {
    ParseError(String),
    UnsupportedDirective(String),
    MissingRequiredClause(String),
}

impl fmt::Display for OpenMPError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            OpenMPError::ParseError(msg) =&gt; write!(f, "Parse error: {}", msg),
            OpenMPError::UnsupportedDirective(kind) =&gt; {
                write!(f, "Unsupported directive: {}", kind)
            }
            OpenMPError::MissingRequiredClause(clause) =&gt; {
                write!(f, "Missing required clause: {}", clause)
            }
        }
    }
}

impl std::error::Error for OpenMPError {}

fn validate_parallel_directive(input: &amp;str) -&gt; Result&lt;(), OpenMPError&gt; {
    let directive = parse_openmp_directive(input, Language::C)
        .map_err(|e| OpenMPError::ParseError(e.to_string()))?;
    
    if !directive.kind.is_parallel() {
        return Err(OpenMPError::UnsupportedDirective(
            format!("{:?}", directive.kind)
        ));
    }
    
    // Check for required clauses (example: must have num_threads)
    let has_num_threads = directive.clauses.iter()
        .any(|c| c.is_num_threads());
    
    if !has_num_threads {
        return Err(OpenMPError::MissingRequiredClause("num_threads".into()));
    }
    
    Ok(())
}

fn main() {
    match validate_parallel_directive("#pragma omp parallel num_threads(4)") {
        Ok(()) =&gt; println!("✓ Valid parallel directive"),
        Err(e) =&gt; eprintln!("✗ {}", e),
    }
}</code></pre>
<hr />
<h2 id="querying-directives"><a class="header" href="#querying-directives">Querying Directives</a></h2>
<h3 id="check-directive-kind"><a class="header" href="#check-directive-kind">Check Directive Kind</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::ir::DirectiveKind;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel for";
    let directive = parse_openmp_directive(input, Language::C).unwrap();
    
    // Pattern match on kind
    match directive.kind {
        DirectiveKind::Parallel =&gt; println!("This is a parallel directive"),
        DirectiveKind::For =&gt; println!("This is a for directive"),
        DirectiveKind::ParallelFor =&gt; println!("This is a combined parallel for"),
        DirectiveKind::Target =&gt; println!("This is a target directive"),
        _ =&gt; println!("Other directive type"),
    }
    
    // Or use helper methods
    if directive.kind.is_parallel() {
        println!("Contains parallel semantics");
    }
    
    if directive.kind.is_worksharing() {
        println!("Is a worksharing construct");
    }
}</code></pre>
<h3 id="extract-source-location"><a class="header" href="#extract-source-location">Extract Source Location</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel";
    let directive = parse_openmp_directive(input, Language::C).unwrap();
    
    println!("Directive found at:");
    println!("  Line: {}", directive.location.line);
    println!("  Column: {}", directive.location.column);
    println!("  Language: {:?}", directive.language);
}</code></pre>
<hr />
<h2 id="working-with-clauses"><a class="header" href="#working-with-clauses">Working with Clauses</a></h2>
<h3 id="iterate-over-clauses"><a class="header" href="#iterate-over-clauses">Iterate Over Clauses</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel num_threads(8) default(shared) private(x)";
    let directive = parse_openmp_directive(input, Language::C).unwrap();
    
    println!("Found {} clauses:", directive.clauses.len());
    
    for clause in &amp;directive.clauses {
        println!("  - {:?}", clause);
    }
}</code></pre>
<h3 id="pattern-match-on-clauses"><a class="header" href="#pattern-match-on-clauses">Pattern Match on Clauses</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::ir::ClauseData;
use roup::lexer::Language;

fn main() {
    let input = "#pragma omp parallel num_threads(4) default(shared) private(x, y)";
    let directive = parse_openmp_directive(input, Language::C).unwrap();
    
    for clause in &amp;directive.clauses {
        match clause {
            ClauseData::NumThreads(expr) =&gt; {
                println!("Thread count: {}", expr.value);
            }
            ClauseData::Default(kind) =&gt; {
                println!("Default sharing: {:?}", kind);
            }
            ClauseData::Private { items, .. } =&gt; {
                println!("Private variables: {:?}", items);
            }
            ClauseData::Shared { items, .. } =&gt; {
                println!("Shared variables: {:?}", items);
            }
            ClauseData::Reduction { operator, items, .. } =&gt; {
                println!("Reduction: {:?} on {:?}", operator, items);
            }
            _ =&gt; {
                println!("Other clause: {:?}", clause);
            }
        }
    }
}</code></pre>
<h3 id="find-specific-clauses"><a class="header" href="#find-specific-clauses">Find Specific Clauses</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::ir::ClauseData;
use roup::lexer::Language;

fn get_thread_count(input: &amp;str) -&gt; Option&lt;String&gt; {
    let directive = parse_openmp_directive(input, Language::C).ok()?;
    
    directive.clauses.iter()
        .find_map(|clause| {
            if let ClauseData::NumThreads(expr) = clause {
                Some(expr.value.to_string())
            } else {
                None
            }
        })
}

fn get_private_vars(input: &amp;str) -&gt; Vec&lt;String&gt; {
    let directive = parse_openmp_directive(input, Language::C)
        .ok()
        .unwrap_or_default();
    
    directive.clauses.iter()
        .filter_map(|clause| {
            if let ClauseData::Private { items, .. } = clause {
                Some(items.iter().map(|s| s.to_string()).collect())
            } else {
                None
            }
        })
        .flatten()
        .collect()
}

fn main() {
    let input = "#pragma omp parallel num_threads(8) private(x, y, z)";
    
    if let Some(count) = get_thread_count(input) {
        println!("Thread count: {}", count);
    }
    
    let vars = get_private_vars(input);
    println!("Private variables: {:?}", vars);
}</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Thread count: 8
Private variables: ["x", "y", "z"]
</code></pre>
<hr />
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="parse-multiple-directives"><a class="header" href="#parse-multiple-directives">Parse Multiple Directives</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::ir::DirectiveIR;
use roup::lexer::Language;

fn parse_file_directives(source: &amp;str) -&gt; Vec&lt;DirectiveIR&gt; {
    source.lines()
        .filter(|line| line.trim().starts_with("#pragma omp"))
        .filter_map(|line| {
            parse_openmp_directive(line, Language::C).ok()
        })
        .collect()
}

fn main() {
    let source = r#"
    #pragma omp parallel num_threads(4)
    for (int i = 0; i &lt; n; i++) {
        #pragma omp task
        process(i);
    }
    #pragma omp taskwait
    "#;
    
    let directives = parse_file_directives(source);
    
    println!("Found {} OpenMP directives:", directives.len());
    for (i, dir) in directives.iter().enumerate() {
        println!("  {}. {:?} at line {}", 
                 i + 1, dir.kind, dir.location.line);
    }
}</code></pre>
<h3 id="directive-analysis"><a class="header" href="#directive-analysis">Directive Analysis</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::ir::{DirectiveIR, ClauseData};
use roup::lexer::Language;

struct DirectiveStats {
    total_clauses: usize,
    has_data_sharing: bool,
    has_scheduling: bool,
    has_reduction: bool,
    thread_count: Option&lt;String&gt;,
}

impl DirectiveStats {
    fn analyze(directive: &amp;DirectiveIR) -&gt; Self {
        let total_clauses = directive.clauses.len();
        
        let mut has_data_sharing = false;
        let mut has_scheduling = false;
        let mut has_reduction = false;
        let mut thread_count = None;
        
        for clause in &amp;directive.clauses {
            match clause {
                ClauseData::Private { .. } | 
                ClauseData::Shared { .. } |
                ClauseData::Firstprivate { .. } |
                ClauseData::Lastprivate { .. } =&gt; {
                    has_data_sharing = true;
                }
                ClauseData::Schedule { .. } =&gt; {
                    has_scheduling = true;
                }
                ClauseData::Reduction { .. } =&gt; {
                    has_reduction = true;
                }
                ClauseData::NumThreads(expr) =&gt; {
                    thread_count = Some(expr.value.to_string());
                }
                _ =&gt; {}
            }
        }
        
        Self {
            total_clauses,
            has_data_sharing,
            has_scheduling,
            has_reduction,
            thread_count,
        }
    }
}

fn main() {
    let input = "#pragma omp parallel for num_threads(4) \
                 schedule(static) private(x) reduction(+:sum)";
    
    let directive = parse_openmp_directive(input, Language::C).unwrap();
    let stats = DirectiveStats::analyze(&amp;directive);
    
    println!("Directive Analysis:");
    println!("  Total clauses: {}", stats.total_clauses);
    println!("  Has data-sharing: {}", stats.has_data_sharing);
    println!("  Has scheduling: {}", stats.has_scheduling);
    println!("  Has reduction: {}", stats.has_reduction);
    if let Some(count) = stats.thread_count {
        println!("  Thread count: {}", count);
    }
}</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Directive Analysis:
  Total clauses: 4
  Has data-sharing: true
  Has scheduling: true
  Has reduction: true
  Thread count: 4
</code></pre>
<h3 id="building-a-directive-validator"><a class="header" href="#building-a-directive-validator">Building a Directive Validator</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp::parse_openmp_directive;
use roup::ir::{DirectiveIR, DirectiveKind, ClauseData};
use roup::lexer::Language;

struct ValidationRule {
    name: &amp;'static str,
    check: fn(&amp;DirectiveIR) -&gt; bool,
}

fn validate_directive(directive: &amp;DirectiveIR, rules: &amp;[ValidationRule]) -&gt; Vec&lt;String&gt; {
    rules.iter()
        .filter(|rule| !(rule.check)(directive))
        .map(|rule| rule.name.to_string())
        .collect()
}

fn main() {
    let rules = vec![
        ValidationRule {
            name: "Parallel regions should specify thread count",
            check: |dir| {
                !dir.kind.is_parallel() || 
                dir.clauses.iter().any(|c| matches!(c, ClauseData::NumThreads(_)))
            },
        },
        ValidationRule {
            name: "For loops with reduction should have schedule clause",
            check: |dir| {
                let has_reduction = dir.clauses.iter()
                    .any(|c| matches!(c, ClauseData::Reduction { .. }));
                let has_schedule = dir.clauses.iter()
                    .any(|c| matches!(c, ClauseData::Schedule { .. }));
                
                !has_reduction || has_schedule
            },
        },
    ];
    
    let input = "#pragma omp parallel";  // Missing num_threads
    let directive = parse_openmp_directive(input, Language::C).unwrap();
    
    let violations = validate_directive(&amp;directive, &amp;rules);
    
    if violations.is_empty() {
        println!("✓ All validation rules passed");
    } else {
        println!("✗ Validation warnings:");
        for violation in violations {
            println!("  - {}", violation);
        }
    }
}</code></pre>
<hr />
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use roup::parser::openmp::parse_openmp_directive;
    use roup::ir::DirectiveKind;
    use roup::lexer::Language;
    
    #[test]
    fn test_parse_parallel() {
        let input = "#pragma omp parallel";
        let result = parse_openmp_directive(input, Language::C);
        
        assert!(result.is_ok());
        let directive = result.unwrap();
        assert_eq!(directive.kind, DirectiveKind::Parallel);
        assert_eq!(directive.clauses.len(), 0);
    }
    
    #[test]
    fn test_parse_with_clauses() {
        let input = "#pragma omp parallel num_threads(4)";
        let directive = parse_openmp_directive(input, Language::C).unwrap();
        
        assert_eq!(directive.kind, DirectiveKind::Parallel);
        assert_eq!(directive.clauses.len(), 1);
    }
    
    #[test]
    fn test_invalid_directive() {
        let input = "#pragma omp invalid_directive";
        let result = parse_openmp_directive(input, Language::C);
        
        assert!(result.is_err());
    }
    
    #[test]
    fn test_fortran_syntax() {
        let input = "!$omp parallel";
        let result = parse_openmp_directive(input, Language::Fortran);
        
        assert!(result.is_ok());
        let directive = result.unwrap();
        assert_eq!(directive.kind, DirectiveKind::Parallel);
    }
}</code></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod integration_tests {
    use roup::parser::openmp::parse_openmp_directive;
    use roup::ir::ClauseData;
    use roup::lexer::Language;
    
    #[test]
    fn test_complete_parsing_pipeline() {
        let inputs = vec![
            "#pragma omp parallel",
            "#pragma omp for schedule(static)",
            "#pragma omp parallel for num_threads(8) private(x)",
            "#pragma omp task depend(in: x) priority(10)",
        ];
        
        for input in inputs {
            let result = parse_openmp_directive(input, Language::C);
            assert!(result.is_ok(), "Failed to parse: {}", input);
            
            let directive = result.unwrap();
            assert!(directive.kind.is_valid());
            
            // Verify round-trip
            let output = directive.to_string();
            assert!(!output.is_empty());
        }
    }
    
    #[test]
    fn test_clause_extraction() {
        let input = "#pragma omp parallel for \
                     num_threads(4) \
                     schedule(dynamic, 100) \
                     private(i, j) \
                     reduction(+:sum)";
        
        let directive = parse_openmp_directive(input, Language::C).unwrap();
        
        // Count clause types
        let mut num_threads_count = 0;
        let mut schedule_count = 0;
        let mut private_count = 0;
        let mut reduction_count = 0;
        
        for clause in &amp;directive.clauses {
            match clause {
                ClauseData::NumThreads(_) =&gt; num_threads_count += 1,
                ClauseData::Schedule { .. } =&gt; schedule_count += 1,
                ClauseData::Private { .. } =&gt; private_count += 1,
                ClauseData::Reduction { .. } =&gt; reduction_count += 1,
                _ =&gt; {}
            }
        }
        
        assert_eq!(num_threads_count, 1);
        assert_eq!(schedule_count, 1);
        assert_eq!(private_count, 1);
        assert_eq!(reduction_count, 1);
    }
}</code></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-always-handle-errors"><a class="header" href="#1-always-handle-errors">1. Always Handle Errors</a></h3>
<pre><code class="language-rust ignore">// ❌ Bad - unwrap can panic
let directive = parse_openmp_directive(input, Language::C).unwrap();

// ✅ Good - explicit error handling
match parse_openmp_directive(input, Language::C) {
    Ok(directive) =&gt; { /* use directive */ }
    Err(e) =&gt; { /* handle error */ }
}</code></pre>
<h3 id="2-use-pattern-matching"><a class="header" href="#2-use-pattern-matching">2. Use Pattern Matching</a></h3>
<pre><code class="language-rust ignore">// ❌ Bad - lots of if-let chains
for clause in &amp;directive.clauses {
    if let ClauseData::NumThreads(expr) = clause {
        // ...
    } else if let ClauseData::Private { items, .. } = clause {
        // ...
    }
}

// ✅ Good - clean match expression
for clause in &amp;directive.clauses {
    match clause {
        ClauseData::NumThreads(expr) =&gt; { /* ... */ }
        ClauseData::Private { items, .. } =&gt; { /* ... */ }
        _ =&gt; {}
    }
}</code></pre>
<h3 id="3-leverage-iterator-combinators"><a class="header" href="#3-leverage-iterator-combinators">3. Leverage Iterator Combinators</a></h3>
<pre><code class="language-rust ignore">// ❌ Bad - manual iteration
let mut has_reduction = false;
for clause in &amp;directive.clauses {
    if matches!(clause, ClauseData::Reduction { .. }) {
        has_reduction = true;
        break;
    }
}

// ✅ Good - iterator method
let has_reduction = directive.clauses.iter()
    .any(|c| matches!(c, ClauseData::Reduction { .. }));</code></pre>
<h3 id="4-create-helper-functions"><a class="header" href="#4-create-helper-functions">4. Create Helper Functions</a></h3>
<pre><code class="language-rust ignore">// Reusable helper
fn has_clause&lt;F&gt;(directive: &amp;DirectiveIR, predicate: F) -&gt; bool
where
    F: Fn(&amp;ClauseData) -&gt; bool,
{
    directive.clauses.iter().any(predicate)
}

// Usage
if has_clause(&amp;directive, |c| matches!(c, ClauseData::NumThreads(_))) {
    println!("Has num_threads clause");
}</code></pre>
<hr />
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><strong><a href="./c-tutorial.html">C Tutorial</a></strong> - Learn the C FFI API</li>
<li><strong><a href="./cpp-tutorial.html">C++ Tutorial</a></strong> - Build a real-world application</li>
<li><strong><a href="./api-reference.html">API Reference</a></strong> - Complete Rust API documentation</li>
<li><strong>Examples</strong> - Check out <code>tests/</code> directory for 355+ test cases</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Key Takeaways:</strong></p>
<ol>
<li>Use <code>parse_openmp_directive()</code> for parsing</li>
<li>Handle errors with <code>Result</code> types</li>
<li>Pattern match on <code>DirectiveKind</code> and <code>ClauseData</code></li>
<li>Use iterators for clause analysis</li>
<li>Write tests for your integration code</li>
</ol>
<p><strong>Common Patterns:</strong></p>
<pre><code class="language-rust ignore">// Parse
let directive = parse_openmp_directive(input, Language::C)?;

// Check kind
if directive.kind.is_parallel() { /* ... */ }

// Find clause
let num_threads = directive.clauses.iter()
    .find_map(|c| match c {
        ClauseData::NumThreads(expr) =&gt; Some(expr.value.clone()),
        _ =&gt; None,
    });

// Analyze all clauses
for clause in &amp;directive.clauses {
    match clause {
        ClauseData::Private { items, .. } =&gt; { /* ... */ }
        ClauseData::Shared { items, .. } =&gt; { /* ... */ }
        _ =&gt; {}
    }
}</code></pre>
<p><strong>Happy parsing!</strong> 🦀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-tutorial"><a class="header" href="#c-tutorial">C Tutorial</a></h1>
<p>This tutorial demonstrates how to use ROUP's <strong>minimal unsafe pointer-based C API</strong> for parsing OpenMP directives. The API uses direct C pointers following standard malloc/free patterns familiar to C programmers.</p>
<blockquote>
<p><strong>API Design</strong>: Direct pointers (<code>*mut OmpDirective</code>, <code>*mut OmpClause</code>) with manual memory management. No global state, no handles.</p>
<p><strong>Source</strong>: <code>src/c_api.rs</code> - 16 FFI functions, ~60 lines of unsafe code</p>
</blockquote>
<hr />
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>C compiler (GCC, Clang, or MSVC)</li>
<li>ROUP library compiled (see <a href="./building.html">Building Guide</a>)</li>
<li>Basic understanding of malloc/free patterns</li>
</ul>
<p><strong>Example code</strong>: See <code>examples/c/tutorial_basic.c</code> for a complete working example.</p>
<hr />
<h2 id="step-1-setup-and-compilation"><a class="header" href="#step-1-setup-and-compilation">Step 1: Setup and Compilation</a></h2>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code class="language-text">my-project/
├── src/
│   └── main.c
├── include/
│   └── roup_ffi.h      # Forward declarations
└── libroup.a            # Built from cargo build
</code></pre>
<h3 id="forward-declarations"><a class="header" href="#forward-declarations">Forward Declarations</a></h3>
<p>Create <code>include/roup_ffi.h</code> with the C API declarations:</p>
<pre><code class="language-c ignore">#ifndef ROUP_FFI_H
#define ROUP_FFI_H

#include &lt;stdint.h&gt;

// Opaque types (defined in Rust)
typedef struct OmpDirective OmpDirective;
typedef struct OmpClause OmpClause;
typedef struct OmpClauseIterator OmpClauseIterator;
typedef struct OmpStringList OmpStringList;

// Lifecycle functions
extern OmpDirective* roup_parse(const char* input);
extern void roup_directive_free(OmpDirective* directive);
extern void roup_clause_free(OmpClause* clause);

// Directive queries
extern int32_t roup_directive_kind(const OmpDirective* directive);
extern int32_t roup_directive_clause_count(const OmpDirective* directive);
extern OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);

// Iterator functions
extern int32_t roup_clause_iterator_next(OmpClauseIterator* iter, OmpClause** out);
extern void roup_clause_iterator_free(OmpClauseIterator* iter);

// Clause queries
extern int32_t roup_clause_kind(const OmpClause* clause);
extern int32_t roup_clause_schedule_kind(const OmpClause* clause);
extern int32_t roup_clause_reduction_operator(const OmpClause* clause);
extern int32_t roup_clause_default_data_sharing(const OmpClause* clause);

// Variable lists
extern OmpStringList* roup_clause_variables(const OmpClause* clause);
extern int32_t roup_string_list_len(const OmpStringList* list);
extern const char* roup_string_list_get(const OmpStringList* list, int32_t index);
extern void roup_string_list_free(OmpStringList* list);

#endif // ROUP_FFI_H
</code></pre>
<h3 id="compilation"><a class="header" href="#compilation">Compilation</a></h3>
<p><strong>Option 1: Using GCC/Clang</strong></p>
<pre><code class="language-bash"># Build ROUP library
cargo build --release

# Compile C program
gcc -o my_app src/main.c \
    -I include \
    -L target/release \
    -lroup \
    -lpthread -ldl -lm
</code></pre>
<p><strong>Option 2: Using CMake</strong></p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.10)
project(roup_example C)

add_executable(my_app src/main.c)
target_include_directories(my_app PRIVATE include)
target_link_libraries(my_app ${CMAKE_SOURCE_DIR}/target/release/libroup.a pthread dl m)
</code></pre>
<hr />
<h2 id="step-2-parse-a-simple-directive"><a class="header" href="#step-2-parse-a-simple-directive">Step 2: Parse a Simple Directive</a></h2>
<p>Let's start with the most basic operation: parsing a simple directive.</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include "roup_ffi.h"

int main(void) {
    const char* input = "#pragma omp parallel";
    
    // Parse the directive
    OmpDirective* dir = roup_parse(input);
    
    // Check for errors (NULL = parse failed)
    if (!dir) {
        fprintf(stderr, "Parse failed!\n");
        return 1;
    }
    
    printf("✅ Parse succeeded!\n");
    
    // IMPORTANT: Free the directive
    roup_directive_free(dir);
    
    return 0;
}
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><code>roup_parse()</code> returns a pointer or <code>NULL</code> on error</li>
<li>Always check for <code>NULL</code> before using the directive</li>
<li><strong>Always call <code>roup_directive_free()</code></strong> to prevent memory leaks</li>
</ul>
<hr />
<h2 id="step-3-query-directive-properties"><a class="header" href="#step-3-query-directive-properties">Step 3: Query Directive Properties</a></h2>
<p>After parsing, you can query the directive's properties:</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include "roup_ffi.h"

int main(void) {
    const char* input = "#pragma omp parallel for num_threads(4)";
    
    OmpDirective* dir = roup_parse(input);
    if (!dir) {
        return 1;
    }
    
    // Query directive properties
    int32_t kind = roup_directive_kind(dir);
    int32_t clause_count = roup_directive_clause_count(dir);
    
    printf("Directive kind: %d\n", kind);
    printf("Clause count: %d\n", clause_count);
    
    roup_directive_free(dir);
    return 0;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Directive kind: 28
Clause count: 1
</code></pre>
<blockquote>
<p><strong>Note</strong>: Directive kind is an integer from the parser's internal registry. For practical use, you typically care more about the clauses than the exact directive kind. The kind value comes from the order in which directives were registered in <code>src/parser/openmp.rs</code> - these internal IDs are not part of the stable API and may change between versions.</p>
</blockquote>
<hr />
<h2 id="step-4-iterate-through-clauses"><a class="header" href="#step-4-iterate-through-clauses">Step 4: Iterate Through Clauses</a></h2>
<p>To access individual clauses, use the iterator pattern:</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include "roup_ffi.h"

const char* clause_name(int32_t kind) {
    switch(kind) {
        case 0: return "num_threads";
        case 1: return "if";
        case 2: return "private";
        case 3: return "shared";
        case 6: return "reduction";
        case 7: return "schedule";
        case 10: return "nowait";
        default: return "unknown";
    }
}

int main(void) {
    const char* input = "#pragma omp parallel num_threads(8) default(shared) nowait";
    
    OmpDirective* dir = roup_parse(input);
    if (!dir) return 1;
    
    // Create iterator
    OmpClauseIterator* iter = roup_directive_clauses_iter(dir);
    if (!iter) {
        roup_directive_free(dir);
        return 1;
    }
    
    // Iterate through clauses
    printf("Clauses:\n");
    OmpClause* clause;
    while (roup_clause_iterator_next(iter, &amp;clause)) {
        int32_t kind = roup_clause_kind(clause);
        printf("  - %s (kind=%d)\n", clause_name(kind), kind);
    }
    
    // Cleanup
    roup_clause_iterator_free(iter);
    roup_directive_free(dir);
    
    return 0;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Clauses:
  - num_threads (kind=0)
  - default (kind=11)
  - nowait (kind=10)
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><code>roup_clause_iterator_next()</code> returns <code>1</code> if clause available, <code>0</code> when done</li>
<li>Write the clause pointer to <code>out</code> parameter</li>
<li>Always free the iterator with <code>roup_clause_iterator_free()</code></li>
</ul>
<hr />
<h2 id="step-5-query-clause-specific-data"><a class="header" href="#step-5-query-clause-specific-data">Step 5: Query Clause-Specific Data</a></h2>
<p>Different clause types have different data. Use type-specific query functions:</p>
<h3 id="schedule-clause"><a class="header" href="#schedule-clause">Schedule Clause</a></h3>
<pre><code class="language-c ignore">OmpClause* clause = /* ... get clause ... */;
if (roup_clause_kind(clause) == 7) {  // SCHEDULE
    int32_t sched = roup_clause_schedule_kind(clause);
    const char* names[] = {"static", "dynamic", "guided", "auto", "runtime"};
    printf("Schedule: %s\n", names[sched]);
}
</code></pre>
<h3 id="reduction-clause"><a class="header" href="#reduction-clause">Reduction Clause</a></h3>
<pre><code class="language-c ignore">if (roup_clause_kind(clause) == 6) {  // REDUCTION
    int32_t op = roup_clause_reduction_operator(clause);
    const char* ops[] = {"+", "-", "*", "&amp;", "|", "^", "&amp;&amp;", "||", "min", "max"};
    printf("Reduction operator: %s\n", ops[op]);
}
</code></pre>
<h3 id="default-clause"><a class="header" href="#default-clause">Default Clause</a></h3>
<pre><code class="language-c ignore">if (roup_clause_kind(clause) == 11) {  // DEFAULT
    int32_t def = roup_clause_default_data_sharing(clause);
    printf("Default: %s\n", def == 0 ? "shared" : "none");
}
</code></pre>
<h3 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h3>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include "roup_ffi.h"

int main(void) {
    const char* input = "#pragma omp parallel for schedule(static, 10) reduction(+:sum)";
    
    OmpDirective* dir = roup_parse(input);
    if (!dir) return 1;
    
    OmpClauseIterator* iter = roup_directive_clauses_iter(dir);
    if (!iter) {
        roup_directive_free(dir);
        return 1;
    }
    
    OmpClause* clause;
    while (roup_clause_iterator_next(iter, &amp;clause)) {
        int32_t kind = roup_clause_kind(clause);
        
        if (kind == 7) {  // SCHEDULE
            int32_t sched = roup_clause_schedule_kind(clause);
            const char* names[] = {"static", "dynamic", "guided", "auto", "runtime"};
            printf("Schedule: %s\n", names[sched]);
        }
        else if (kind == 6) {  // REDUCTION
            int32_t op = roup_clause_reduction_operator(clause);
            const char* ops[] = {"+", "-", "*", "&amp;", "|", "^", "&amp;&amp;", "||", "min", "max"};
            printf("Reduction: %s\n", ops[op]);
        }
    }
    
    roup_clause_iterator_free(iter);
    roup_directive_free(dir);
    
    return 0;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">Schedule: static
Reduction: +
</code></pre>
<hr />
<h2 id="step-6-access-variable-lists"><a class="header" href="#step-6-access-variable-lists">Step 6: Access Variable Lists</a></h2>
<p>Clauses like <code>private(x, y, z)</code> contain lists of variables:</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include "roup_ffi.h"

int main(void) {
    const char* input = "#pragma omp parallel private(x, y, z) shared(a, b)";
    
    OmpDirective* dir = roup_parse(input);
    if (!dir) return 1;
    
    OmpClauseIterator* iter = roup_directive_clauses_iter(dir);
    if (!iter) {
        roup_directive_free(dir);
        return 1;
    }
    
    OmpClause* clause;
    while (roup_clause_iterator_next(iter, &amp;clause)) {
        int32_t kind = roup_clause_kind(clause);
        
        // Get variable list
        OmpStringList* vars = roup_clause_variables(clause);
        if (vars) {
            int32_t len = roup_string_list_len(vars);
            
            const char* kind_name = (kind == 2) ? "private" : "shared";
            printf("%s variables: ", kind_name);
            
            for (int32_t i = 0; i &lt; len; i++) {
                const char* var = roup_string_list_get(vars, i);
                printf("%s%s", var, (i &lt; len - 1) ? ", " : "");
            }
            printf("\n");
            
            roup_string_list_free(vars);
        }
    }
    
    roup_clause_iterator_free(iter);
    roup_directive_free(dir);
    
    return 0;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">private variables: x, y, z
shared variables: a, b
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><code>roup_clause_variables()</code> returns a <code>OmpStringList*</code> or <code>NULL</code></li>
<li>Use <code>roup_string_list_len()</code> to get the count</li>
<li>Use <code>roup_string_list_get(list, index)</code> to access individual strings</li>
<li><strong>Always call <code>roup_string_list_free()</code></strong> when done</li>
</ul>
<hr />
<h2 id="step-7-error-handling"><a class="header" href="#step-7-error-handling">Step 7: Error Handling</a></h2>
<p>Robust error handling is crucial. The API returns <code>NULL</code> on failure:</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include "roup_ffi.h"

int main(void) {
    // Test 1: Invalid syntax
    const char* invalid = "#pragma omp INVALID_DIRECTIVE";
    OmpDirective* dir1 = roup_parse(invalid);
    if (!dir1) {
        printf("✓ Invalid syntax correctly rejected\n");
    }
    
    // Test 2: NULL input
    OmpDirective* dir2 = roup_parse(NULL);
    if (!dir2) {
        printf("✓ NULL input correctly rejected\n");
    }
    
    // Test 3: Empty string
    OmpDirective* dir3 = roup_parse("");
    if (!dir3) {
        printf("✓ Empty string correctly rejected\n");
    }
    
    // Test 4: Querying NULL
    int32_t kind = roup_directive_kind(NULL);
    printf("roup_directive_kind(NULL) = %d\n", kind);  // Returns -1
    
    return 0;
}
</code></pre>
<p><strong>Error Handling Guidelines:</strong></p>
<ol>
<li>Always check <code>roup_parse()</code> return value for <code>NULL</code></li>
<li>Check <code>roup_directive_clauses_iter()</code> for <code>NULL</code></li>
<li>Query functions return <code>-1</code> or safe defaults for <code>NULL</code> inputs</li>
<li>Free resources even in error paths (if allocated)</li>
</ol>
<hr />
<h2 id="step-8-complete-example"><a class="header" href="#step-8-complete-example">Step 8: Complete Example</a></h2>
<p>Here's a complete program that demonstrates all concepts:</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "roup_ffi.h"

void print_clause_details(OmpClause* clause) {
    int32_t kind = roup_clause_kind(clause);
    
    switch(kind) {
        case 0:
            printf("  - num_threads\n");
            break;
        case 2: {
            printf("  - private(");
            OmpStringList* vars = roup_clause_variables(clause);
            if (vars) {
                int32_t len = roup_string_list_len(vars);
                for (int32_t i = 0; i &lt; len; i++) {
                    printf("%s%s", roup_string_list_get(vars, i), 
                           (i &lt; len - 1) ? ", " : "");
                }
                roup_string_list_free(vars);
            }
            printf(")\n");
            break;
        }
        case 6: {
            printf("  - reduction(");
            int32_t op = roup_clause_reduction_operator(clause);
            const char* ops[] = {"+", "-", "*", "&amp;", "|", "^", "&amp;&amp;", "||", "min", "max"};
            if (op &gt;= 0 &amp;&amp; op &lt; 10) {
                printf("%s", ops[op]);
            }
            printf(":...)\n");
            break;
        }
        case 7: {
            printf("  - schedule(");
            int32_t sched = roup_clause_schedule_kind(clause);
            const char* names[] = {"static", "dynamic", "guided", "auto", "runtime"};
            if (sched &gt;= 0 &amp;&amp; sched &lt; 5) {
                printf("%s", names[sched]);
            }
            printf(")\n");
            break;
        }
        case 10:
            printf("  - nowait\n");
            break;
        case 11:
            printf("  - default(%s)\n", 
                   roup_clause_default_data_sharing(clause) == 0 ? "shared" : "none");
            break;
        default:
            printf("  - unknown (kind=%d)\n", kind);
            break;
    }
}

int main(void) {
    const char* test_cases[] = {
        "#pragma omp parallel",
        "#pragma omp parallel for num_threads(4) private(i, j)",
        "#pragma omp parallel for schedule(static, 100) reduction(+:sum)",
        "#pragma omp task default(shared) nowait",
        NULL
    };
    
    for (int i = 0; test_cases[i] != NULL; i++) {
        printf("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
        printf("Input: %s\n", test_cases[i]);
        printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
        
        OmpDirective* dir = roup_parse(test_cases[i]);
        if (!dir) {
            printf("❌ Parse failed!\n");
            continue;
        }
        
        int32_t clause_count = roup_directive_clause_count(dir);
        printf("Clauses: %d\n", clause_count);
        
        if (clause_count &gt; 0) {
            OmpClauseIterator* iter = roup_directive_clauses_iter(dir);
            if (iter) {
                OmpClause* clause;
                while (roup_clause_iterator_next(iter, &amp;clause)) {
                    print_clause_details(clause);
                }
                roup_clause_iterator_free(iter);
            }
        }
        
        roup_directive_free(dir);
    }
    
    printf("\n✅ All tests completed!\n\n");
    return 0;
}
</code></pre>
<hr />
<h2 id="clause-kind-reference"><a class="header" href="#clause-kind-reference">Clause Kind Reference</a></h2>
<p>The C API supports 12 common clause types:</p>
<div class="table-wrapper"><table><thead><tr><th>Kind</th><th>Clause</th><th>Has Variables</th><th>Has Specific Data</th></tr></thead><tbody>
<tr><td>0</td><td><code>num_threads</code></td><td>No</td><td>Value (int)</td></tr>
<tr><td>1</td><td><code>if</code></td><td>No</td><td>Condition (string)</td></tr>
<tr><td>2</td><td><code>private</code></td><td>Yes</td><td>Variable list</td></tr>
<tr><td>3</td><td><code>shared</code></td><td>Yes</td><td>Variable list</td></tr>
<tr><td>4</td><td><code>firstprivate</code></td><td>Yes</td><td>Variable list</td></tr>
<tr><td>5</td><td><code>lastprivate</code></td><td>Yes</td><td>Variable list</td></tr>
<tr><td>6</td><td><code>reduction</code></td><td>Yes</td><td>Operator + variables</td></tr>
<tr><td>7</td><td><code>schedule</code></td><td>No</td><td>Schedule kind + chunk</td></tr>
<tr><td>8</td><td><code>collapse</code></td><td>No</td><td>Depth (int)</td></tr>
<tr><td>9</td><td><code>ordered</code></td><td>No</td><td>-</td></tr>
<tr><td>10</td><td><code>nowait</code></td><td>No</td><td>-</td></tr>
<tr><td>11</td><td><code>default</code></td><td>No</td><td>Sharing kind</td></tr>
<tr><td>999</td><td>Unknown</td><td>-</td><td>-</td></tr>
</tbody></table>
</div>
<p><strong>Schedule Kinds</strong> (for clause kind 7):</p>
<ul>
<li>0 = <code>static</code></li>
<li>1 = <code>dynamic</code></li>
<li>2 = <code>guided</code></li>
<li>3 = <code>auto</code></li>
<li>4 = <code>runtime</code></li>
</ul>
<p><strong>Reduction Operators</strong> (for clause kind 6):</p>
<ul>
<li>0 = <code>+</code>, 1 = <code>-</code>, 2 = <code>*</code></li>
<li>3 = <code>&amp;</code>, 4 = <code>|</code>, 5 = <code>^</code></li>
<li>6 = <code>&amp;&amp;</code>, 7 = <code>||</code></li>
<li>8 = <code>min</code>, 9 = <code>max</code></li>
</ul>
<p><strong>Default Kinds</strong> (for clause kind 11):</p>
<ul>
<li>0 = <code>shared</code></li>
<li>1 = <code>none</code></li>
<li>2 = <code>private</code></li>
<li>3 = <code>firstprivate</code></li>
</ul>
<hr />
<h2 id="memory-management-checklist"><a class="header" href="#memory-management-checklist">Memory Management Checklist</a></h2>
<p>✅ <strong>DO:</strong></p>
<ul>
<li>Call <code>roup_directive_free()</code> for every successful <code>roup_parse()</code></li>
<li>Call <code>roup_clause_iterator_free()</code> for every <code>roup_directive_clauses_iter()</code></li>
<li>Call <code>roup_string_list_free()</code> for every <code>roup_clause_variables()</code></li>
<li>Check for <code>NULL</code> returns before using pointers</li>
</ul>
<p>❌ <strong>DON'T:</strong></p>
<ul>
<li>Call <code>roup_clause_free()</code> on clauses from iterators (owned by directive)</li>
<li>Access freed pointers (use-after-free)</li>
<li>Forget to free in error paths</li>
<li>Assume parse always succeeds</li>
</ul>
<hr />
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li><strong>Reuse parsed directives</strong> - Don't reparse the same string repeatedly</li>
<li><strong>Minimize FFI crossings</strong> - Batch operations when possible</li>
<li><strong>Avoid unnecessary iteration</strong> - If you only need clause count, don't iterate</li>
<li><strong>Use local variables</strong> - Cache query results instead of calling repeatedly</li>
</ol>
<p><strong>Example (inefficient):</strong></p>
<pre><code class="language-c ignore">// BAD: Queries kind multiple times
for (int i = 0; i &lt; count; i++) {
    if (roup_clause_kind(clause) == 2) {
        process_private(roup_clause_kind(clause));
    }
}
</code></pre>
<p><strong>Example (efficient):</strong></p>
<pre><code class="language-c ignore">// GOOD: Cache the kind
int32_t kind = roup_clause_kind(clause);
if (kind == 2) {
    process_private(kind);
}
</code></pre>
<hr />
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Now that you understand the C API basics:</p>
<ol>
<li><strong>Build the example</strong> - Compile and run <code>examples/c/tutorial_basic.c</code></li>
<li><strong>Explore directives</strong> - See <a href="./openmp-support.html">OpenMP Support</a> for all 120+ directives</li>
<li><strong>Advanced usage</strong> - Check <a href="./api-reference.html">API Reference</a> for complete function details</li>
<li><strong>C++ wrappers</strong> - Read <a href="./cpp-tutorial.html">C++ Tutorial</a> for RAII wrappers</li>
</ol>
<p><strong>Full Example Code</strong>: <code>examples/c/tutorial_basic.c</code> (433 lines with detailed comments)</p>
<hr />
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="linker-errors"><a class="header" href="#linker-errors">Linker Errors</a></h3>
<p><strong>Problem</strong>: <code>undefined reference to roup_parse</code></p>
<p><strong>Solution</strong>: Link against the ROUP static library:</p>
<pre><code class="language-bash">gcc ... -L target/release -lroup -lpthread -ldl -lm
</code></pre>
<h3 id="parse-always-returns-null"><a class="header" href="#parse-always-returns-null">Parse Always Returns NULL</a></h3>
<p><strong>Problem</strong>: All parses fail, even valid input</p>
<p><strong>Solution</strong>:</p>
<ul>
<li>Check that the library was built correctly (<code>cargo build --release</code>)</li>
<li>Verify the input string is valid OpenMP syntax</li>
<li>Ensure the string is null-terminated</li>
<li>Try the examples first to verify the library works</li>
</ul>
<h3 id="memory-leaks"><a class="header" href="#memory-leaks">Memory Leaks</a></h3>
<p><strong>Problem</strong>: Valgrind reports memory leaks</p>
<p><strong>Solution</strong>:</p>
<ul>
<li>Ensure every <code>roup_parse()</code> has a matching <code>roup_directive_free()</code></li>
<li>Ensure every <code>roup_directive_clauses_iter()</code> has a matching <code>roup_clause_iterator_free()</code></li>
<li>Ensure every <code>roup_clause_variables()</code> has a matching <code>roup_string_list_free()</code></li>
</ul>
<h3 id="segmentation-fault"><a class="header" href="#segmentation-fault">Segmentation Fault</a></h3>
<p><strong>Problem</strong>: Program crashes with segfault</p>
<p><strong>Solution</strong>:</p>
<ul>
<li>Check for <code>NULL</code> before dereferencing pointers</li>
<li>Don't access freed pointers</li>
<li>Don't call <code>roup_clause_free()</code> on clauses from iterators</li>
</ul>
<hr />
<p><strong>Questions?</strong> Check the <a href="./faq.html">FAQ</a> or open an issue on <a href="https://github.com/ouankou/roup/issues">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-tutorial-building-a-real-application"><a class="header" href="#c-tutorial-building-a-real-application">C++ Tutorial: Building a Real Application</a></h1>
<p>This tutorial shows how to integrate ROUP into a <strong>real C++ application</strong> using modern C++17 features.</p>
<p>We'll build an <strong>OpenMP pragma analyzer</strong> - a tool that reads C/C++ source files, extracts OpenMP directives, and reports statistics.</p>
<hr />
<h2 id="what-youll-build"><a class="header" href="#what-youll-build">What You'll Build</a></h2>
<p>A command-line tool that:</p>
<ol>
<li>Reads source files line-by-line</li>
<li>Detects OpenMP pragmas</li>
<li>Parses them using ROUP</li>
<li>Reports directive types and clause counts</li>
<li>Provides summary statistics</li>
</ol>
<p><strong>Example output:</strong></p>
<pre><code class="language-text">$ ./omp_analyzer mycode.c
Found 5 OpenMP directives:
  Line 10: parallel (3 clauses)
  Line 25: for (2 clauses)
  Line 42: parallel for (4 clauses)
  Line 68: task (1 clause)
  Line 95: barrier (0 clauses)

Summary:
  Total directives: 5
  Total clauses: 10
  Most common: parallel (2 occurrences)
</code></pre>
<hr />
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<ul>
<li><strong>C++ Compiler:</strong> clang++ or g++ with C++17 support</li>
<li><strong>ROUP Library:</strong> Built and installed (see below)</li>
<li><strong>System:</strong> Linux, macOS, or Windows with WSL</li>
</ul>
<h3 id="building-roup"><a class="header" href="#building-roup">Building ROUP</a></h3>
<pre><code class="language-bash">git clone https://github.com/ouankou/roup.git
cd roup
cargo build --release

# Library is now at: target/release/libroup.so (Linux)
#                or: target/release/libroup.dylib (macOS)
</code></pre>
<hr />
<h2 id="step-1-understanding-the-roup-c-api"><a class="header" href="#step-1-understanding-the-roup-c-api">Step 1: Understanding the ROUP C API</a></h2>
<p>ROUP exports a minimal C API with 16 functions. Here are the key ones for our tool:</p>
<h3 id="lifecycle-functions"><a class="header" href="#lifecycle-functions">Lifecycle Functions</a></h3>
<pre><code class="language-c">// Parse an OpenMP directive string
OmpDirective* roup_parse(const char* input);

// Free the parsed directive
void roup_directive_free(OmpDirective* directive);
</code></pre>
<h3 id="query-functions"><a class="header" href="#query-functions">Query Functions</a></h3>
<pre><code class="language-c">// Get directive type (0=parallel, 1=for, 4=task, etc.)
int32_t roup_directive_kind(const OmpDirective* directive);

// Get number of clauses
int32_t roup_directive_clause_count(const OmpDirective* directive);

// Create iterator for clauses
OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);

// Get next clause (returns 1 if available, 0 if done)
int32_t roup_clause_iterator_next(OmpClauseIterator* iter, OmpClause** out);

// Get clause type (0=num_threads, 2=private, 6=reduction, etc.)
int32_t roup_clause_kind(const OmpClause* clause);

// Free iterator
void roup_clause_iterator_free(OmpClauseIterator* iter);
</code></pre>
<hr />
<h2 id="step-2-create-raii-wrappers-modern-c"><a class="header" href="#step-2-create-raii-wrappers-modern-c">Step 2: Create RAII Wrappers (Modern C++)</a></h2>
<p>Instead of manual memory management, let's use <strong>RAII</strong> (Resource Acquisition Is Initialization) to automatically clean up resources.</p>
<p>Create <code>roup_wrapper.hpp</code>:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cstdint&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;optional&gt;

// Forward declarations of opaque C types
struct OmpDirective;
struct OmpClause;
struct OmpClauseIterator;

// C API declarations
extern "C" {
    OmpDirective* roup_parse(const char* input);
    void roup_directive_free(OmpDirective* directive);
    int32_t roup_directive_kind(const OmpDirective* directive);
    int32_t roup_directive_clause_count(const OmpDirective* directive);
    OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);
    int32_t roup_clause_iterator_next(OmpClauseIterator* iter, OmpClause** out);
    void roup_clause_iterator_free(OmpClauseIterator* iter);
    int32_t roup_clause_kind(const OmpClause* clause);
}

namespace roup {

// RAII wrapper for OmpDirective
class Directive {
private:
    OmpDirective* ptr_;

public:
    // Constructor: parse directive
    explicit Directive(const std::string&amp; input) 
        : ptr_(roup_parse(input.c_str())) {}
    
    // Destructor: automatic cleanup
    ~Directive() {
        if (ptr_) {
            roup_directive_free(ptr_);
        }
    }
    
    // Delete copy (move-only type)
    Directive(const Directive&amp;) = delete;
    Directive&amp; operator=(const Directive&amp;) = delete;
    
    // Move constructor
    Directive(Directive&amp;&amp; other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }
    
    // Move assignment
    Directive&amp; operator=(Directive&amp;&amp; other) noexcept {
        if (this != &amp;other) {
            if (ptr_) roup_directive_free(ptr_);
            ptr_ = other.ptr_;
            other.ptr_ = nullptr;
        }
        return *this;
    }
    
    // Check if parse succeeded
    bool valid() const { return ptr_ != nullptr; }
    explicit operator bool() const { return valid(); }
    
    // Get directive kind
    int32_t kind() const {
        return ptr_ ? roup_directive_kind(ptr_) : -1;
    }
    
    // Get clause count
    int32_t clause_count() const {
        return ptr_ ? roup_directive_clause_count(ptr_) : 0;
    }
    
    // Get raw pointer (for advanced usage)
    OmpDirective* get() const { return ptr_; }
};

// RAII wrapper for OmpClauseIterator
class ClauseIterator {
private:
    OmpClauseIterator* iter_;
    
public:
    explicit ClauseIterator(const Directive&amp; directive)
        : iter_(directive.valid() ? roup_directive_clauses_iter(directive.get()) : nullptr) {}
    
    ~ClauseIterator() {
        if (iter_) {
            roup_clause_iterator_free(iter_);
        }
    }
    
    // Delete copy
    ClauseIterator(const ClauseIterator&amp;) = delete;
    ClauseIterator&amp; operator=(const ClauseIterator&amp;) = delete;
    
    // Get next clause kind (returns std::optional)
    std::optional&lt;int32_t&gt; next() {
        if (!iter_) return std::nullopt;
        
        OmpClause* clause = nullptr;
        if (roup_clause_iterator_next(iter_, &amp;clause) == 1) {
            return roup_clause_kind(clause);
            // Note: Don't free clause - owned by directive
        }
        return std::nullopt;
    }
};

// Helper: Convert directive kind to name
inline const char* directive_kind_name(int32_t kind) {
    switch (kind) {
        case 0: return "parallel";
        case 1: return "for";
        case 2: return "sections";
        case 3: return "single";
        case 4: return "task";
        case 5: return "master";
        case 6: return "critical";
        case 7: return "barrier";
        case 8: return "taskwait";
        case 9: return "taskgroup";
        case 10: return "atomic";
        case 11: return "flush";
        case 12: return "ordered";
        case 13: return "target";
        case 14: return "teams";
        case 15: return "distribute";
        case 16: return "metadirective";
        default: return "unknown";
    }
}

// Helper: Convert clause kind to name
inline const char* clause_kind_name(int32_t kind) {
    switch (kind) {
        case 0: return "num_threads";
        case 1: return "if";
        case 2: return "private";
        case 3: return "shared";
        case 4: return "firstprivate";
        case 5: return "lastprivate";
        case 6: return "reduction";
        case 7: return "schedule";
        case 8: return "collapse";
        case 9: return "ordered";
        case 10: return "nowait";
        case 11: return "default";
        default: return "unknown";
    }
}

} // namespace roup
</code></pre>
<p><strong>Key RAII benefits:</strong></p>
<ul>
<li>✅ <strong>Automatic cleanup</strong> - No need to call <code>_free()</code> functions</li>
<li>✅ <strong>Exception safe</strong> - Resources freed even if exceptions thrown</li>
<li>✅ <strong>Move semantics</strong> - Efficient transfer of ownership</li>
<li>✅ <strong>Modern C++</strong> - Uses <code>std::optional</code>, deleted copy constructors</li>
</ul>
<hr />
<h2 id="step-3-build-the-analyzer-tool"><a class="header" href="#step-3-build-the-analyzer-tool">Step 3: Build the Analyzer Tool</a></h2>
<p>Create <code>omp_analyzer.cpp</code>:</p>
<pre><code class="language-cpp">#include "roup_wrapper.hpp"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct DirectiveInfo {
    int line_number;
    std::string directive_name;
    int clause_count;
    std::vector&lt;std::string&gt; clause_names;
};

class OMPAnalyzer {
private:
    std::vector&lt;DirectiveInfo&gt; directives_;
    std::map&lt;std::string, int&gt; directive_counts_;
    
public:
    // Analyze a single line for OpenMP pragmas
    void analyze_line(const std::string&amp; line, int line_number) {
        // Check if line contains OpenMP pragma
        if (line.find("#pragma omp") == std::string::npos) {
            return;
        }
        
        // Parse the directive
        roup::Directive directive(line);
        if (!directive) {
            std::cerr &lt;&lt; "Warning: Failed to parse line " &lt;&lt; line_number 
                      &lt;&lt; ": " &lt;&lt; line &lt;&lt; std::endl;
            return;
        }
        
        // Extract directive info
        DirectiveInfo info;
        info.line_number = line_number;
        info.directive_name = roup::directive_kind_name(directive.kind());
        info.clause_count = directive.clause_count();
        
        // Extract clause names
        roup::ClauseIterator iter(directive);
        while (auto clause_kind = iter.next()) {
            info.clause_names.push_back(roup::clause_kind_name(*clause_kind));
        }
        
        directives_.push_back(info);
        directive_counts_[info.directive_name]++;
    }
    
    // Analyze entire file
    bool analyze_file(const std::string&amp; filename) {
        std::ifstream file(filename);
        if (!file) {
            std::cerr &lt;&lt; "Error: Cannot open file: " &lt;&lt; filename &lt;&lt; std::endl;
            return false;
        }
        
        std::string line;
        int line_number = 0;
        
        while (std::getline(file, line)) {
            line_number++;
            analyze_line(line, line_number);
        }
        
        return true;
    }
    
    // Print detailed report
    void print_report() const {
        if (directives_.empty()) {
            std::cout &lt;&lt; "No OpenMP directives found." &lt;&lt; std::endl;
            return;
        }
        
        std::cout &lt;&lt; "\nFound " &lt;&lt; directives_.size() 
                  &lt;&lt; " OpenMP directive(s):\n" &lt;&lt; std::endl;
        
        for (const auto&amp; info : directives_) {
            std::cout &lt;&lt; "  Line " &lt;&lt; info.line_number &lt;&lt; ": "
                      &lt;&lt; info.directive_name &lt;&lt; " ("
                      &lt;&lt; info.clause_count &lt;&lt; " clause"
                      &lt;&lt; (info.clause_count != 1 ? "s" : "") &lt;&lt; ")";
            
            if (!info.clause_names.empty()) {
                std::cout &lt;&lt; " [";
                for (size_t i = 0; i &lt; info.clause_names.size(); ++i) {
                    if (i &gt; 0) std::cout &lt;&lt; ", ";
                    std::cout &lt;&lt; info.clause_names[i];
                }
                std::cout &lt;&lt; "]";
            }
            std::cout &lt;&lt; std::endl;
        }
        
        print_summary();
    }
    
    // Print summary statistics
    void print_summary() const {
        int total_clauses = 0;
        for (const auto&amp; info : directives_) {
            total_clauses += info.clause_count;
        }
        
        std::cout &lt;&lt; "\nSummary:" &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Total directives: " &lt;&lt; directives_.size() &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Total clauses: " &lt;&lt; total_clauses &lt;&lt; std::endl;
        
        // Find most common directive
        auto max_elem = std::max_element(
            directive_counts_.begin(), 
            directive_counts_.end(),
            [](const auto&amp; a, const auto&amp; b) { return a.second &lt; b.second; }
        );
        
        if (max_elem != directive_counts_.end()) {
            std::cout &lt;&lt; "  Most common: " &lt;&lt; max_elem-&gt;first 
                      &lt;&lt; " (" &lt;&lt; max_elem-&gt;second &lt;&lt; " occurrence"
                      &lt;&lt; (max_elem-&gt;second != 1 ? "s" : "") &lt;&lt; ")" &lt;&lt; std::endl;
        }
        
        // Print directive type breakdown
        if (directive_counts_.size() &gt; 1) {
            std::cout &lt;&lt; "\nDirective breakdown:" &lt;&lt; std::endl;
            for (const auto&amp; [name, count] : directive_counts_) {
                std::cout &lt;&lt; "  " &lt;&lt; name &lt;&lt; ": " &lt;&lt; count &lt;&lt; std::endl;
            }
        }
    }
};

int main(int argc, char* argv[]) {
    if (argc &lt; 2) {
        std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " &lt;source-file&gt;" &lt;&lt; std::endl;
        std::cerr &lt;&lt; "Example: " &lt;&lt; argv[0] &lt;&lt; " mycode.c" &lt;&lt; std::endl;
        return 1;
    }
    
    OMPAnalyzer analyzer;
    
    if (!analyzer.analyze_file(argv[1])) {
        return 1;
    }
    
    analyzer.print_report();
    return 0;
}
```text

---

## Step 4: Build and Run

### Compilation

```bash
# Build ROUP library first
cd roup
cargo build --release

# Build the analyzer
clang++ -std=c++17 omp_analyzer.cpp \
    -L./target/release -lroup \
    -Wl,-rpath,./target/release \
    -o omp_analyzer

# Or with g++:
g++ -std=c++17 omp_analyzer.cpp \
    -L./target/release -lroup \
    -Wl,-rpath,./target/release \
    -o omp_analyzer
</code></pre>
<h3 id="test-with-sample-file"><a class="header" href="#test-with-sample-file">Test with Sample File</a></h3>
<p>Create <code>test.c</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int n = 1000;
    int sum = 0;
    
    #pragma omp parallel for reduction(+:sum) num_threads(4)
    for (int i = 0; i &lt; n; i++) {
        sum += i;
    }
    
    #pragma omp parallel
    {
        #pragma omp single
        {
            printf("Hello from thread\\n");
        }
    }
    
    #pragma omp task depend(in: sum)
    printf("Sum: %d\\n", sum);
    
    #pragma omp barrier
    
    return 0;
}
</code></pre>
<h3 id="run-the-analyzer"><a class="header" href="#run-the-analyzer">Run the Analyzer</a></h3>
<pre><code class="language-bash">$ ./omp_analyzer test.c

Found 5 OpenMP directive(s):

  Line 7: for (3 clauses) [reduction, num_threads]
  Line 11: parallel (0 clauses)
  Line 13: single (0 clauses)
  Line 19: task (1 clause) [depend]
  Line 22: barrier (0 clauses)

Summary:
  Total directives: 5
  Total clauses: 4
  Most common: parallel (1 occurrence)

Directive breakdown:
  barrier: 1
  for: 1
  parallel: 1
  single: 1
  task: 1
</code></pre>
<hr />
<h2 id="step-5-advanced-features"><a class="header" href="#step-5-advanced-features">Step 5: Advanced Features</a></h2>
<h3 id="51-extract-variable-names-from-clauses"><a class="header" href="#51-extract-variable-names-from-clauses">5.1 Extract Variable Names from Clauses</a></h3>
<p>Some clauses (like <code>private</code>, <code>shared</code>) contain variable lists. To access them:</p>
<pre><code class="language-cpp">// In C API (add to roup_wrapper.hpp):
extern "C" {
    OmpStringList* roup_clause_variables(const OmpClause* clause);
    int32_t roup_string_list_len(const OmpStringList* list);
    const char* roup_string_list_get(const OmpStringList* list, int32_t index);
    void roup_string_list_free(OmpStringList* list);
}

// RAII wrapper for string list
class StringList {
private:
    OmpStringList* list_;
    
public:
    explicit StringList(OmpStringList* list) : list_(list) {}
    
    ~StringList() {
        if (list_) roup_string_list_free(list_);
    }
    
    int32_t size() const {
        return list_ ? roup_string_list_len(list_) : 0;
    }
    
    std::string get(int32_t index) const {
        if (!list_ || index &gt;= size()) return "";
        return roup_string_list_get(list_, index);
    }
    
    std::vector&lt;std::string&gt; to_vector() const {
        std::vector&lt;std::string&gt; result;
        for (int32_t i = 0; i &lt; size(); ++i) {
            result.push_back(get(i));
        }
        return result;
    }
};
```text

### 5.2 Handle Parse Errors Gracefully

```cpp
std::optional&lt;DirectiveInfo&gt; parse_directive(const std::string&amp; line) {
    roup::Directive directive(line);
    if (!directive) {
        return std::nullopt;  // Parse failed
    }
    
    DirectiveInfo info;
    info.directive_name = roup::directive_kind_name(directive.kind());
    info.clause_count = directive.clause_count();
    
    return info;
}
</code></pre>
<h3 id="53-process-multiple-files"><a class="header" href="#53-process-multiple-files">5.3 Process Multiple Files</a></h3>
<pre><code class="language-cpp">void analyze_project(const std::vector&lt;std::string&gt;&amp; files) {
    OMPAnalyzer combined;
    
    for (const auto&amp; file : files) {
        OMPAnalyzer file_analyzer;
        if (file_analyzer.analyze_file(file)) {
            std::cout &lt;&lt; "\n=== " &lt;&lt; file &lt;&lt; " ===" &lt;&lt; std::endl;
            file_analyzer.print_report();
        }
    }
}
</code></pre>
<hr />
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="1-openmp-linter"><a class="header" href="#1-openmp-linter">1. <strong>OpenMP Linter</strong></a></h3>
<p>Check for common mistakes:</p>
<ul>
<li><code>parallel for</code> without <code>private</code> on loop variable</li>
<li><code>reduction</code> with unsupported operators</li>
<li>Missing <code>nowait</code> opportunities</li>
</ul>
<h3 id="2-code-modernization-tool"><a class="header" href="#2-code-modernization-tool">2. <strong>Code Modernization Tool</strong></a></h3>
<ul>
<li>Convert OpenMP 3.x → 5.x syntax</li>
<li>Suggest modern alternatives (e.g., <code>taskloop</code> instead of manual tasks)</li>
</ul>
<h3 id="3-performance-analyzer"><a class="header" href="#3-performance-analyzer">3. <strong>Performance Analyzer</strong></a></h3>
<ul>
<li>Count parallelization opportunities</li>
<li>Identify nested parallel regions (potential over-subscription)</li>
<li>Find synchronization hotspots</li>
</ul>
<h3 id="4-ide-integration"><a class="header" href="#4-ide-integration">4. <strong>IDE Integration</strong></a></h3>
<ul>
<li>Syntax highlighting for OpenMP pragmas</li>
<li>Auto-completion for clause names</li>
<li>Quick documentation lookup</li>
</ul>
<hr />
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>ROUP is <strong>fast</strong>:</p>
<ul>
<li>Parsing a typical directive: <strong>~1-5 microseconds</strong></li>
<li>Zero-copy design: Uses string slices, not allocations</li>
<li>Suitable for <strong>real-time IDE integration</strong></li>
</ul>
<p><strong>Benchmark</strong> (on typical code):</p>
<pre><code class="language-text">File size: 10,000 lines
OpenMP directives: 500
Total parse time: ~2.5 milliseconds
Throughput: ~200,000 directives/second
</code></pre>
<hr />
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="issue-undefined-reference-to-roup_parse"><a class="header" href="#issue-undefined-reference-to-roup_parse">Issue: <code>undefined reference to roup_parse</code></a></h3>
<p><strong>Solution:</strong> Make sure library path is correct:</p>
<pre><code class="language-bash">clang++ ... -L./target/release -lroup -Wl,-rpath,./target/release
</code></pre>
<h3 id="issue-error-while-loading-shared-libraries-libroupso"><a class="header" href="#issue-error-while-loading-shared-libraries-libroupso">Issue: <code>error while loading shared libraries: libroup.so</code></a></h3>
<p><strong>Solution:</strong> Set <code>LD_LIBRARY_PATH</code> (Linux) or <code>DYLD_LIBRARY_PATH</code> (macOS):</p>
<pre><code class="language-bash">export LD_LIBRARY_PATH=./target/release:$LD_LIBRARY_PATH
</code></pre>
<h3 id="issue-parse-failures-on-valid-pragmas"><a class="header" href="#issue-parse-failures-on-valid-pragmas">Issue: Parse failures on valid pragmas</a></h3>
<p><strong>Cause:</strong> ROUP currently supports C/C++ syntax (<code>#pragma omp</code>), not Fortran (<code>!$omp</code>).</p>
<p><strong>Solution:</strong> Ensure input starts with <code>#pragma omp</code>.</p>
<hr />
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><strong>Explore the Rust API</strong> - See <a href="./api-reference.html">API Reference</a></li>
<li><strong>Check out more examples</strong> - <a href="https://github.com/ouankou/roup/tree/main/examples">GitHub repository</a></li>
<li><strong>Contribute</strong> - Report issues or submit PRs!</li>
</ul>
<hr />
<h2 id="complete-example-code"><a class="header" href="#complete-example-code">Complete Example Code</a></h2>
<p>All code from this tutorial is available at:</p>
<ul>
<li><code>examples/cpp/roup_wrapper.hpp</code> - RAII wrappers</li>
<li><code>examples/cpp/omp_analyzer.cpp</code> - Full analyzer tool</li>
</ul>
<p><strong>Clone and try:</strong></p>
<pre><code class="language-bash">git clone https://github.com/ouankou/roup.git
cd roup/examples/cpp
make  # Builds all examples
./omp_analyzer ../../tests/data/sample.c
</code></pre>
<p>Happy parsing! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortran-tutorial"><a class="header" href="#fortran-tutorial">Fortran Tutorial</a></h1>
<p>This tutorial demonstrates how to use ROUP to parse OpenMP directives in Fortran code.</p>
<h2 id="-experimental-status"><a class="header" href="#-experimental-status">🚧 Experimental Status</a></h2>
<p><strong>Fortran support in ROUP is currently experimental.</strong> Features may change as development progresses.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>ROUP supports parsing OpenMP directives from Fortran source code in both free-form and fixed-form formats. This enables Fortran developers to:</p>
<ul>
<li>Parse OpenMP directives from Fortran source</li>
<li>Validate directive syntax</li>
<li>Extract clause information</li>
<li>Build tools for Fortran+OpenMP code analysis</li>
</ul>
<h2 id="fortran-directive-formats"><a class="header" href="#fortran-directive-formats">Fortran Directive Formats</a></h2>
<h3 id="free-form-modern-fortran"><a class="header" href="#free-form-modern-fortran">Free-Form (Modern Fortran)</a></h3>
<p>Free-form Fortran uses the <code>!$OMP</code> sentinel (case-insensitive):</p>
<pre><code class="language-fortran">!$OMP PARALLEL PRIVATE(A, B) NUM_THREADS(4)
!$OMP END PARALLEL

!$omp parallel do private(i) reduction(+:sum)
!$OMP END PARALLEL DO
</code></pre>
<h3 id="fixed-form-fortran-77"><a class="header" href="#fixed-form-fortran-77">Fixed-Form (Fortran 77)</a></h3>
<p>Fixed-form Fortran uses <code>!$OMP</code> or <code>C$OMP</code> sentinels in columns 1-6:</p>
<pre><code class="language-fortran">C$OMP PARALLEL PRIVATE(X, Y)
!$OMP DO SCHEDULE(STATIC, 10)
C$OMP END DO
C$OMP END PARALLEL
</code></pre>
<h2 id="fortran-specific-directives"><a class="header" href="#fortran-specific-directives">Fortran-Specific Directives</a></h2>
<p>ROUP supports Fortran-specific directive syntax, including the Fortran <code>DO</code> construct which is equivalent to C/C++ <code>FOR</code>:</p>
<h3 id="do-directive-fortran"><a class="header" href="#do-directive-fortran">DO Directive (Fortran)</a></h3>
<pre><code class="language-fortran">!$OMP DO PRIVATE(I) SCHEDULE(STATIC)
    do i = 1, n
        ! Loop body
    end do
!$OMP END DO
</code></pre>
<h3 id="parallel-do-fortran"><a class="header" href="#parallel-do-fortran">PARALLEL DO (Fortran)</a></h3>
<pre><code class="language-fortran">!$OMP PARALLEL DO PRIVATE(I) REDUCTION(+:SUM)
    do i = 1, n
        sum = sum + a(i)
    end do
!$OMP END PARALLEL DO
</code></pre>
<p><strong>Note</strong>: ROUP recognizes both Fortran syntax (<code>DO</code>) and C syntax (<code>FOR</code>) for compatibility:</p>
<ul>
<li><code>!$OMP DO</code> → Fortran-specific (preferred for Fortran code)</li>
<li><code>!$OMP FOR</code> → C/C++ syntax (also works in Fortran mode)</li>
<li><code>!$OMP PARALLEL DO</code> → Fortran-specific</li>
<li><code>!$OMP PARALLEL FOR</code> → C/C++ syntax (also works in Fortran mode)</li>
</ul>
<h2 id="language-constants"><a class="header" href="#language-constants">Language Constants</a></h2>
<p>ROUP provides language format constants for Fortran parsing:</p>
<pre><code class="language-c">#define ROUP_LANG_C                0  // C/C++ (#pragma omp)
#define ROUP_LANG_FORTRAN_FREE     1  // Fortran free-form (!$OMP)
#define ROUP_LANG_FORTRAN_FIXED    2  // Fortran fixed-form (!$OMP or C$OMP)
</code></pre>
<h2 id="using-the-rust-api"><a class="header" href="#using-the-rust-api">Using the Rust API</a></h2>
<h3 id="parsing-fortran-directives"><a class="header" href="#parsing-fortran-directives">Parsing Fortran Directives</a></h3>
<pre><code class="language-rust ignore">use roup::lexer::Language;
use roup::parser::openmp;

// Create parser with Fortran free-form support
let parser = openmp::parser().with_language(Language::FortranFree);

// Parse a Fortran OpenMP directive
let input = "!$OMP PARALLEL PRIVATE(A, B) NUM_THREADS(4)";
let (rest, directive) = parser.parse(input).expect("parsing should succeed");

println!("Directive: {}", directive.name);
println!("Clauses: {}", directive.clauses.len());</code></pre>
<h3 id="supported-language-formats"><a class="header" href="#supported-language-formats">Supported Language Formats</a></h3>
<pre><code class="language-rust ignore">use roup::lexer::Language;

// C/C++ format (default)
let c_parser = openmp::parser().with_language(Language::C);

// Fortran free-form
let fortran_free = openmp::parser().with_language(Language::FortranFree);

// Fortran fixed-form
let fortran_fixed = openmp::parser().with_language(Language::FortranFixed);</code></pre>
<h2 id="using-the-c-api-from-fortran"><a class="header" href="#using-the-c-api-from-fortran">Using the C API from Fortran</a></h2>
<h3 id="setting-up-fortran-c-interoperability"><a class="header" href="#setting-up-fortran-c-interoperability">Setting Up Fortran-C Interoperability</a></h3>
<p>Create an interface module for ROUP C API:</p>
<pre><code class="language-fortran">module roup_interface
    use iso_c_binding
    implicit none
    
    ! Language constants
    integer(c_int), parameter :: ROUP_LANG_FORTRAN_FREE = 1
    integer(c_int), parameter :: ROUP_LANG_FORTRAN_FIXED = 2
    
    interface
        ! Parse with language specification
        function roup_parse_with_language(input, language) &amp;
            bind(C, name="roup_parse_with_language")
            use iso_c_binding
            type(c_ptr), value :: input
            integer(c_int), value :: language
            type(c_ptr) :: roup_parse_with_language
        end function roup_parse_with_language
        
        ! Free directive
        subroutine roup_directive_free(directive) &amp;
            bind(C, name="roup_directive_free")
            use iso_c_binding
            type(c_ptr), value :: directive
        end subroutine roup_directive_free
        
        ! Get directive name
        function roup_directive_name(directive) &amp;
            bind(C, name="roup_directive_name")
            use iso_c_binding
            type(c_ptr), value :: directive
            type(c_ptr) :: roup_directive_name
        end function roup_directive_name
        
        ! Get clause count
        function roup_directive_clause_count(directive) &amp;
            bind(C, name="roup_directive_clause_count")
            use iso_c_binding
            type(c_ptr), value :: directive
            integer(c_size_t) :: roup_directive_clause_count
        end function roup_directive_clause_count
    end interface
end module roup_interface
</code></pre>
<h3 id="parsing-fortran-directives-from-fortran"><a class="header" href="#parsing-fortran-directives-from-fortran">Parsing Fortran Directives from Fortran</a></h3>
<pre><code class="language-fortran">program parse_example
    use iso_c_binding
    use roup_interface
    implicit none
    
    type(c_ptr) :: directive_ptr, name_ptr
    character(len=100) :: input = "!$OMP PARALLEL PRIVATE(X)"
    character(kind=c_char), dimension(:), allocatable :: c_input
    integer :: i, n
    
    ! Convert Fortran string to C string
    n = len_trim(input)
    allocate(c_input(n+1))
    do i = 1, n
        c_input(i) = input(i:i)
    end do
    c_input(n+1) = c_null_char
    
    ! Parse directive
    directive_ptr = roup_parse_with_language(c_loc(c_input), &amp;
                                              ROUP_LANG_FORTRAN_FREE)
    
    if (c_associated(directive_ptr)) then
        ! Get directive information
        name_ptr = roup_directive_name(directive_ptr)
        ! ... process name_ptr ...
        
        ! Clean up
        call roup_directive_free(directive_ptr)
    else
        print *, "Parse error"
    end if
    
    deallocate(c_input)
end program parse_example
</code></pre>
<h2 id="case-insensitivity"><a class="header" href="#case-insensitivity">Case Insensitivity</a></h2>
<p>Fortran is case-insensitive, and ROUP respects this:</p>
<pre><code class="language-fortran">! All of these are equivalent
!$OMP PARALLEL PRIVATE(X)
!$omp parallel private(x)
!$Omp Parallel Private(X)
</code></pre>
<p>ROUP normalizes Fortran identifiers to lowercase internally while preserving the original case in the parsed output.</p>
<h2 id="common-fortran-openmp-constructs"><a class="header" href="#common-fortran-openmp-constructs">Common Fortran OpenMP Constructs</a></h2>
<h3 id="parallel-regions"><a class="header" href="#parallel-regions">Parallel Regions</a></h3>
<pre><code class="language-fortran">!$OMP PARALLEL PRIVATE(TID) SHARED(N)
    ! Parallel code
!$OMP END PARALLEL
</code></pre>
<h3 id="work-sharing-constructs"><a class="header" href="#work-sharing-constructs">Work-Sharing Constructs</a></h3>
<p>In Fortran, use <code>DO</code> instead of C's <code>for</code>:</p>
<pre><code class="language-fortran">!$OMP DO PRIVATE(I) SCHEDULE(STATIC, 10)
    do i = 1, n
        ! Loop body
    end do
!$OMP END DO
</code></pre>
<p>Or combined:</p>
<pre><code class="language-fortran">!$OMP PARALLEL DO PRIVATE(I,J) REDUCTION(+:SUM)
    do i = 1, n
        sum = sum + array(i)
    end do
!$OMP END PARALLEL DO
</code></pre>
<h3 id="array-sections"><a class="header" href="#array-sections">Array Sections</a></h3>
<p>Fortran array sections use different syntax than C:</p>
<pre><code class="language-fortran">!$OMP PARALLEL PRIVATE(A(1:N), B(:,1:M))
    ! Work with array sections
!$OMP END PARALLEL
</code></pre>
<h3 id="common-blocks"><a class="header" href="#common-blocks">Common Blocks</a></h3>
<p>Fortran's <code>THREADPRIVATE</code> can apply to common blocks:</p>
<pre><code class="language-fortran">      COMMON /MYDATA/ X, Y, Z
!$OMP THREADPRIVATE(/MYDATA/)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>See the <a href="../../examples/fortran/"><code>examples/fortran/</code></a> directory for complete working examples:</p>
<ul>
<li><strong>basic_parse.f90</strong>: Simple Fortran directive examples</li>
<li><strong>tutorial_basic.f90</strong>: Full C API integration tutorial</li>
</ul>
<h2 id="building-fortran-programs-with-roup"><a class="header" href="#building-fortran-programs-with-roup">Building Fortran Programs with ROUP</a></h2>
<h3 id="using-gfortran"><a class="header" href="#using-gfortran">Using gfortran</a></h3>
<pre><code class="language-bash"># Compile Fortran code
gfortran -c my_program.f90

# Link with ROUP library
gcc my_program.o -L/path/to/roup/target/release -lroup -o my_program

# Run (set LD_LIBRARY_PATH)
LD_LIBRARY_PATH=/path/to/roup/target/release ./my_program
</code></pre>
<h3 id="makefile-example"><a class="header" href="#makefile-example">Makefile Example</a></h3>
<pre><code class="language-makefile">FC = gfortran
ROUP_LIB = -L../../target/release -lroup -Wl,-rpath,../../target/release

my_program: my_program.f90
	$(FC) -o $@ $&lt; $(ROUP_LIB)
</code></pre>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<p>⚠️ <strong>Current limitations in experimental Fortran support:</strong></p>
<ol>
<li>
<p><strong>Continuation Syntax Requirements</strong>: Multi-line directives must use standard continuation markers</p>
<ul>
<li><strong>Fortran</strong>: Terminate continued lines with <code>&amp;</code> and optionally repeat the sentinel on the next line</li>
<li><strong>C/C++</strong>: Place a trailing <code>\</code> at the end of each continued line</li>
<li>See <a href="./line-continuations.html">Line Continuations</a> for canonical examples across languages</li>
</ul>
</li>
<li>
<p><strong>End Directives</strong>: <code>!$OMP END PARALLEL</code> and similar end directives may not parse correctly</p>
</li>
<li>
<p><strong>Array Sections</strong>: Complex array section syntax may have issues</p>
</li>
<li>
<p><strong>Fixed-Form Column Rules</strong>: Strict column 1-6 sentinel placement not enforced</p>
</li>
<li>
<p><strong>Fortran-Specific Directives</strong>: Some Fortran-only directives (e.g., <code>WORKSHARE</code>) may not be registered</p>
</li>
</ol>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="parse-errors"><a class="header" href="#parse-errors">Parse Errors</a></h3>
<p>If parsing fails:</p>
<ol>
<li><strong>Check sentinel format</strong>: Use <code>!$OMP</code> for free-form or <code>!$OMP</code>/<code>C$OMP</code> for fixed-form</li>
<li><strong>Verify case</strong>: While case-insensitive, ensure proper formatting</li>
<li><strong>Check whitespace</strong>: Ensure proper spacing after sentinel</li>
<li><strong>Use correct language mode</strong>: Specify <code>ROUP_LANG_FORTRAN_FREE</code> or <code>ROUP_LANG_FORTRAN_FIXED</code></li>
</ol>
<h3 id="directive-not-found"><a class="header" href="#directive-not-found">Directive Not Found</a></h3>
<p>Some directives may not be in the registry. Check:</p>
<ul>
<li>Is the directive name correct? (Fortran supports both <code>DO</code> and <code>FOR</code> syntax)</li>
<li>Is it a composite directive? (Use <code>PARALLEL DO</code> not <code>PARALLEL</code> + <code>DO</code>)</li>
</ul>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<p>See:</p>
<ul>
<li><a href="./c-tutorial.html">C Tutorial</a> - C API documentation</li>
<li><a href="./api-reference.html">API Reference</a> - Complete API listing</li>
<li><a href="./architecture.html">Architecture</a> - Parser internals</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Fortran support is under active development. Contributions welcome:</p>
<ul>
<li>Test with real Fortran+OpenMP code</li>
<li>Report parsing issues</li>
<li>Add more Fortran-specific test cases</li>
<li>Improve documentation</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://www.openmp.org/specifications/">OpenMP 5.2 Specification</a> - Official OpenMP standard</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gfortran/OpenMP.html">Fortran OpenMP Documentation</a> - GCC Fortran OpenMP guide</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gfortran/Interoperability-with-C.html">ISO C Binding</a> - Fortran-C interop guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ompparser-compatibility-layer"><a class="header" href="#ompparser-compatibility-layer">ompparser Compatibility Layer</a></h1>
<p>⚠️ <strong>Experimental Feature</strong> - This compatibility layer is under active development.</p>
<p>ROUP provides a drop-in compatibility layer for projects using <a href="https://github.com/ouankou/ompparser">ompparser</a>, allowing you to switch to ROUP's expected-to-be faster, safer Rust-based parser without changing your code.</p>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>A compatibility layer that provides:</p>
<ul>
<li><strong>Same API</strong> as ompparser - no code changes needed</li>
<li><strong>Drop-in replacement</strong> via <code>libompparser.so</code></li>
<li><strong>ROUP backend</strong> - expected-to-be faster, safer parsing in Rust</li>
<li><strong>Reuses ompparser methods</strong> - toString(), generateDOT(), etc. (zero duplication)</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="one-command-build"><a class="header" href="#one-command-build">One-Command Build</a></h3>
<pre><code class="language-bash">cd compat/ompparser
./build.sh
</code></pre>
<p>The script will:</p>
<ol>
<li>Check prerequisites (git, cmake, gcc, cargo)</li>
<li>Initialize ompparser submodule</li>
<li>Build ROUP core library</li>
<li>Build <code>libompparser.so</code> (size varies by build configuration)</li>
<li>Run all 46 tests</li>
</ol>
<h3 id="manual-build"><a class="header" href="#manual-build">Manual Build</a></h3>
<pre><code class="language-bash"># 1. Initialize ompparser submodule
git submodule update --init --recursive

# 2. Build ROUP core
cd /path/to/roup
cargo build --release

# 3. Build compatibility layer
cd compat/ompparser
mkdir -p build &amp;&amp; cd build
cmake ..
make

# 4. Run tests
ctest --output-on-failure
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="drop-in-replacement"><a class="header" href="#drop-in-replacement">Drop-in Replacement</a></h3>
<p>Install system-wide and use exactly like original ompparser:</p>
<pre><code class="language-bash"># Install
cd compat/ompparser/build
sudo make install
sudo ldconfig

# Use (unchanged!)
g++ mycompiler.cpp -lompparser -o mycompiler
</code></pre>
<h3 id="code-example"><a class="header" href="#code-example">Code Example</a></h3>
<p>Your existing ompparser code works without changes:</p>
<pre><code class="language-cpp">#include &lt;OpenMPIR.h&gt;
#include &lt;iostream&gt;

int main() {
    // Parse OpenMP directive
    OpenMPDirective* dir = parseOpenMP("omp parallel num_threads(4)", nullptr);
    
    if (dir) {
        // Use ompparser methods (all work!)
        std::cout &lt;&lt; "Kind: " &lt;&lt; dir-&gt;getKind() &lt;&lt; std::endl;
        std::cout &lt;&lt; "String: " &lt;&lt; dir-&gt;toString() &lt;&lt; std::endl;
        
        // Access clauses
        auto* clauses = dir-&gt;getAllClauses();
        std::cout &lt;&lt; "Clauses: " &lt;&lt; clauses-&gt;size() &lt;&lt; std::endl;
        
        delete dir;
    }
    
    return 0;
}
</code></pre>
<h3 id="cmake-integration"><a class="header" href="#cmake-integration">CMake Integration</a></h3>
<p><strong>Option 1: pkg-config</strong></p>
<pre><code class="language-cmake">find_package(PkgConfig REQUIRED)
pkg_check_modules(OMPPARSER REQUIRED ompparser)

target_link_libraries(your_app ${OMPPARSER_LIBRARIES})
target_include_directories(your_app PRIVATE ${OMPPARSER_INCLUDE_DIRS})
</code></pre>
<p><strong>Option 2: Direct linking</strong></p>
<pre><code class="language-cmake">target_link_libraries(your_app
    ${PATH_TO_ROUP}/compat/ompparser/build/libompparser.so
)
</code></pre>
<h2 id="whats-included"><a class="header" href="#whats-included">What's Included</a></h2>
<h3 id="libompparserso"><a class="header" href="#libompparserso">libompparser.so</a></h3>
<p>Single self-contained library with:</p>
<ul>
<li><strong>ROUP parser</strong> (statically embedded) - Rust-based, safe parsing</li>
<li><strong>ompparser methods</strong> - toString, generateDOT, etc.</li>
<li><strong>Compatibility wrapper</strong> - Seamless integration layer</li>
<li><strong>Self-contained</strong> - No libroup.so dependency (system libs via libc)</li>
</ul>
<h3 id="comprehensive-testing"><a class="header" href="#comprehensive-testing">Comprehensive Testing</a></h3>
<p>46 tests covering:</p>
<ul>
<li><strong>Basic directives</strong>: parallel, for, sections, single, task, barrier, taskwait, critical, master</li>
<li><strong>Clauses</strong>: num_threads, private, shared, reduction, schedule, if, nowait, etc.</li>
<li><strong>String generation</strong>: toString(), generatePragmaString()</li>
<li><strong>Error handling</strong>: null input, invalid directives, malformed pragmas</li>
<li><strong>Memory management</strong>: allocations, deletion, reuse</li>
<li><strong>Language modes</strong>: C, C++, Fortran via setLang()</li>
</ul>
<p>Run tests:</p>
<pre><code class="language-bash">cd compat/ompparser/build
ctest --output-on-failure
</code></pre>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code class="language-text">Your Application (OpenMP directives to parse)
    ↓
compat_impl.cpp (~190 lines) - Minimal wrapper
    ↓
ROUP C API (roup_parse, roup_directive_kind, etc.)
    ↓
ROUP Rust Parser (safe parser core)
    ↓
Returns: OpenMPDirective with ompparser methods
</code></pre>
<p><strong>Key Design</strong>:</p>
<ul>
<li>Reuses 90% of ompparser code (no duplication)</li>
<li>Git submodule approach - automatic ompparser upgrades</li>
<li>Minimal unsafe code (~60 lines, 0.9%), all at FFI boundary</li>
</ul>
<h2 id="known-limitations-1"><a class="header" href="#known-limitations-1">Known Limitations</a></h2>
<h3 id="1-combined-directives-"><a class="header" href="#1-combined-directives-">1. Combined Directives ⚠️</a></h3>
<p>Combined directives like <code>parallel for</code> are currently parsed as the first directive only.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-cpp">parseOpenMP("omp parallel for", nullptr)
// Returns: OMPD_parallel (should be OMPD_parallel_for)
</code></pre>
<p><strong>Status</strong>: ROUP core limitation, tracked for future improvement.</p>
<p><strong>Workaround</strong>: Tests document expected behavior with clear warnings.</p>
<h3 id="2-clause-parameters-"><a class="header" href="#2-clause-parameters-">2. Clause Parameters 🔄</a></h3>
<p>Basic clause detection works, but parameter extraction not yet implemented.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-cpp">parseOpenMP("omp parallel num_threads(4)", nullptr)
// Detects: num_threads clause ✅
// Extracts "4": ❌ (TODO)
</code></pre>
<p><strong>Status</strong>: Planned wrapper enhancement using ROUP's clause expression API.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Complete documentation in <code>compat/ompparser/</code>:</p>
<ul>
<li><strong><a href="https://github.com/ouankou/roup/blob/main/compat/ompparser/README.md">README.md</a></strong> - Complete compatibility layer guide with build instructions and examples</li>
</ul>
<p>For detailed ROUP API documentation, see <a href="./api-reference.html">API Reference</a>.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Rust toolchain</strong> (for ROUP core)</li>
<li><strong>CMake 3.10+</strong></li>
<li><strong>C++11 compiler</strong> (gcc/clang)</li>
<li><strong>Git</strong> (for submodule management)</li>
</ul>
<h2 id="cicd"><a class="header" href="#cicd">CI/CD</a></h2>
<p>The compatibility layer is tested automatically via GitHub Actions (<code>.github/workflows/build.yml</code>):</p>
<pre><code class="language-yaml">- Tests ROUP core (always)
- Tests compat layer (if submodule initialized)
- Verifies library builds successfully
- Validates drop-in functionality
- Checks constants synchronization (checksum validation)
</code></pre>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><strong>Q: Do I need to change my code?</strong><br />
A: No! It's a drop-in replacement with the same API.</p>
<p><strong>Q: What if I don't need compat layer?</strong><br />
A: ROUP works perfectly standalone. The compat layer is optional.</p>
<p><strong>Q: How do I get ompparser upgrades?</strong><br />
A: <code>git submodule update --remote</code> pulls latest ompparser automatically.</p>
<p><strong>Q: What about performance?</strong><br />
A: ROUP is expected to be faster than original ompparser due to Rust optimizations.</p>
<p><strong>Q: Is it stable?</strong><br />
A: ⚠️ Experimental stage - thoroughly tested (46 tests) but under active development.</p>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<ul>
<li><strong>Issues</strong>: <a href="https://github.com/ouankou/roup/issues">GitHub Issues</a></li>
<li><strong>Discussions</strong>: <a href="https://github.com/ouankou/roup/discussions">GitHub Discussions</a></li>
<li><strong>Email</strong>: See <a href="./contributing.html">Contributing Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h1>
<p>ROUP provides comprehensive APIs for Rust, C, and C++.</p>
<hr />
<h2 id="rust-api-documentation"><a class="header" href="#rust-api-documentation">Rust API Documentation</a></h2>
<p>The complete Rust API documentation is auto-generated from the source code using <code>rustdoc</code>.</p>
<p><strong><a href="./api/roup/index.html">→ View Rust API Documentation</a></strong></p>
<h3 id="key-modules"><a class="header" href="#key-modules">Key Modules</a></h3>
<ul>
<li>
<p><strong><code>roup::parser</code></strong> - Main parsing functions</p>
<ul>
<li><code>parse()</code> - Parse OpenMP directive from string</li>
<li><code>parse_with_config()</code> - Parse with custom configuration</li>
</ul>
</li>
<li>
<p><strong><code>roup::ir::directive</code></strong> - Directive types and structures</p>
<ul>
<li><code>DirectiveIR</code> - Main directive structure</li>
<li><code>DirectiveKind</code> - Enum of directive types</li>
</ul>
</li>
<li>
<p><strong><code>roup::ir::clause</code></strong> - Clause types and data</p>
<ul>
<li><code>Clause</code> - Clause structure</li>
<li><code>ClauseKind</code> - Enum of clause types</li>
<li><code>ScheduleKind</code>, <code>ReductionOperator</code>, etc.</li>
</ul>
</li>
<li>
<p><strong><code>roup::ir::types</code></strong> - Common types</p>
<ul>
<li><code>Language</code> - Source language (C, C++, Fortran)</li>
<li><code>SourceLocation</code> - Position in source code</li>
</ul>
</li>
</ul>
<h3 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h3>
<ul>
<li><a href="./api/roup/parser/index.html">Parse Functions</a></li>
<li><a href="./api/roup/ir/directive/index.html">Directive Types</a></li>
<li><a href="./api/roup/ir/clause/index.html">Clause Types</a></li>
</ul>
<hr />
<h2 id="translation-api"><a class="header" href="#translation-api">Translation API</a></h2>
<p>ROUP supports <strong>bidirectional translation</strong> between C/C++ and Fortran OpenMP directive syntax. This is useful for automatically porting benchmarks and code between languages.</p>
<h3 id="rust-translation-api"><a class="header" href="#rust-translation-api">Rust Translation API</a></h3>
<p>The <code>roup::ir::translate</code> module provides high-level translation functions:</p>
<pre><code class="language-rust ignore">use roup::ir::translate::{translate_c_to_fortran, translate_fortran_to_c};

// C/C++ → Fortran
let fortran = translate_c_to_fortran("#pragma omp parallel for private(i)")?;
// Result: "!$omp parallel do private(i)"

// Fortran → C/C++
let c_code = translate_fortran_to_c("!$omp parallel do schedule(static, 4)")?;
// Result: "#pragma omp parallel for schedule(static, 4)"</code></pre>
<p><strong>Advanced API</strong> (returns IR for further processing):</p>
<pre><code class="language-rust ignore">use roup::ir::{translate::translate_c_to_fortran_ir, Language, ParserConfig};

let config = ParserConfig::with_parsing(Language::C);
let ir = translate_c_to_fortran_ir("#pragma omp parallel for", config)?;

// Can query or modify the IR
println!("Language: {:?}", ir.language());
println!("Fortran: {}", ir.to_string_for_language(Language::Fortran));</code></pre>
<h3 id="supported-translations"><a class="header" href="#supported-translations">Supported Translations</a></h3>
<h4 id="loop-directive-mapping"><a class="header" href="#loop-directive-mapping">Loop Directive Mapping</a></h4>
<p>The translation correctly maps <strong>loop directive names</strong> between languages:</p>
<div class="table-wrapper"><table><thead><tr><th>C/C++</th><th>Fortran</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>do</code></td><td>Basic loop construct</td></tr>
<tr><td><code>for simd</code></td><td><code>do simd</code></td><td>SIMD loop</td></tr>
<tr><td><code>parallel for</code></td><td><code>parallel do</code></td><td>Parallel loop</td></tr>
<tr><td><code>parallel for simd</code></td><td><code>parallel do simd</code></td><td>Parallel SIMD loop</td></tr>
<tr><td><code>distribute parallel for</code></td><td><code>distribute parallel do</code></td><td>Distributed parallel loop</td></tr>
<tr><td><code>distribute parallel for simd</code></td><td><code>distribute parallel do simd</code></td><td>All combined forms</td></tr>
<tr><td><code>teams distribute parallel for</code></td><td><code>teams distribute parallel do</code></td><td>Complex nesting</td></tr>
<tr><td><code>target teams distribute parallel for simd</code></td><td><code>target teams distribute parallel do simd</code></td><td>Maximum nesting</td></tr>
</tbody></table>
</div>
<p><strong>Complete list</strong>: All 12 loop directive variants are supported in both directions.</p>
<h4 id="sentinel-translation"><a class="header" href="#sentinel-translation">Sentinel Translation</a></h4>
<div class="table-wrapper"><table><thead><tr><th>C/C++</th><th>Fortran</th></tr></thead><tbody>
<tr><td><code>#pragma omp</code></td><td><code>!$omp</code> (free-form)</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: Fixed-form Fortran sentinels (<code>c$omp</code>, <code>*$omp</code>) are supported for parsing but output uses free-form only.</p>
<h4 id="clause-preservation"><a class="header" href="#clause-preservation">Clause Preservation</a></h4>
<p>✅ <strong>All clauses are preserved as-is</strong> — The OpenMP standard defines clauses identically across languages:</p>
<pre><code class="language-text">Input (C):
#pragma omp parallel for private(i,j) schedule(static, 4) collapse(2)

Output (Fortran) - clauses unchanged:
!$omp parallel do private(i,j) schedule(static, 4) collapse(2)
</code></pre>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>The translation focuses on <strong>directive syntax only</strong>. The following are <strong>intentionally not translated</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reason</th></tr></thead><tbody>
<tr><td><strong>Expressions in clauses</strong></td><td>❌ Not translated</td><td>Language-specific syntax (e.g., <code>arr[i]</code> vs <code>arr(i)</code>) requires full expression parsing</td></tr>
<tr><td><strong>Variable names</strong></td><td>✅ Preserved</td><td>Variable identifiers work across languages</td></tr>
<tr><td><strong>Surrounding code</strong></td><td>❌ Not translated</td><td>Only directive lines are processed</td></tr>
<tr><td><strong>Fixed-form Fortran output</strong></td><td>❌ Not supported</td><td>Free-form <code>!$omp</code> is the modern standard</td></tr>
<tr><td><strong>Comments/whitespace</strong></td><td>❌ Not preserved</td><td>Output is normalized</td></tr>
</tbody></table>
</div>
<p><strong>Example limitation:</strong></p>
<pre><code class="language-c">// Input (C)
#pragma omp parallel for reduction(+:sum) if(n &gt; 1000)

// Output (Fortran) - expressions NOT translated
!$omp parallel do reduction(+:sum) if(n &gt; 1000)
//                                   ^^^^^^^^^^^^
//                                   Still C syntax! Manual fix needed.
</code></pre>
<p><strong>Recommendation</strong>: Use translation for directive structure, then manually adjust expressions for target language.</p>
<h3 id="c-translation-api"><a class="header" href="#c-translation-api">C Translation API</a></h3>
<p>The C API provides <code>roup_convert_language()</code> for language conversion:</p>
<pre><code class="language-c">// Convert C to Fortran
const char* c_input = "#pragma omp parallel for private(x)";
char* fortran_output = roup_convert_language(
    c_input,
    ROUP_LANG_C,              // from language
    ROUP_LANG_FORTRAN_FREE    // to language
);

if (fortran_output != NULL) {
    printf("Fortran: %s\n", fortran_output);
    // Result: "!$omp parallel do private(x)"

    // IMPORTANT: Free the returned string
    roup_string_free(fortran_output);
}
</code></pre>
<p><strong>Language codes:</strong></p>
<pre><code class="language-c">#define ROUP_LANG_C             0
#define ROUP_LANG_FORTRAN_FREE  2
#define ROUP_LANG_FORTRAN_FIXED 3
</code></pre>
<p><strong>Function signature:</strong></p>
<pre><code class="language-c">// Convert directive between languages
// Returns NULL on error (must free with roup_string_free on success)
char* roup_convert_language(
    const char* input,
    int32_t from_language,
    int32_t to_language
);

// Free string returned by roup_convert_language
void roup_string_free(char* ptr);
</code></pre>
<p><strong>Error handling:</strong> Returns <code>NULL</code> if:</p>
<ul>
<li>Input is NULL or empty</li>
<li>Language code is invalid</li>
<li>Parsing fails</li>
<li>Conversion fails</li>
</ul>
<h3 id="translation-error-handling"><a class="header" href="#translation-error-handling">Translation Error Handling</a></h3>
<p><strong>Rust API:</strong></p>
<pre><code class="language-rust ignore">use roup::ir::translate::{translate_c_to_fortran, TranslationError};

match translate_c_to_fortran(input) {
    Ok(fortran) =&gt; println!("Translated: {}", fortran),
    Err(TranslationError::EmptyInput) =&gt; eprintln!("Input is empty"),
    Err(TranslationError::ParseError(msg)) =&gt; eprintln!("Parse failed: {}", msg),
    Err(TranslationError::ConversionError(err)) =&gt; eprintln!("Conversion failed: {}", err),
}</code></pre>
<p><strong>C API:</strong></p>
<pre><code class="language-c">char* result = roup_convert_language(input, ROUP_LANG_C, ROUP_LANG_FORTRAN_FREE);
if (result == NULL) {
    fprintf(stderr, "Translation failed\n");
    return 1;
}
// Use result...
roup_string_free(result);
</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<ol>
<li><strong>Benchmark porting</strong> - Convert OpenMP benchmarks between languages</li>
<li><strong>Multi-language codebases</strong> - Generate equivalent directives for polyglot projects</li>
<li><strong>Documentation</strong> - Show directive equivalents across languages</li>
<li><strong>Code generation</strong> - Generate language-specific directives from templates</li>
<li><strong>Migration tools</strong> - Assist in language migration projects</li>
</ol>
<hr />
<h2 id="c-api-reference"><a class="header" href="#c-api-reference">C API Reference</a></h2>
<p>ROUP exports 16 C functions for FFI integration, providing a minimal C API with unsafe pointer operations only at the FFI boundary. All functions use direct C pointers (<code>*mut OmpDirective</code>, <code>*mut OmpClause</code>) following a standard malloc/free pattern.</p>
<p><strong>Source</strong>: <code>src/c_api.rs</code> (~60 lines of unsafe code at FFI boundary, ~0.9% of file)</p>
<h3 id="lifecycle-functions-1"><a class="header" href="#lifecycle-functions-1">Lifecycle Functions</a></h3>
<pre><code class="language-c">// Parse OpenMP directive from C string
OmpDirective* roup_parse(const char* input);

// Free directive (required after parsing)
void roup_directive_free(OmpDirective* directive);

// Free clause (usually not needed - owned by directive)
void roup_clause_free(OmpClause* clause);
</code></pre>
<h3 id="directive-query-functions"><a class="header" href="#directive-query-functions">Directive Query Functions</a></h3>
<pre><code class="language-c">// Get directive kind (0=parallel, 1=for, etc.)
int32_t roup_directive_kind(const OmpDirective* directive);

// Get number of clauses
int32_t roup_directive_clause_count(const OmpDirective* directive);

// Create clause iterator
OmpClauseIterator* roup_directive_clauses_iter(const OmpDirective* directive);
</code></pre>
<h3 id="iterator-functions"><a class="header" href="#iterator-functions">Iterator Functions</a></h3>
<pre><code class="language-c">// Get next clause from iterator
// Returns 1 if clause available, 0 if done
int32_t roup_clause_iterator_next(OmpClauseIterator* iter, OmpClause** out);

// Free iterator
void roup_clause_iterator_free(OmpClauseIterator* iter);
</code></pre>
<h3 id="clause-query-functions"><a class="header" href="#clause-query-functions">Clause Query Functions</a></h3>
<pre><code class="language-c">// Get clause kind (0=num_threads, 2=private, etc.)
int32_t roup_clause_kind(const OmpClause* clause);

// Get schedule kind (0=static, 1=dynamic, etc.)
int32_t roup_clause_schedule_kind(const OmpClause* clause);

// Get reduction operator (0=+, 1=-, 2=*, etc.)
int32_t roup_clause_reduction_operator(const OmpClause* clause);

// Get default data sharing (0=shared, 1=none)
int32_t roup_clause_default_data_sharing(const OmpClause* clause);
</code></pre>
<h3 id="variable-list-functions"><a class="header" href="#variable-list-functions">Variable List Functions</a></h3>
<pre><code class="language-c">// Get variable list from clause (e.g., private(x, y, z))
OmpStringList* roup_clause_variables(const OmpClause* clause);

// Get length of string list
int32_t roup_string_list_len(const OmpStringList* list);

// Get string at index
const char* roup_string_list_get(const OmpStringList* list, int32_t index);

// Free string list
void roup_string_list_free(OmpStringList* list);
</code></pre>
<h3 id="mapping-tables"><a class="header" href="#mapping-tables">Mapping Tables</a></h3>
<blockquote>
<p><strong>Important:</strong> These values are defined in <code>src/c_api.rs</code>. The C API uses a <strong>simple subset</strong> of OpenMP clauses with straightforward integer mapping.</p>
</blockquote>
<h4 id="directive-kinds"><a class="header" href="#directive-kinds">Directive Kinds</a></h4>
<p>The C API provides <code>roup_directive_kind()</code> which returns an integer representing the directive type. The specific mapping depends on the parser's internal directive registry.</p>
<p><strong>Common directive types</strong> (from parser):</p>
<ul>
<li>Parallel constructs: <code>parallel</code>, <code>parallel for</code>, <code>parallel sections</code></li>
<li>Work-sharing: <code>for</code>, <code>sections</code>, <code>single</code>, <code>workshare</code></li>
<li>Tasking: <code>task</code>, <code>taskloop</code>, <code>taskgroup</code>, <code>taskwait</code></li>
<li>Device: <code>target</code>, <code>target data</code>, <code>target update</code>, <code>teams</code></li>
<li>Synchronization: <code>barrier</code>, <code>critical</code>, <code>atomic</code>, <code>ordered</code></li>
<li>SIMD: <code>simd</code>, <code>declare simd</code>, <code>distribute</code></li>
<li>Advanced: <code>metadirective</code>, <code>declare variant</code>, <code>assume</code></li>
</ul>
<p>For a complete list of all 120+ supported directives with version compatibility, see the <a href="./openmp-support.html">OpenMP Support Matrix</a>.</p>
<h4 id="clause-kinds-integer-discriminants"><a class="header" href="#clause-kinds-integer-discriminants">Clause Kinds (Integer Discriminants)</a></h4>
<p>The C API supports 12 common clause types with simple integer mapping:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Clause</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td>0</td><td><code>num_threads</code></td><td>Thread count</td><td><code>num_threads(4)</code></td></tr>
<tr><td>1</td><td><code>if</code></td><td>Conditional</td><td><code>if(condition)</code></td></tr>
<tr><td>2</td><td><code>private</code></td><td>Private variables</td><td><code>private(x, y)</code></td></tr>
<tr><td>3</td><td><code>shared</code></td><td>Shared variables</td><td><code>shared(a, b)</code></td></tr>
<tr><td>4</td><td><code>firstprivate</code></td><td>Private with init</td><td><code>firstprivate(z)</code></td></tr>
<tr><td>5</td><td><code>lastprivate</code></td><td>Private with final value</td><td><code>lastprivate(result)</code></td></tr>
<tr><td>6</td><td><code>reduction</code></td><td>Reduction operation</td><td><code>reduction(+:sum)</code></td></tr>
<tr><td>7</td><td><code>schedule</code></td><td>Loop scheduling</td><td><code>schedule(static, 100)</code></td></tr>
<tr><td>8</td><td><code>collapse</code></td><td>Loop nesting</td><td><code>collapse(2)</code></td></tr>
<tr><td>9</td><td><code>ordered</code></td><td>Ordered execution</td><td><code>ordered</code></td></tr>
<tr><td>10</td><td><code>nowait</code></td><td>Remove barrier</td><td><code>nowait</code></td></tr>
<tr><td>11</td><td><code>default</code></td><td>Default sharing</td><td><code>default(shared)</code></td></tr>
<tr><td>999</td><td>Unknown</td><td>Unrecognized clause</td><td>-</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: The C API intentionally supports a focused subset of clauses for simplicity. The Rust API supports all 92+ OpenMP 6.0 clauses.</p>
<h4 id="schedule-kinds"><a class="header" href="#schedule-kinds">Schedule Kinds</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Schedule</th></tr></thead><tbody>
<tr><td>0</td><td><code>static</code></td></tr>
<tr><td>1</td><td><code>dynamic</code></td></tr>
<tr><td>2</td><td><code>guided</code></td></tr>
<tr><td>3</td><td><code>auto</code></td></tr>
<tr><td>4</td><td><code>runtime</code></td></tr>
</tbody></table>
</div>
<h4 id="default-kinds-defaultkind-enum"><a class="header" href="#default-kinds-defaultkind-enum">Default Kinds (DefaultKind enum)</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Default</th></tr></thead><tbody>
<tr><td>0</td><td><code>shared</code></td></tr>
<tr><td>1</td><td><code>none</code></td></tr>
<tr><td>2</td><td><code>private</code></td></tr>
<tr><td>3</td><td><code>firstprivate</code></td></tr>
</tbody></table>
</div>
<h4 id="reduction-operators-reductionoperator-enum"><a class="header" href="#reduction-operators-reductionoperator-enum">Reduction Operators (ReductionOperator enum)</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Operator</th></tr></thead><tbody>
<tr><td>0</td><td><code>+</code> (add)</td></tr>
<tr><td>1</td><td><code>*</code> (multiply)</td></tr>
<tr><td>2</td><td><code>-</code> (subtract)</td></tr>
<tr><td>3</td><td><code>&amp;</code> (bitwise AND)</td></tr>
<tr><td>4</td><td>`</td></tr>
<tr><td>5</td><td><code>^</code> (bitwise XOR)</td></tr>
<tr><td>6</td><td><code>&amp;&amp;</code> (logical AND)</td></tr>
<tr><td>7</td><td>`</td></tr>
<tr><td>8</td><td><code>min</code> (minimum)</td></tr>
<tr><td>9</td><td><code>max</code> (maximum)</td></tr>
<tr><td>10</td><td><code>custom</code> (user-defined)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-raii-wrappers"><a class="header" href="#c-raii-wrappers">C++ RAII Wrappers</a></h2>
<p>For modern C++17 applications, use the RAII wrappers provided in the <a href="./cpp-tutorial.html#step-2-create-raii-wrappers-modern-c">C++ Tutorial</a>.</p>
<p><strong>Key classes:</strong></p>
<ul>
<li><code>roup::Directive</code> - Auto-frees directive on destruction</li>
<li><code>roup::ClauseIterator</code> - Auto-frees iterator on destruction</li>
<li><code>roup::StringList</code> - Auto-frees string list on destruction</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">#include "roup_wrapper.hpp"

roup::Directive dir("#pragma omp parallel for num_threads(4)");
if (dir) {
    std::cout &lt;&lt; "Kind: " &lt;&lt; dir.kind() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Clauses: " &lt;&lt; dir.clause_count() &lt;&lt; std::endl;
}
// Automatic cleanup when dir goes out of scope
</code></pre>
<hr />
<h2 id="memory-management-rules"><a class="header" href="#memory-management-rules">Memory Management Rules</a></h2>
<h3 id="rust-api"><a class="header" href="#rust-api">Rust API</a></h3>
<ul>
<li><strong>Automatic</strong> - Rust's ownership system handles everything</li>
<li>No manual <code>free()</code> needed</li>
</ul>
<h3 id="c-api"><a class="header" href="#c-api">C API</a></h3>
<ul>
<li><strong>Manual</strong> - Must call <code>_free()</code> functions</li>
<li><strong>Directive:</strong> Call <code>roup_directive_free()</code> when done</li>
<li><strong>Iterator:</strong> Call <code>roup_clause_iterator_free()</code> when done</li>
<li><strong>String List:</strong> Call <code>roup_string_list_free()</code> when done</li>
<li><strong>Clauses:</strong> Do NOT free - owned by directive</li>
</ul>
<h3 id="c-raii-api"><a class="header" href="#c-raii-api">C++ RAII API</a></h3>
<ul>
<li><strong>Automatic</strong> - RAII wrappers call <code>_free()</code> in destructors</li>
<li>Exception-safe - cleanup happens even with exceptions</li>
</ul>
<hr />
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp;

let parser = openmp::parser();
match parser.parse(input) {
    Ok((_, directive)) =&gt; { /* use directive */ },
    Err(e) =&gt; eprintln!("Parse error: {:?}", e),
}</code></pre>
<h3 id="c-2"><a class="header" href="#c-2">C</a></h3>
<pre><code class="language-c">OmpDirective* dir = roup_parse(input);
if (dir == NULL) {
    fprintf(stderr, "Parse failed\n");
    return 1;
}
// Use dir...
roup_directive_free(dir);
</code></pre>
<h3 id="c-3"><a class="header" href="#c-3">C++</a></h3>
<pre><code class="language-cpp">roup::Directive dir(input);
if (!dir) {
    std::cerr &lt;&lt; "Parse failed\n";
    return 1;
}
// Use dir...
</code></pre>
<hr />
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<ul>
<li>✅ <strong>Parsing is thread-safe</strong> - Multiple threads can call <code>parse()</code> simultaneously</li>
<li>✅ <strong>Read operations are thread-safe</strong> - Query functions are read-only</li>
<li>⚠️ <strong>Modification is not thread-safe</strong> - Don't mutate same directive from multiple threads</li>
<li>⚠️ <strong>Iterators are single-threaded</strong> - One iterator per thread</li>
</ul>
<hr />
<h2 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h2>
<ol>
<li><strong>Reuse parsed directives</strong> when possible</li>
<li><strong>Avoid reparsing</strong> the same string repeatedly</li>
<li><strong>Use iterators</strong> instead of random access</li>
<li><strong>Batch operations</strong> to minimize FFI overhead (C/C++)</li>
<li><strong>Profile first</strong> - parsing is usually not the bottleneck</li>
</ol>
<hr />
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><a href="./api/roup/index.html">Rust API Documentation</a> - Complete rustdoc</li>
<li><a href="./cpp-tutorial.html">C++ Tutorial</a> - Real-world C++ examples</li>
<li><a href="https://github.com/ouankou/roup">GitHub Repository</a> - Source code and examples</li>
<li><a href="./getting-started.html">Getting Started Guide</a> - Get started in 5 minutes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openmp-support-1"><a class="header" href="#openmp-support-1">OpenMP support</a></h1>
<p>ROUP registers every directive and clause keyword from the OpenMP 6.0
specification. The canonical listings live in the generated reference chapters:</p>
<ul>
<li><a href="./openmp60-directives-clauses.html">Directive catalogue</a></li>
<li><a href="./openmp60-directive-clause-components.html">Directive/clause components</a></li>
<li><a href="./openmp60-restrictions.html">Restrictions</a></li>
</ul>
<h2 id="quick-facts"><a class="header" href="#quick-facts">Quick facts</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Details</th></tr></thead><tbody>
<tr><td>OpenMP versions</td><td>3.0 – 6.0</td></tr>
<tr><td>Directive keywords</td><td>128</td></tr>
<tr><td>Clause keywords</td><td>132</td></tr>
<tr><td>Languages</td><td>C, C++, Fortran</td></tr>
<tr><td>Automated tests</td><td>620</td></tr>
</tbody></table>
</div>
<p>Unknown directives and clauses are rejected so unsupported constructs fail fast.
The <code>tests/openmp_keyword_coverage.rs</code> integration test keeps the registry in
sync with the specification, and additional round-trip tests validate parsing,
IR conversion, and display.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openmp-60-directives-and-clauses"><a class="header" href="#openmp-60-directives-and-clauses">OpenMP 6.0 Directives and Clauses</a></h1>
<p>This catalogue is derived directly from the ROUP parser's keyword registries and
shows exactly which OpenMP 6.0 directive and clause tokens are recognised.  The
source of truth is <code>OpenMpDirective::ALL</code> and <code>OpenMpClause::ALL</code> in
<a href="../../../src/parser/openmp.rs"><code>src/parser/openmp.rs</code></a>.  Every entry listed
below is exercised by the automated support-matrix tests, so the tables always
reflect parser reality.</p>
<p>For the normative meaning of each keyword, consult the
<a href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-6-0.pdf">OpenMP Application Programming Interface Version 6.0 specification</a>.</p>
<h2 id="directive-keywords-127-total"><a class="header" href="#directive-keywords-127-total">Directive keywords (127 total)</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><code>allocate</code></td><td><code>distribute parallel loop simd</code></td><td><code>parallel master taskloop</code></td><td><code>target teams distribute parallel for simd</code></td></tr>
<tr><td><code>allocators</code></td><td><code>distribute simd</code></td><td><code>parallel master taskloop simd</code></td><td><code>target teams distribute parallel loop</code></td></tr>
<tr><td><code>assume</code></td><td><code>do</code></td><td><code>parallel sections</code></td><td><code>target teams distribute parallel loop simd</code></td></tr>
<tr><td><code>assumes</code></td><td><code>do simd</code></td><td><code>requires</code></td><td><code>target teams distribute simd</code></td></tr>
<tr><td><code>atomic</code></td><td><code>end declare target</code></td><td><code>reverse</code></td><td><code>target teams loop</code></td></tr>
<tr><td><code>atomic capture</code></td><td><code>error</code></td><td><code>scan</code></td><td><code>target teams loop simd</code></td></tr>
<tr><td><code>atomic compare capture</code></td><td><code>flush</code></td><td><code>scope</code></td><td><code>target update</code></td></tr>
<tr><td><code>atomic read</code></td><td><code>for</code></td><td><code>section</code></td><td><code>task</code></td></tr>
<tr><td><code>atomic update</code></td><td><code>for simd</code></td><td><code>sections</code></td><td><code>task iteration</code></td></tr>
<tr><td><code>atomic write</code></td><td><code>fuse</code></td><td><code>simd</code></td><td><code>taskgraph</code></td></tr>
<tr><td><code>barrier</code></td><td><code>groupprivate</code></td><td><code>single</code></td><td><code>taskgroup</code></td></tr>
<tr><td><code>begin assumes</code></td><td><code>interchange</code></td><td><code>split</code></td><td><code>taskloop</code></td></tr>
<tr><td><code>begin declare target</code></td><td><code>interop</code></td><td><code>stripe</code></td><td><code>taskloop simd</code></td></tr>
<tr><td><code>begin declare variant</code></td><td><code>loop</code></td><td><code>target</code></td><td><code>taskwait</code></td></tr>
<tr><td><code>begin metadirective</code></td><td><code>masked</code></td><td><code>target data</code></td><td><code>taskyield</code></td></tr>
<tr><td><code>cancel</code></td><td><code>masked taskloop</code></td><td><code>target enter data</code></td><td><code>teams</code></td></tr>
<tr><td><code>cancellation point</code></td><td><code>masked taskloop simd</code></td><td><code>target exit data</code></td><td><code>teams distribute</code></td></tr>
<tr><td><code>critical</code></td><td><code>master</code></td><td><code>target loop</code></td><td><code>teams distribute parallel do</code></td></tr>
<tr><td><code>declare induction</code></td><td><code>metadirective</code></td><td><code>target loop simd</code></td><td><code>teams distribute parallel do simd</code></td></tr>
<tr><td><code>declare mapper</code></td><td><code>nothing</code></td><td><code>target parallel</code></td><td><code>teams distribute parallel for</code></td></tr>
<tr><td><code>declare reduction</code></td><td><code>ordered</code></td><td><code>target parallel do</code></td><td><code>teams distribute parallel for simd</code></td></tr>
<tr><td><code>declare simd</code></td><td><code>parallel</code></td><td><code>target parallel do simd</code></td><td><code>teams distribute parallel loop</code></td></tr>
<tr><td><code>declare target</code></td><td><code>parallel do</code></td><td><code>target parallel for</code></td><td><code>teams distribute parallel loop simd</code></td></tr>
<tr><td><code>declare variant</code></td><td><code>parallel do simd</code></td><td><code>target parallel for simd</code></td><td><code>teams distribute simd</code></td></tr>
<tr><td><code>depobj</code></td><td><code>parallel for</code></td><td><code>target parallel loop</code></td><td><code>teams loop</code></td></tr>
<tr><td><code>dispatch</code></td><td><code>parallel for simd</code></td><td><code>target parallel loop simd</code></td><td><code>teams loop simd</code></td></tr>
<tr><td><code>distribute</code></td><td><code>parallel loop</code></td><td><code>target simd</code></td><td><code>threadprivate</code></td></tr>
<tr><td><code>distribute parallel do</code></td><td><code>parallel loop simd</code></td><td><code>target teams</code></td><td><code>tile</code></td></tr>
<tr><td><code>distribute parallel do simd</code></td><td><code>parallel masked</code></td><td><code>target teams distribute</code></td><td><code>unroll</code></td></tr>
<tr><td><code>distribute parallel for</code></td><td><code>parallel masked taskloop</code></td><td><code>target teams distribute parallel do</code></td><td><code>workdistribute</code></td></tr>
<tr><td><code>distribute parallel for simd</code></td><td><code>parallel masked taskloop simd</code></td><td><code>target teams distribute parallel do simd</code></td><td><code>workshare</code></td></tr>
<tr><td><code>distribute parallel loop</code></td><td><code>parallel master</code></td><td><code>target teams distribute parallel for</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="clause-keywords-132-total"><a class="header" href="#clause-keywords-132-total">Clause keywords (132 total)</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><code>absent</code></td><td><code>doacross</code></td><td><code>looprange</code></td><td><code>reproducible</code></td></tr>
<tr><td><code>acq_rel</code></td><td><code>dynamic_allocators</code></td><td><code>map</code></td><td><code>reverse</code></td></tr>
<tr><td><code>acquire</code></td><td><code>enter</code></td><td><code>match</code></td><td><code>reverse_offload</code></td></tr>
<tr><td><code>adjust_args</code></td><td><code>exclusive</code></td><td><code>memscope</code></td><td><code>safelen</code></td></tr>
<tr><td><code>affinity</code></td><td><code>fail</code></td><td><code>mergeable</code></td><td><code>safesync</code></td></tr>
<tr><td><code>align</code></td><td><code>filter</code></td><td><code>message</code></td><td><code>schedule</code></td></tr>
<tr><td><code>aligned</code></td><td><code>final</code></td><td><code>no_openmp</code></td><td><code>self_maps</code></td></tr>
<tr><td><code>allocate</code></td><td><code>firstprivate</code></td><td><code>no_openmp_constructs</code></td><td><code>seq_cst</code></td></tr>
<tr><td><code>allocator</code></td><td><code>from</code></td><td><code>no_openmp_routines</code></td><td><code>severity</code></td></tr>
<tr><td><code>append_args</code></td><td><code>full</code></td><td><code>no_parallelism</code></td><td><code>shared</code></td></tr>
<tr><td><code>apply</code></td><td><code>grainsize</code></td><td><code>nocontext</code></td><td><code>simd</code></td></tr>
<tr><td><code>at</code></td><td><code>graph_id</code></td><td><code>nogroup</code></td><td><code>simdlen</code></td></tr>
<tr><td><code>atomic_default_mem_order</code></td><td><code>graph_reset</code></td><td><code>nontemporal</code></td><td><code>sizes</code></td></tr>
<tr><td><code>bind</code></td><td><code>has_device_addr</code></td><td><code>notinbranch</code></td><td><code>task_reduction</code></td></tr>
<tr><td><code>capture</code></td><td><code>hint</code></td><td><code>novariants</code></td><td><code>thread_limit</code></td></tr>
<tr><td><code>collapse</code></td><td><code>holds</code></td><td><code>nowait</code></td><td><code>threads</code></td></tr>
<tr><td><code>collector</code></td><td><code>if</code></td><td><code>num_tasks</code></td><td><code>threadset</code></td></tr>
<tr><td><code>combiner</code></td><td><code>in_reduction</code></td><td><code>num_teams</code></td><td><code>tile</code></td></tr>
<tr><td><code>compare</code></td><td><code>inbranch</code></td><td><code>num_threads</code></td><td><code>to</code></td></tr>
<tr><td><code>contains</code></td><td><code>inclusive</code></td><td><code>order</code></td><td><code>transparent</code></td></tr>
<tr><td><code>copyin</code></td><td><code>indirect</code></td><td><code>ordered</code></td><td><code>unified_address</code></td></tr>
<tr><td><code>copyprivate</code></td><td><code>induction</code></td><td><code>otherwise</code></td><td><code>unified_shared_memory</code></td></tr>
<tr><td><code>counts</code></td><td><code>inductor</code></td><td><code>partial</code></td><td><code>uniform</code></td></tr>
<tr><td><code>default</code></td><td><code>init</code></td><td><code>permutation</code></td><td><code>unroll</code></td></tr>
<tr><td><code>defaultmap</code></td><td><code>init_complete</code></td><td><code>priority</code></td><td><code>untied</code></td></tr>
<tr><td><code>depend</code></td><td><code>initializer</code></td><td><code>private</code></td><td><code>update</code></td></tr>
<tr><td><code>destroy</code></td><td><code>interop</code></td><td><code>proc_bind</code></td><td><code>use</code></td></tr>
<tr><td><code>detach</code></td><td><code>is_device_ptr</code></td><td><code>public</code></td><td><code>use_device_addr</code></td></tr>
<tr><td><code>device</code></td><td><code>label</code></td><td><code>read</code></td><td><code>use_device_ptr</code></td></tr>
<tr><td><code>device_resident</code></td><td><code>lastprivate</code></td><td><code>reduction</code></td><td><code>uses_allocators</code></td></tr>
<tr><td><code>device_safesync</code></td><td><code>linear</code></td><td><code>relaxed</code></td><td><code>weak</code></td></tr>
<tr><td><code>device_type</code></td><td><code>link</code></td><td><code>release</code></td><td><code>when</code></td></tr>
<tr><td><code>dist_schedule</code></td><td><code>local</code></td><td><code>replayable</code></td><td><code>write</code></td></tr>
</tbody></table>
</div>
<h2 id="keeping-the-list-in-sync"><a class="header" href="#keeping-the-list-in-sync">Keeping the list in sync</a></h2>
<p>To regenerate the tables after changing <code>src/parser/openmp.rs</code>, run the helper
script below and replace the output in this document:</p>
<pre><code class="language-bash">python - &lt;&lt;'PY'
import math, pathlib, re
text = pathlib.Path('src/parser/openmp.rs').read_text()
block = re.search(r"openmp_directives!\s*{(.*?)}\s*\n\npub fn clause_registry", text, re.S).group(1)
directives = sorted({re.search(r'"([^"]+)"', line).group(1)
                      for line in block.splitlines() if '"' in line})
clauses_block = re.search(r"openmp_clauses!\s*{(.*?)}\s*\n\nmacro_rules!", text, re.S).group(1)
clauses = sorted({re.search(r'name: "([^"]+)"', line).group(1)
                   for line in clauses_block.splitlines() if 'name:' in line})

def make_table(items, columns=4):
    rows = math.ceil(len(items) / columns)
    table = ['| ' + ' | '.join([''] * columns) + ' |', '| ' + ' | '.join(['---'] * columns) + ' |']
    for r in range(rows):
        row = []
        for c in range(columns):
            idx = c * rows + r
            row.append(f"`{items[idx]}`" if idx &lt; len(items) else '')
        table.append('| ' + ' | '.join(row) + ' |')
    return '\n'.join(table)

print(make_table(directives))
print('\n')
print(make_table(clauses))
PY
</code></pre>
<p>Keeping this document machine-derived guarantees it matches the parser at all
times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openmp-60-directiveclause-components"><a class="header" href="#openmp-60-directiveclause-components">OpenMP 6.0 Directive–Clause Components</a></h1>
<p>This reference summarises how the ROUP parser tokenises OpenMP 6.0 clause
keywords.  Rather than attempting to restate the entire specification, the
information below mirrors the parser's <a href="../../../src/parser/openmp.rs"><code>ClauseRule</code></a>
data so you can quickly see which textual forms are accepted.  Combined
constructs (for example <code>parallel for</code> or <code>target teams distribute parallel for simd</code>) are already part of the directive keyword registry listed in the
<a href="./openmp60-directives-clauses.html">directive catalogue</a>.</p>
<blockquote>
<p><strong>Note:</strong> The OpenMP specification defines which directives may use a given
clause and any semantic restrictions.  ROUP currently enforces keyword syntax
and delegates the normative rules to higher layers.  Consult the
<a href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-6-0.pdf">OpenMP 6.0 specification</a>
for the full directive–clause compatibility matrix.</p>
</blockquote>
<h2 id="clause-syntax-summary"><a class="header" href="#clause-syntax-summary">Clause syntax summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Clause</th><th>Parser rule</th><th>Accepted forms</th></tr></thead><tbody>
<tr><td><code>absent</code></td><td>Parenthesized</td><td><code>absent(...)</code></td></tr>
<tr><td><code>acq_rel</code></td><td>Bare</td><td><code>#pragma omp parallel acq_rel</code></td></tr>
<tr><td><code>acquire</code></td><td>Bare</td><td><code>#pragma omp parallel acquire</code></td></tr>
<tr><td><code>adjust_args</code></td><td>Parenthesized</td><td><code>adjust_args(...)</code></td></tr>
<tr><td><code>affinity</code></td><td>Parenthesized</td><td><code>affinity(...)</code></td></tr>
<tr><td><code>align</code></td><td>Parenthesized</td><td><code>align(...)</code></td></tr>
<tr><td><code>aligned</code></td><td>Parenthesized</td><td><code>aligned(...)</code></td></tr>
<tr><td><code>allocate</code></td><td>Parenthesized</td><td><code>allocate(...)</code></td></tr>
<tr><td><code>allocator</code></td><td>Parenthesized</td><td><code>allocator(...)</code></td></tr>
<tr><td><code>append_args</code></td><td>Parenthesized</td><td><code>append_args(...)</code></td></tr>
<tr><td><code>apply</code></td><td>Parenthesized</td><td><code>apply(...)</code></td></tr>
<tr><td><code>at</code></td><td>Parenthesized</td><td><code>at(...)</code></td></tr>
<tr><td><code>atomic_default_mem_order</code></td><td>Parenthesized</td><td><code>atomic_default_mem_order(...)</code></td></tr>
<tr><td><code>bind</code></td><td>Parenthesized</td><td><code>bind(...)</code></td></tr>
<tr><td><code>capture</code></td><td>Flexible</td><td><code>capture</code> or <code>capture(...)</code></td></tr>
<tr><td><code>collapse</code></td><td>Parenthesized</td><td><code>collapse(...)</code></td></tr>
<tr><td><code>collector</code></td><td>Parenthesized</td><td><code>collector(...)</code></td></tr>
<tr><td><code>combiner</code></td><td>Parenthesized</td><td><code>combiner(...)</code></td></tr>
<tr><td><code>compare</code></td><td>Flexible</td><td><code>compare</code> or <code>compare(...)</code></td></tr>
<tr><td><code>contains</code></td><td>Parenthesized</td><td><code>contains(...)</code></td></tr>
<tr><td><code>copyin</code></td><td>Parenthesized</td><td><code>copyin(...)</code></td></tr>
<tr><td><code>copyprivate</code></td><td>Parenthesized</td><td><code>copyprivate(...)</code></td></tr>
<tr><td><code>counts</code></td><td>Parenthesized</td><td><code>counts(...)</code></td></tr>
<tr><td><code>default</code></td><td>Parenthesized</td><td><code>default(...)</code></td></tr>
<tr><td><code>defaultmap</code></td><td>Parenthesized</td><td><code>defaultmap(...)</code></td></tr>
<tr><td><code>depend</code></td><td>Parenthesized</td><td><code>depend(...)</code></td></tr>
<tr><td><code>destroy</code></td><td>Flexible</td><td><code>destroy</code> or <code>destroy(...)</code></td></tr>
<tr><td><code>detach</code></td><td>Parenthesized</td><td><code>detach(...)</code></td></tr>
<tr><td><code>device</code></td><td>Parenthesized</td><td><code>device(...)</code></td></tr>
<tr><td><code>device_resident</code></td><td>Parenthesized</td><td><code>device_resident(...)</code></td></tr>
<tr><td><code>device_safesync</code></td><td>Flexible</td><td><code>device_safesync</code> or <code>device_safesync(...)</code></td></tr>
<tr><td><code>device_type</code></td><td>Parenthesized</td><td><code>device_type(...)</code></td></tr>
<tr><td><code>dist_schedule</code></td><td>Parenthesized</td><td><code>dist_schedule(...)</code></td></tr>
<tr><td><code>doacross</code></td><td>Parenthesized</td><td><code>doacross(...)</code></td></tr>
<tr><td><code>dynamic_allocators</code></td><td>Bare</td><td><code>#pragma omp parallel dynamic_allocators</code></td></tr>
<tr><td><code>enter</code></td><td>Parenthesized</td><td><code>enter(...)</code></td></tr>
<tr><td><code>exclusive</code></td><td>Bare</td><td><code>#pragma omp parallel exclusive</code></td></tr>
<tr><td><code>fail</code></td><td>Flexible</td><td><code>fail</code> or <code>fail(...)</code></td></tr>
<tr><td><code>filter</code></td><td>Parenthesized</td><td><code>filter(...)</code></td></tr>
<tr><td><code>final</code></td><td>Parenthesized</td><td><code>final(...)</code></td></tr>
<tr><td><code>firstprivate</code></td><td>Parenthesized</td><td><code>firstprivate(...)</code></td></tr>
<tr><td><code>from</code></td><td>Parenthesized</td><td><code>from(...)</code></td></tr>
<tr><td><code>full</code></td><td>Flexible</td><td><code>full</code> or <code>full(...)</code></td></tr>
<tr><td><code>grainsize</code></td><td>Parenthesized</td><td><code>grainsize(...)</code></td></tr>
<tr><td><code>graph_id</code></td><td>Parenthesized</td><td><code>graph_id(...)</code></td></tr>
<tr><td><code>graph_reset</code></td><td>Parenthesized</td><td><code>graph_reset(...)</code></td></tr>
<tr><td><code>has_device_addr</code></td><td>Parenthesized</td><td><code>has_device_addr(...)</code></td></tr>
<tr><td><code>hint</code></td><td>Parenthesized</td><td><code>hint(...)</code></td></tr>
<tr><td><code>holds</code></td><td>Parenthesized</td><td><code>holds(...)</code></td></tr>
<tr><td><code>if</code></td><td>Parenthesized</td><td><code>if(...)</code></td></tr>
<tr><td><code>in_reduction</code></td><td>Parenthesized</td><td><code>in_reduction(...)</code></td></tr>
<tr><td><code>inbranch</code></td><td>Bare</td><td><code>#pragma omp parallel inbranch</code></td></tr>
<tr><td><code>inclusive</code></td><td>Bare</td><td><code>#pragma omp parallel inclusive</code></td></tr>
<tr><td><code>indirect</code></td><td>Flexible</td><td><code>indirect</code> or <code>indirect(...)</code></td></tr>
<tr><td><code>induction</code></td><td>Parenthesized</td><td><code>induction(...)</code></td></tr>
<tr><td><code>inductor</code></td><td>Parenthesized</td><td><code>inductor(...)</code></td></tr>
<tr><td><code>init</code></td><td>Parenthesized</td><td><code>init(...)</code></td></tr>
<tr><td><code>init_complete</code></td><td>Flexible</td><td><code>init_complete</code> or <code>init_complete(...)</code></td></tr>
<tr><td><code>initializer</code></td><td>Parenthesized</td><td><code>initializer(...)</code></td></tr>
<tr><td><code>interop</code></td><td>Parenthesized</td><td><code>interop(...)</code></td></tr>
<tr><td><code>is_device_ptr</code></td><td>Parenthesized</td><td><code>is_device_ptr(...)</code></td></tr>
<tr><td><code>label</code></td><td>Parenthesized</td><td><code>label(...)</code></td></tr>
<tr><td><code>lastprivate</code></td><td>Parenthesized</td><td><code>lastprivate(...)</code></td></tr>
<tr><td><code>linear</code></td><td>Parenthesized</td><td><code>linear(...)</code></td></tr>
<tr><td><code>link</code></td><td>Parenthesized</td><td><code>link(...)</code></td></tr>
<tr><td><code>local</code></td><td>Parenthesized</td><td><code>local(...)</code></td></tr>
<tr><td><code>looprange</code></td><td>Parenthesized</td><td><code>looprange(...)</code></td></tr>
<tr><td><code>map</code></td><td>Parenthesized</td><td><code>map(...)</code></td></tr>
<tr><td><code>match</code></td><td>Parenthesized</td><td><code>match(...)</code></td></tr>
<tr><td><code>memscope</code></td><td>Parenthesized</td><td><code>memscope(...)</code></td></tr>
<tr><td><code>mergeable</code></td><td>Bare</td><td><code>#pragma omp parallel mergeable</code></td></tr>
<tr><td><code>message</code></td><td>Parenthesized</td><td><code>message(...)</code></td></tr>
<tr><td><code>no_openmp</code></td><td>Flexible</td><td><code>no_openmp</code> or <code>no_openmp(...)</code></td></tr>
<tr><td><code>no_openmp_constructs</code></td><td>Flexible</td><td><code>no_openmp_constructs</code> or <code>no_openmp_constructs(...)</code></td></tr>
<tr><td><code>no_openmp_routines</code></td><td>Flexible</td><td><code>no_openmp_routines</code> or <code>no_openmp_routines(...)</code></td></tr>
<tr><td><code>no_parallelism</code></td><td>Flexible</td><td><code>no_parallelism</code> or <code>no_parallelism(...)</code></td></tr>
<tr><td><code>nocontext</code></td><td>Parenthesized</td><td><code>nocontext(...)</code></td></tr>
<tr><td><code>nogroup</code></td><td>Bare</td><td><code>#pragma omp parallel nogroup</code></td></tr>
<tr><td><code>nontemporal</code></td><td>Parenthesized</td><td><code>nontemporal(...)</code></td></tr>
<tr><td><code>notinbranch</code></td><td>Bare</td><td><code>#pragma omp parallel notinbranch</code></td></tr>
<tr><td><code>novariants</code></td><td>Flexible</td><td><code>novariants</code> or <code>novariants(...)</code></td></tr>
<tr><td><code>nowait</code></td><td>Bare</td><td><code>#pragma omp parallel nowait</code></td></tr>
<tr><td><code>num_tasks</code></td><td>Parenthesized</td><td><code>num_tasks(...)</code></td></tr>
<tr><td><code>num_teams</code></td><td>Parenthesized</td><td><code>num_teams(...)</code></td></tr>
<tr><td><code>num_threads</code></td><td>Parenthesized</td><td><code>num_threads(...)</code></td></tr>
<tr><td><code>order</code></td><td>Parenthesized</td><td><code>order(...)</code></td></tr>
<tr><td><code>ordered</code></td><td>Flexible</td><td><code>ordered</code> or <code>ordered(...)</code></td></tr>
<tr><td><code>otherwise</code></td><td>Parenthesized</td><td><code>otherwise(...)</code></td></tr>
<tr><td><code>partial</code></td><td>Flexible</td><td><code>partial</code> or <code>partial(...)</code></td></tr>
<tr><td><code>permutation</code></td><td>Parenthesized</td><td><code>permutation(...)</code></td></tr>
<tr><td><code>priority</code></td><td>Parenthesized</td><td><code>priority(...)</code></td></tr>
<tr><td><code>private</code></td><td>Parenthesized</td><td><code>private(...)</code></td></tr>
<tr><td><code>proc_bind</code></td><td>Parenthesized</td><td><code>proc_bind(...)</code></td></tr>
<tr><td><code>public</code></td><td>Flexible</td><td><code>public</code> or <code>public(...)</code></td></tr>
<tr><td><code>read</code></td><td>Flexible</td><td><code>read</code> or <code>read(...)</code></td></tr>
<tr><td><code>reduction</code></td><td>Parenthesized</td><td><code>reduction(...)</code></td></tr>
<tr><td><code>relaxed</code></td><td>Bare</td><td><code>#pragma omp parallel relaxed</code></td></tr>
<tr><td><code>release</code></td><td>Bare</td><td><code>#pragma omp parallel release</code></td></tr>
<tr><td><code>replayable</code></td><td>Flexible</td><td><code>replayable</code> or <code>replayable(...)</code></td></tr>
<tr><td><code>reproducible</code></td><td>Bare</td><td><code>#pragma omp parallel reproducible</code></td></tr>
<tr><td><code>reverse</code></td><td>Flexible</td><td><code>reverse</code> or <code>reverse(...)</code></td></tr>
<tr><td><code>reverse_offload</code></td><td>Bare</td><td><code>#pragma omp parallel reverse_offload</code></td></tr>
<tr><td><code>safelen</code></td><td>Parenthesized</td><td><code>safelen(...)</code></td></tr>
<tr><td><code>safesync</code></td><td>Bare</td><td><code>#pragma omp parallel safesync</code></td></tr>
<tr><td><code>schedule</code></td><td>Parenthesized</td><td><code>schedule(...)</code></td></tr>
<tr><td><code>self_maps</code></td><td>Bare</td><td><code>#pragma omp parallel self_maps</code></td></tr>
<tr><td><code>seq_cst</code></td><td>Bare</td><td><code>#pragma omp parallel seq_cst</code></td></tr>
<tr><td><code>severity</code></td><td>Parenthesized</td><td><code>severity(...)</code></td></tr>
<tr><td><code>shared</code></td><td>Parenthesized</td><td><code>shared(...)</code></td></tr>
<tr><td><code>simd</code></td><td>Bare</td><td><code>#pragma omp parallel simd</code></td></tr>
<tr><td><code>simdlen</code></td><td>Parenthesized</td><td><code>simdlen(...)</code></td></tr>
<tr><td><code>sizes</code></td><td>Parenthesized</td><td><code>sizes(...)</code></td></tr>
<tr><td><code>task_reduction</code></td><td>Parenthesized</td><td><code>task_reduction(...)</code></td></tr>
<tr><td><code>thread_limit</code></td><td>Parenthesized</td><td><code>thread_limit(...)</code></td></tr>
<tr><td><code>threads</code></td><td>Bare</td><td><code>#pragma omp parallel threads</code></td></tr>
<tr><td><code>threadset</code></td><td>Parenthesized</td><td><code>threadset(...)</code></td></tr>
<tr><td><code>tile</code></td><td>Parenthesized</td><td><code>tile(...)</code></td></tr>
<tr><td><code>to</code></td><td>Parenthesized</td><td><code>to(...)</code></td></tr>
<tr><td><code>transparent</code></td><td>Flexible</td><td><code>transparent</code> or <code>transparent(...)</code></td></tr>
<tr><td><code>unified_address</code></td><td>Flexible</td><td><code>unified_address</code> or <code>unified_address(...)</code></td></tr>
<tr><td><code>unified_shared_memory</code></td><td>Flexible</td><td><code>unified_shared_memory</code> or <code>unified_shared_memory(...)</code></td></tr>
<tr><td><code>uniform</code></td><td>Parenthesized</td><td><code>uniform(...)</code></td></tr>
<tr><td><code>unroll</code></td><td>Flexible</td><td><code>unroll</code> or <code>unroll(...)</code></td></tr>
<tr><td><code>untied</code></td><td>Bare</td><td><code>#pragma omp parallel untied</code></td></tr>
<tr><td><code>update</code></td><td>Flexible</td><td><code>update</code> or <code>update(...)</code></td></tr>
<tr><td><code>use</code></td><td>Parenthesized</td><td><code>use(...)</code></td></tr>
<tr><td><code>use_device_addr</code></td><td>Parenthesized</td><td><code>use_device_addr(...)</code></td></tr>
<tr><td><code>use_device_ptr</code></td><td>Parenthesized</td><td><code>use_device_ptr(...)</code></td></tr>
<tr><td><code>uses_allocators</code></td><td>Parenthesized</td><td><code>uses_allocators(...)</code></td></tr>
<tr><td><code>weak</code></td><td>Flexible</td><td><code>weak</code> or <code>weak(...)</code></td></tr>
<tr><td><code>when</code></td><td>Parenthesized</td><td><code>when(...)</code></td></tr>
<tr><td><code>write</code></td><td>Flexible</td><td><code>write</code> or <code>write(...)</code></td></tr>
</tbody></table>
</div>
<h2 id="updating-this-index"><a class="header" href="#updating-this-index">Updating this index</a></h2>
<p>The table can be regenerated with the following helper if new clauses are added
or the parser changes a clause rule:</p>
<pre><code class="language-bash">python - &lt;&lt;'PY'
import pathlib, re
text = pathlib.Path('src/parser/openmp.rs').read_text()
block = re.search(r"openmp_clauses!\s*{(.*?)}\s*\n\nmacro_rules!", text, re.S).group(1)
clauses = []
for entry in block.split('},'):
    name_match = re.search(r'name: "([^"]+)"', entry)
    rule_match = re.search(r'rule: ClauseRule::([A-Za-z_]+)', entry)
    if name_match and rule_match:
        clauses.append((name_match.group(1), rule_match.group(1)))
for name, rule in sorted(clauses):
    if rule == 'Bare':
        forms = f"`#pragma omp parallel {name}`"
    elif rule == 'Parenthesized':
        forms = f"`{name}(...)`"
    else:
        forms = f"`{name}` or `{name}(...)`"
    print(f"| `{name}` | {rule} | {forms} |")
PY
</code></pre>
<p>Copy the generated rows into the table above to keep this document aligned with
<code>OpenMpClause::ALL</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openmp-60-restrictions"><a class="header" href="#openmp-60-restrictions">OpenMP 6.0 Restrictions</a></h1>
<p>The OpenMP specification attaches normative "Restrictions" text to almost every
directive and clause.  Rather than duplicating that material (which quickly
falls out of sync), this guide explains how to locate and verify the
restrictions relevant to any construct while working on ROUP.</p>
<h2 id="where-to-look-in-the-specification"><a class="header" href="#where-to-look-in-the-specification">Where to look in the specification</a></h2>
<ul>
<li><strong>Directive sections</strong> – Each directive definition in Chapters 5–17 of the
<a href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-6-0.pdf">OpenMP 6.0 specification</a>
ends with a <em>Restrictions</em> subsection.  The text typically begins with
"Restrictions to the <code>&lt;name&gt;</code> directive are as follows".</li>
<li><strong>Clause sections</strong> – Clause descriptions follow the same pattern, usually
starting with "Restrictions to the <code>&lt;name&gt;</code> clause".</li>
<li><strong>Tables and modifiers</strong> – Map-type modifiers, dependence types, and other
structured lists include restrictions inline with the tables that define the
allowed values.</li>
<li><strong>Language-specific notes</strong> – When the requirements differ between C/C++ and
Fortran, the spec labels each bullet accordingly.  Keep both variants in mind
when adding parser validation or documentation.</li>
</ul>
<h2 id="practical-workflow-for-roup-contributors"><a class="header" href="#practical-workflow-for-roup-contributors">Practical workflow for ROUP contributors</a></h2>
<ol>
<li><strong>Locate the canonical section</strong> using the directive and clause catalogues in
this repository.  Both
<a href="./openmp60-directives-clauses.html"><code>openmp60-directives-clauses.md</code></a> and
<a href="./openmp60-directive-clause-components.html"><code>openmp60-directive-clause-components.md</code></a>
link directly to the parser keywords.</li>
<li><strong>Read the specification subsection</strong> for the construct you are working on
and note any "must", "shall", or "must not" statements.  These are the
normative requirements that need to be respected by higher-level tooling.</li>
<li><strong>Capture parser limitations</strong> in code comments or documentation if ROUP does
not yet enforce a particular rule.  This keeps behaviour transparent for
users of the library and the ompparser compatibility layer.</li>
<li><strong>Add tests where feasible</strong>.  Many restrictions can be unit- or
integration-tested (for example, rejecting a clause form that is not
permitted).  When runtime enforcement is out of scope, reference the relevant
specification section in the documentation so readers know where the gap is.</li>
</ol>
<h2 id="keeping-restriction-notes-accurate"><a class="header" href="#keeping-restriction-notes-accurate">Keeping restriction notes accurate</a></h2>
<ul>
<li><strong>Do not duplicate specification prose</strong> verbatim; link to the relevant
section instead.  This avoids stale text and respects the licence of the
official document.</li>
<li><strong>Record deviations</strong> whenever ROUP intentionally accepts syntax that the
specification would forbid.  Document the reasoning in the relevant module or
test to make review easier.</li>
<li><strong>Use citations</strong> (for example, <code>§7.5.4</code>) when summarising restrictions in
release notes, tutorials, or design documents.  It gives downstream users a
precise pointer back to the standard.</li>
</ul>
<p>By following this workflow the repository remains aligned with the official
standard while still clearly communicating the parser's current behaviour.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-continuations"><a class="header" href="#line-continuations">Line Continuations</a></h1>
<p>⚠️ Experimental: ROUP now understands multi-line OpenMP directives across C, C++, and Fortran. This guide shows how to format
continuations so the parser and ompparser compatibility layer recognize them reliably.</p>
<h2 id="when-to-use-continuations"><a class="header" href="#when-to-use-continuations">When to use continuations</a></h2>
<p>OpenMP pragmas often grow long once multiple clauses are attached. Rather than forcing everything onto a single line, you can
split directives while keeping source files readable. ROUP stitches the continued lines together during lexing, so downstream
APIs still observe canonical single-line directive strings.</p>
<p>Continuations are supported in two situations:</p>
<ul>
<li><strong>C / C++ pragmas</strong> that end a line with a trailing backslash (<code>\</code>).</li>
<li><strong>Fortran sentinels</strong> (<code>!$OMP</code>, <code>C$OMP</code>, <code>*$OMP</code>) that use the standard ampersand (<code>&amp;</code>) continuation syntax.</li>
</ul>
<p>ROUP preserves clause order and trims whitespace that was introduced only to align indentation.</p>
<h2 id="c--c-example"><a class="header" href="#c--c-example">C / C++ example</a></h2>
<pre><code class="language-c">#pragma omp parallel for \
    schedule(dynamic, 4) \
    private(i, \
            j)
</code></pre>
<p>ROUP merges this directive into <code>#pragma omp parallel for schedule(dynamic, 4) private(i, j)</code>. Clause arguments keep their
original spacing. Comments (<code>/* */</code> or <code>//</code>) may appear between continued lines and are ignored during merging.</p>
<h3 id="tips-for-c--c"><a class="header" href="#tips-for-c--c">Tips for C / C++</a></h3>
<ul>
<li>The backslash must be the final character on the line (aside from trailing spaces or tabs).</li>
<li>Windows line endings (<code>\r\n</code>) are handled automatically.</li>
<li>Keep at least one space between the directive name and the first clause on subsequent lines.</li>
</ul>
<h2 id="fortran-free-form-example"><a class="header" href="#fortran-free-form-example">Fortran free-form example</a></h2>
<pre><code class="language-fortran">!$omp target teams distribute &amp;
!$omp parallel do &amp;
!$omp&amp; private(i, j)
</code></pre>
<p>The parser removes the continuation markers and produces <code>!$omp target teams distribute parallel do private(i, j)</code>.</p>
<h3 id="fortran-fixed-form-example"><a class="header" href="#fortran-fixed-form-example">Fortran fixed-form example</a></h3>
<pre><code class="language-fortran">      C$OMP   DO &amp;
      !$OMP&amp; SCHEDULE(DYNAMIC) &amp;
      !$OMP PRIVATE(I) SHARED(A)
</code></pre>
<p>Column prefixes (<code>!</code>, <code>C</code>, or <code>*</code>) are respected. ROUP normalizes the directive to <code>do schedule(DYNAMIC) private(I) shared(A)</code>.</p>
<h3 id="tips-for-fortran-continuations"><a class="header" href="#tips-for-fortran-continuations">Tips for Fortran continuations</a></h3>
<ul>
<li>Terminate every continued line with <code>&amp;</code>. ROUP tolerates trailing comments (e.g., <code>&amp; ! explanation</code>) and skips them automatically.</li>
<li>You may repeat the sentinel on continuation lines (<code>!$OMP&amp;</code>), or start the next line with only <code>&amp;</code>. Both forms are accepted.</li>
<li>Blank continuation lines are ignored as long as they contain only whitespace.</li>
<li>Clause bodies can span multiple lines; nested continuations inside parentheses are collapsed to a single line in the parsed
clause value.</li>
</ul>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<ul>
<li><strong>Missing continuation marker</strong>: If a line break appears without <code>&amp;</code> (Fortran) or <code>\</code> (C/C++), the parser treats the next line
as a separate statement and reports an error or unexpected directive name.</li>
<li><strong>Custom formatting macros</strong>: Preprocessors that insert trailing spaces after <code>\</code> may break continuations. Ensure the backslash
is the final printable character.</li>
<li><strong>Compatibility layer</strong>: The ompparser shim mirrors the same behavior. The comprehensive tests in
<code>compat/ompparser/tests/comprehensive_test.cpp</code> include multi-line inputs for both languages.</li>
</ul>
<p>For more examples, refer to the automated tests in <code>tests/openmp_line_continuations.rs</code> and the parser unit tests in
<code>src/parser/mod.rs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h1>
<p>This chapter explains how ROUP is organised internally and where to look when
modifying the parser or the public bindings.</p>
<h2 id="high-level-view"><a class="header" href="#high-level-view">High level view</a></h2>
<pre><code class="language-text">source text
   │
   ▼
lexer (`src/lexer.rs`)
   │  ─ token stream with language specific helpers
   ▼
parser (`src/parser/`)
   │  ─ builds an intermediate representation (IR)
   ▼
IR (`src/ir/`)
   │  ├─ used directly by Rust callers
   │  └─ converted into the C API data structures
   ▼
C bindings (`src/c_api.rs`)
</code></pre>
<p>The lexer normalises whitespace, line continuations, sentinel comments, and
language specific keywords before the parser consumes the token stream.  The
parser modules mirror the OpenMP structure: directives, clauses, helper
enumerations, and validation passes.  Rust callers typically work with the IR
structures directly, while C and C++ consumers receive stable C structs exposed
through the FFI layer.</p>
<h2 id="unsafe-code-boundaries"><a class="header" href="#unsafe-code-boundaries">Unsafe code boundaries</a></h2>
<p>The vast majority of the project uses safe Rust.  The only <code>unsafe</code> blocks live
inside <code>src/c_api.rs</code> where pointers cross the FFI boundary.  Each function
performs explicit null checks and documents its expectations.  When modifying or
adding FFI functions, keep the following rules in mind:</p>
<ul>
<li>Convert raw pointers to Rust types as late as possible and convert back only
when returning values to the caller.</li>
<li>Maintain ownership invariants: the caller is responsible for freeing values
returned by constructors and must not free borrowed data.</li>
<li>Update the C header generated by <code>build.rs</code> whenever the exported structs or
enums change.</li>
</ul>
<h2 id="generated-constants-and-headers"><a class="header" href="#generated-constants-and-headers">Generated constants and headers</a></h2>
<p>The build script (<code>build.rs</code>) parses portions of <code>src/c_api.rs</code> using <code>syn</code> to
produce <code>compat/include/roup_constants.h</code>.  This keeps the directive and clause
code tables in sync with the Rust implementation.  Run <code>cargo run --bin gen</code>
whenever the mappings change to regenerate and validate the header.</p>
<h2 id="integration-with-ompparser"><a class="header" href="#integration-with-ompparser">Integration with ompparser</a></h2>
<p><code>compat/ompparser/</code> implements a translation layer that mirrors the original
ompparser API.  It forwards calls through the C API and converts the resulting
structures back into the C++ types expected by existing clients.  The
compatibility layer is exercised by the CMake tests in <code>compat/ompparser/tests/</code>
and by a small example executable that links against the produced shared
library.</p>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<p>Integration tests live under <code>tests/</code> and cover keyword registration, parser
round-trips, language specific behaviour, and helper utilities.  Running
<code>cargo test</code> executes the Rust suites, while <code>test.sh</code> orchestrates the full
project matrix including compatibility and documentation builds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-guide"><a class="header" href="#contributing-guide">Contributing Guide</a></h1>
<p>Thank you for your interest in contributing to ROUP! This guide will help you get started.</p>
<hr />
<h2 id="quick-links-1"><a class="header" href="#quick-links-1">Quick Links</a></h2>
<ul>
<li><strong>Source Code</strong>: <a href="https://github.com/ouankou/roup">github.com/ouankou/roup</a></li>
<li><strong>Issue Tracker</strong>: <a href="https://github.com/ouankou/roup/issues">GitHub Issues</a></li>
<li><strong>Discussions</strong>: <a href="https://github.com/ouankou/roup/discussions">GitHub Discussions</a></li>
<li><strong>Documentation</strong>: <a href="https://roup.ouankou.com">roup.ouankou.com</a></li>
</ul>
<hr />
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to Contribute</a></h2>
<h3 id="1-report-bugs"><a class="header" href="#1-report-bugs">1. Report Bugs</a></h3>
<p>Found a bug? Please <a href="https://github.com/ouankou/roup/issues/new">open an issue</a> with:</p>
<ul>
<li><strong>Clear title</strong>: What's wrong?</li>
<li><strong>Input</strong>: The OpenMP directive that caused the issue</li>
<li><strong>Expected</strong>: What should happen?</li>
<li><strong>Actual</strong>: What actually happened?</li>
<li><strong>Environment</strong>: OS, Rust version, ROUP version</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-text">Title: Parser fails on `collapse` clause with variable

Input: #pragma omp for collapse(n)
Expected: Parse successfully
Actual: Parse error: "Expected integer literal"
Environment: Ubuntu 22.04, Rust 1.75, ROUP 0.1.0
```text

### 2. Suggest Features

Have an idea? [Start a discussion](https://github.com/ouankou/roup/discussions) or open an issue with:

- **Use case**: Why is this needed?
- **Proposed API**: How would it work?
- **Alternatives**: Other ways to solve the problem?

### 3. Improve Documentation

Documentation improvements are always welcome:

- Fix typos or unclear explanations
- Add examples
- Improve error messages
- Translate documentation
- Write tutorials or blog posts

See [Documentation Updates](#documentation-updates) below.

### 4. Submit Code

Ready to code? See [Development Setup](#development-setup) and [Pull Request Process](#pull-request-process).

---

## Development Setup

### Prerequisites

- **Rust 1.85+** - [Install Rust](https://rustup.rs/)
- **Git** - Version control
- **mdBook** (optional) - For documentation: `cargo install mdbook`

### Clone and Build

```bash
# Clone repository
git clone https://github.com/ouankou/roup.git
cd roup

# Build library
cargo build

# Run tests
cargo test

# Build documentation
cargo doc --no-deps --open
```text

### Development Tools

**Recommended VS Code Extensions:**
- rust-analyzer
- Even Better TOML
- Error Lens

**Recommended CLI Tools:**
```bash
# Code formatter
rustup component add rustfmt

# Linter
rustup component add clippy

# Documentation builder
cargo install mdbook
```text

---

## Code Quality Standards

### Rust Code

#### 1. Use Safe Rust

**Rule**: Unsafe code is permitted ONLY at the FFI boundary in `src/c_api.rs`.

```rust
// ✅ GOOD: Safe Rust in parser
pub fn parse(input: &amp;str) -&gt; Result&lt;DirectiveIR, ParseError&gt; {
    // All safe code
}

// ❌ BAD: Unsafe in parser
pub fn parse(input: &amp;str) -&gt; Result&lt;DirectiveIR, ParseError&gt; {
    unsafe {  // ← Not allowed outside c_api.rs!
        // ...
    }
}
```text

#### 2. Format Your Code

```bash
# Format all code
cargo fmt

# Check formatting (CI uses this)
cargo fmt -- --check
```text

#### 3. Pass Clippy

```bash
# Run linter
cargo clippy

# CI requires no warnings
cargo clippy -- -D warnings
```text

#### 4. Write Tests

Every new feature or bug fix should include tests.

```rust
#[test]
fn test_new_feature() {
    let result = parse("#pragma omp my_new_directive");
    assert!(result.is_ok());
    // More assertions...
}
```text

#### 5. Document Public APIs

```rust
/// Parse an OpenMP directive from a string.
///
/// # Arguments
///
/// * `input` - The OpenMP directive text
///
/// # Returns
///
/// * `Ok(DirectiveIR)` - Parsed directive
/// * `Err(ParseError)` - Parse failure with location
///
/// # Examples
///
/// ```
/// use roup::parser::parse;
///
/// let directive = parse("#pragma omp parallel").unwrap();
/// assert_eq!(directive.clauses.len(), 0);
/// ```
pub fn parse(input: &amp;str) -&gt; Result&lt;DirectiveIR, ParseError&gt; {
    // ...
}
```text

### C API Code

If modifying `src/c_api.rs`:

- **Minimize unsafe blocks**: Only what's absolutely necessary
- **NULL checks**: Before every pointer dereference
- **Document safety contracts**: Explain caller obligations
- **Test thoroughly**: Including NULL inputs and edge cases

```rust
/// # Safety
///
/// Caller must ensure:
/// - `input` points to a valid null-terminated C string
/// - The string remains valid for the duration of this call
/// - The string is valid UTF-8
#[no_mangle]
pub extern "C" fn roup_parse(input: *const c_char) -&gt; *mut OmpDirective {
    if input.is_null() {
        return std::ptr::null_mut();
    }
    
    // ... minimal unsafe code ...
}
```text

---

## Testing Guidelines

### Running Tests

```bash
# All tests
cargo test

# Specific test
cargo test test_parallel_directive

# Tests with output
cargo test -- --nocapture

# Tests in specific module
cargo test parser::
```text

### Test Categories

#### Unit Tests

Test individual functions in isolation.

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tokenize_identifier() {
        let tokens = tokenize("parallel");
        assert_eq!(tokens.len(), 1);
        assert_eq!(tokens[0], Token::Identifier("parallel"));
    }
}
```text

#### Integration Tests

Test complete parsing workflows in `tests/`.

```rust
// tests/openmp_parallel.rs
#[test]
fn test_parallel_with_clauses() {
    let input = "#pragma omp parallel num_threads(4) private(x)";
    let result = roup::parser::parse(input);
    
    assert!(result.is_ok());
    let directive = result.unwrap();
    assert_eq!(directive.clauses.len(), 2);
}
```text

#### FFI Tests

Test C API safety and correctness.

```rust
#[test]
fn test_null_safety() {
    let dir = roup_parse(std::ptr::null());
    assert!(dir.is_null());
}
```text

### Test Coverage

Aim for:
- **90%+ coverage** for parser code
- **100% coverage** for FFI boundary code
- **All error paths** tested

---

## Documentation Updates

### mdBook Website

The main documentation is in `docs/book/src/`:

```text
docs/book/src/
├── SUMMARY.md           # Navigation (table of contents)
├── intro.md             # Homepage
├── getting-started.md   # Quick start guide
├── rust-tutorial.md     # Rust API tutorial
├── c-tutorial.md        # C API tutorial
├── cpp-tutorial.md      # C++ API tutorial
├── building.md          # Build instructions
├── api-reference.md     # API reference
├── architecture.md      # Internal design
├── openmp-support.md    # OpenMP support matrix
├── contributing.md      # This file
└── faq.md              # Frequently asked questions
```text

#### Building Documentation

```bash
# Build website
cd docs/book
mdbook build

# Serve locally (with live reload)
mdbook serve --open

# View at http://localhost:3000
```text

#### Adding New Pages

1. Create `.md` file in `docs/book/src/`
2. Add to `SUMMARY.md`:
   ```markdown
   - [My New Page](./my-new-page.md)
</code></pre>
<ol start="3">
<li>Build and verify: <code>mdbook build</code></li>
</ol>
<h3 id="rustdoc"><a class="header" href="#rustdoc">Rustdoc</a></h3>
<p>API documentation is generated from source code:</p>
<pre><code class="language-bash"># Generate API docs
cargo doc --no-deps --open

# With private items (for development)
cargo doc --no-deps --document-private-items --open
```text

### README.md

**IMPORTANT**: After any change, check that `README.md` stays in sync:

- API changes → Update README examples
- Feature changes → Update README feature list
- Build changes → Update README installation instructions

The README should match website content in `docs/book/src/`.

---

## Pull Request Process

### 1. Fork and Branch

```bash
# Fork on GitHub, then clone your fork
git clone https://github.com/YOUR_USERNAME/roup.git
cd roup

# Create feature branch
git checkout -b feature/my-awesome-feature
```text

### 2. Make Changes

- Write code
- Write tests
- Update documentation
- Format code: `cargo fmt`
- Run tests: `cargo test`
- Check lints: `cargo clippy`

### 3. Commit

Use clear, descriptive commit messages:

```bash
git commit -m "feat: add support for OpenMP 6.0 loop directive"
git commit -m "fix: handle null pointers in roup_parse"
git commit -m "docs: add examples for metadirective"
git commit -m "test: add tests for error recovery"
```text

**Commit Message Format:**
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation only
- `test:` - Tests only
- `refactor:` - Code refactoring
- `perf:` - Performance improvement
- `chore:` - Maintenance tasks

### 4. Pre-PR Checklist

Before opening a PR, ensure:

- [ ] `cargo fmt -- --check` passes (no formatting issues)
- [ ] `cargo build` passes (no compilation warnings)
- [ ] `cargo clippy` passes (no linter warnings)
- [ ] `cargo test` passes (all tests green)
- [ ] `cargo doc --no-deps` passes (no rustdoc warnings)
- [ ] `mdbook build docs/book` passes (if docs changed)
- [ ] README.md is in sync with changes
- [ ] New features have tests
- [ ] New features have documentation

### 5. Push and Open PR

```bash
# Push to your fork
git push origin feature/my-awesome-feature

# Open PR on GitHub
# Go to https://github.com/ouankou/roup and click "New Pull Request"
```text

### 6. PR Description

Include:

**What**: What does this PR do?

**Why**: Why is this change needed?

**How**: How does it work?

**Testing**: How was it tested?

**Example:**
```markdown
## What
Adds support for the OpenMP 6.0 `loop` directive.

## Why
OpenMP 6.0 introduced a new `loop` directive as a more generic alternative to `for`.

## How
- Added `Loop` variant to `DirectiveKind` enum
- Added parsing logic in `directive.rs`
- Updated OpenMP support matrix

## Testing
- Added 15 new test cases covering various `loop` directive forms
- All existing tests still pass
- Manually tested with real-world code
```text

### 7. Code Review

Maintainers will review your PR and may:

- Request changes
- Ask questions
- Suggest improvements

**Be patient and responsive!** Code review is a collaborative process.

### 8. Merge

Once approved, maintainers will merge your PR. Congratulations! 🎉

---

## OpenMP Specification Compliance

When adding support for new OpenMP features:

### 1. Consult Official Specs

- **OpenMP 6.0**: [Latest specification](https://www.openmp.org/specifications/)
- **Archive**: [Older versions](https://www.openmp.org/specifications/)

### 2. Check Syntax Carefully

OpenMP syntax can be subtle. Double-check:

- Required vs optional clauses
- Clause argument types
- Directive applicability (C/C++ vs Fortran)
- Version introduced

### 3. Update Support Matrix

After adding a directive/clause, update `docs/book/src/openmp-support.md`:

```markdown
| Directive | OpenMP Version | Status | Notes |
|-----------|----------------|--------|-------|
| `loop` | 5.0 | ✅ Supported | New in OpenMP 5.0 |
```text

### 4. Add Examples

Include examples in documentation showing correct usage.

---

## Performance Considerations

### Benchmarking

If your change affects performance:

```bash
# Run benchmarks (if available)
cargo bench

# Profile with flamegraph
cargo install flamegraph
cargo flamegraph --bin roup
```text

### Performance Guidelines

- Avoid unnecessary allocations
- Prefer zero-copy when possible
- Use `&amp;str` instead of `String` where appropriate
- Benchmark before/after for significant changes

---

## Security

### Reporting Security Issues

Please report security vulnerabilities by opening a GitHub issue at:
[https://github.com/ouankou/roup/issues](https://github.com/ouankou/roup/issues)

Include:
- Description of vulnerability
- Steps to reproduce
- Potential impact
- Suggested fix (if any)

### Security Best Practices

When writing code:

- Validate all inputs
- Check for integer overflow
- Avoid buffer overruns
- Be careful with unsafe code
- Use safe defaults

---

## Release Process

(For maintainers)

### Version Numbering

ROUP follows [Semantic Versioning](https://semver.org/):

- **MAJOR**: Breaking API changes
- **MINOR**: New features (backward compatible)
- **PATCH**: Bug fixes (backward compatible)

### Release Checklist

1. Update version in `Cargo.toml`
2. Update `CHANGELOG.md`
3. Run full test suite
4. Build documentation
5. Create git tag: `git tag v0.2.0`
6. Push tag: `git push origin v0.2.0`
7. Publish to crates.io: `cargo publish`
8. Create GitHub release with notes

---

## Getting Help

### Stuck?

- **Documentation**: Read [roup.ouankou.com](https://roup.ouankou.com)
- **Discussions**: Ask on [GitHub Discussions](https://github.com/ouankou/roup/discussions)
- **Issues**: Search [existing issues](https://github.com/ouankou/roup/issues)
- **Examples**: Check `examples/` directory

### Communication Guidelines

- Be respectful and professional
- Provide context for questions
- Include minimal reproducible examples
- Search before asking (avoid duplicates)

---

## Code of Conduct

### Our Standards

- **Be respectful**: Treat everyone with respect
- **Be constructive**: Provide helpful feedback
- **Be patient**: Remember that everyone is learning
- **Be inclusive**: Welcome newcomers

### Unacceptable Behavior

- Harassment or discrimination
- Trolling or insulting comments
- Personal attacks
- Publishing others' private information

### Reporting

Report unacceptable behavior to: [conduct@ouankou.com](mailto:conduct@ouankou.com)

---

## Recognition

Contributors will be:

- Listed in `CONTRIBUTORS.md`
- Mentioned in release notes
- Credited in commit messages

Significant contributions may result in:

- Maintainer status
- Commit access
- Decision-making authority

---

## License

By contributing, you agree that your contributions will be licensed under the same license as the project (see `LICENSE` file).

---

## Questions?

Still have questions? Open a [discussion](https://github.com/ouankou/roup/discussions) or reach out to the maintainers.

**Thank you for contributing to ROUP!** 🚀
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<h3 id="what-is-roup-1"><a class="header" href="#what-is-roup-1">What is ROUP?</a></h3>
<p>ROUP is a Rust library that parses OpenMP directives and exposes the result to
Rust, C, C++, and Fortran consumers.  It focuses on analysing and transforming
existing OpenMP code rather than compiling it.</p>
<h3 id="is-roup-production-ready"><a class="header" href="#is-roup-production-ready">Is ROUP production ready?</a></h3>
<p>Not yet.  The project is actively developed and APIs may change between
releases.  Treat the current builds as experimental and review the release notes
for the latest status updates.</p>
<h3 id="which-openmp-versions-are-supported"><a class="header" href="#which-openmp-versions-are-supported">Which OpenMP versions are supported?</a></h3>
<p>The parser tracks the OpenMP 6.0 specification.  Integration tests exercise the
keyword registry, loop-transform directives, meta-directives, and device
constructs.  Unsupported constructs fail with descriptive parse errors instead
of being silently accepted.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="how-do-i-install-roup-for-rust"><a class="header" href="#how-do-i-install-roup-for-rust">How do I install ROUP for Rust?</a></h3>
<p>Add the crate to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
roup = "0.5"
</code></pre>
<h3 id="how-do-i-use-roup-from-c-or-c"><a class="header" href="#how-do-i-use-roup-from-c-or-c">How do I use ROUP from C or C++?</a></h3>
<p>Build the library with <code>cargo build --release</code> and link against the generated
artefact (<code>libroup.so</code>, <code>libroup.dylib</code>, or <code>roup.dll</code>).  The C API is declared
in <code>compat/include/roup.h</code>, which is generated from <code>src/c_api.rs</code> by the build
script.</p>
<h3 id="what-toolchains-are-required"><a class="header" href="#what-toolchains-are-required">What toolchains are required?</a></h3>
<ul>
<li>Rust 1.85 or newer (matches the MSRV in <code>Cargo.toml</code>).</li>
<li>A C/C++ compiler when using the FFI bindings.</li>
<li>Optional: Fortran compiler for the Fortran examples.</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="how-do-i-parse-a-directive"><a class="header" href="#how-do-i-parse-a-directive">How do I parse a directive?</a></h3>
<pre><code class="language-rust ignore">use roup::parser::openmp;

let parser = openmp::parser();
let (_, directive) = parser.parse("#pragma omp parallel for").expect("parse");
println!("kind: {}", directive.name);</code></pre>
<h3 id="how-do-i-walk-clauses-from-c"><a class="header" href="#how-do-i-walk-clauses-from-c">How do I walk clauses from C?</a></h3>
<pre><code class="language-c">OmpClauseIterator* it = roup_directive_clauses_iter(dir);
OmpClause* clause = NULL;
while (roup_clause_iterator_next(it, &amp;clause)) {
    printf("clause kind: %d\n", roup_clause_kind(clause));
}
roup_clause_iterator_free(it);
</code></pre>
<h2 id="testing-and-contributing"><a class="header" href="#testing-and-contributing">Testing and contributing</a></h2>
<h3 id="which-tests-should-i-run-before-sending-a-change"><a class="header" href="#which-tests-should-i-run-before-sending-a-change">Which tests should I run before sending a change?</a></h3>
<p>At minimum run <code>cargo test</code>.  For thorough coverage run <code>./test.sh</code> and
<code>./test_rust_versions.sh</code> (see <code>TESTING.md</code> for details).  These scripts build
examples, execute the ompparser compatibility tests, and verify the
documentation.</p>
<h3 id="where-can-i-learn-more"><a class="header" href="#where-can-i-learn-more">Where can I learn more?</a></h3>
<ul>
<li><a href="./getting-started.html">Getting started</a></li>
<li><a href="./architecture.html">Architecture</a></li>
<li><a href="./openmp-support.html">OpenMP support overview</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
